# file opened: .//rom_a.asm
   1  0000              ; ****************************************************************************
   2  0000              ; * Assembly File Listing to generate 4K "ROM A" for Galaksija microcomputer *
   3  0000              ; ****************************************************************************
   4  0000
   5  0000              ; Introduction
   6  0000              ; ************
   7  0000
   8  0000              ; Disassembled from a binary ROM image and annotated by
   9  0000              ; Tomaz Solc (tomaz.solc@tablix.org)
  10  0000              ; using z80dasm (http://www.tablix.org/~avian/blog/articles/z80dasm)
  11  0000              ; between September 2006 and September 2007
  12  0000
  13  0000              ; The original assembly listing, complete with its lack of useful comments
  14  0000              ; is available at:
  15  0000
  16  0000              ; http://www.galaksija.org/hr/index.php?title=Disasemblirani_ROM_A
  17  0000
  18  0000              ; (Titled "MALI RACUNAR GALAKSIJA" by Voja Antonic 03.01.1984)
  19  0000
  20  0000              ; $Id: rom1.asm,v 1.26 2007-09-23 12:06:17 avian Exp $
  21  0000
  22  0000              ; "ROM A" contains basic operating system of Galaksija, which can be roughly
  23  0000              ; separated into following sections:
  24  0000
  25  0000              ;	o Initialization routines,
  26  0000              ;	o video driver,
  27  0000              ;	o keyboard scanning and simple terminal emulation,
  28  0000              ;	o BASIC interpreter,
  29  0000              ;	o RPN FP calculator and
  30  0000              ;	o audio cassette load/save routines.
  31  0000
  32  0000              ; This ROM is a work of art when you consider how tighly optimized for size
  33  0000              ; it is and a nightmare if you wish to completely understand or even modify
  34  0000              ; anything in it.
  35  0000
  36  0000              ; This disassembly is a work in progress. Sections of the code remain
  37  0000              ; uncommented, however this file should assemble into a binary that is
  38  0000              ; identical to the original ROM image.
  39  0000
  40  0000              ; Any contributions (for example additional comments on the code, patches,
  41  0000              ; etc.) are most welcome at tomaz.solc@tablix.org.
  42  0000
  43  0000
  44  0000              ; Code sightseeing
  45  0000              ; ****************
  46  0000
  47  0000              ; A must-see list of 10 most-interesting parts of code:
  48  0000
  49  0000              ; l0098h	Part of video driver code used as ASCII string for
  50  0000              ;		BASIC interpreter.
  51  0000
  52  0000              ; l00a0h	Part of video driver code used a 1.0 floating point
  53  0000              ;		constant.
  54  0000
  55  0000              ; l0038h	Video driver code as a whole, tuned to one T cycle accuracy.
  56  0000
  57  0000              ; l038ch	A tutorial on how to use "ld" instructions instead of "jr"
  58  0000              ; l0393h	and save a few bytes in the process.
  59  0000              ; l0396h
  60  0000
  61  0000              ; l0018h	A function that gets its arguments from bytes in ROM that
  62  0000              ;		follow its call.
  63  0000
  64  0000              ; l0d2ah	Increasing randomness of pseudo-random generator by changing
  65  0000              ;		the seed after some keys are pressed.
  66  0000
  67  0000              ; l0d70h	One look-up table nested inside unused space of another.
  68  0000
  69  0000              ; l06cfh	DOT - a true multi-purpose function: query, set or reset a
  70  0000              ;		pseudo-graphic pixel or turn real time clock on or off
  71  0000              ;		all in one block of code.
  72  0000
  73  0000              ; l0e58h	Record one additional garbage byte at the end of an audio tape
  74  0000              ;		because it saves one "jr" instruction in ROM.
  75  0000
  76  0000              ; l0fffh	One spare byte for future expansions.
  77  0000
  78  0000
  79  0000              ; About the latch
  80  0000              ; ***************
  81  0000
  82  0000              ; A 6-bit register (called "latch" in the original documentation) can be
  83  0000              ; accessed on all memory addresses that can be written in binary as
  84  0000
  85  0000              ; 0 0 1 0  0 x x x  x x 1 1  1 x x x
  86  0000              ; (for example 207fh as used in VIDEO_INT)
  87  0000
  88  0000              ; The content is write-only. A read from these addresses will return an
  89  0000              ; unspecified value.
  90  0000
  91  0000              ; Individual bits have the following meaning:
  92  0000              ;
  93  0000              ;  7	Clamp RAM A7 to one (1 disabled, 0 enabled)
  94  0000              ;  ---
  95  0000              ;  6    Cassette port output bit 0
  96  0000              ;  ---
  97  0000              ;  5    Character generator row bit 3
  98  0000              ;  ---
  99  0000              ;  4	Character generator row bit 2
 100  0000              ;  ---
 101  0000              ;  3	Character generator row bit 1
 102  0000              ;  ---
 103  0000              ;  2	Character generator row bit 0
 104  0000              ;	Cassette port output bit 1
 105  0000              ;  ---
 106  0000              ;  1	Unused
 107  0000              ;  ---
 108  0000              ;  0	Unused
 109  0000
 110  0000              ;  Character generator row bits hold the current row of the character being
 111  0000              ;  drawn to the screen.
 112  0000
 113  0000              ;  Cassette port is high if both output bits are 1, low if both are 0 and
 114  0000              ;  zero if one bit is 1 and one is 0.
 115  0000
 116  0000              ;  Bit 7 forces RAM address line A7 to one. This is required because the top
 117  0000              ;  bit of the R register never changes (only bottom 7 bits are incremented
 118  0000              ;  during each opcode).
 119  0000
 120  0000
 121  0000
 122  0000              ; ROM A is mapped to memory addresses from 0000h to 0fffh
 123  0000
 124  0000              	org	00000h
 125  0000
 126  0000
 127  0000              ; 'START'
 128  0000              ; =======
 129  0000              ; At power on Z80 starts to execute code here. Interrupt mode is set to 0.
 130  0000
 131  0000              ;; START
 132  0000              l0000h:
 133  0000 F3           	di		;0000   Disable interrupts
 134  0001 97           	sub a		;0001	Clear accumulator
 135  0002 C3 DA 03     	jp l03dah	;0002	Jump forward to START_2, the remainder of
 136  0005              			;	the initialization code.
 137  0005
 138  0005              ; 'EVALUATE NEXT INTEGER ARGUMENT'
 139  0005              ; ================================
 140  0005              ; Evaluate an integer expression at DE behind a ASCII comma. If comma is not
 141  0005              ; found, jump to WHAT_RST.
 142  0005
 143  0005              ;; EVAL_INT_EXP_NEXT
 144  0005              l0005h:
 145  0005 DF           	rst 18h		;0005	Call READ_PAR
 146  0006 2C           	db ','		;0006
 147  0007 2C           	db l0034h-$-1	;0007	Jump to WHAT_RST if there is no next argument
 148  0008              			;	at DE.
 149  0008
 150  0008              ; 'EVALUATE INTEGER EXPRESSION'
 151  0008              ; =============================
 152  0008              ; Evaluate an integer expression at DE and return the result in HL.
 153  0008
 154  0008              ;; EVAL_INT_EXP
 155  0008              l0008h:
 156  0008 CD B2 0A     	call l0ab2h	;0008	Call EVAL_EXPRESSION
 157  000B C3 6D 0A     	jp l0a6dh	;000b	Jump to FP_TO_INT and return.
 158  000E
 159  000E              ; 'FAST MODE'
 160  000E              ; ===========
 161  000E              ; Disable video interrupt.
 162  000E
 163  000E              ;; FAST
 164  000E              l000eh:
 165  000E F3           	di		;000e
 166  000F C9           	ret		;000f
 167  0010
 168  0010              ; 'COMPARE HL WITH DE'
 169  0010              ; ====================
 170  0010              ; This function compares HL with DE register pair and sets C and Z flags
 171  0010              ; accordingly
 172  0010
 173  0010              ; Parameters:
 174  0010              ;	DE, HL: values to be compared
 175  0010              ; Returns:
 176  0010              ;	C, Z flag
 177  0010              ; Destroys:
 178  0010              ;	A, all other flags
 179  0010
 180  0010              ;; CMP_HL_DE
 181  0010              l0010h:
 182  0010 7C           	ld a,h		;0010	Load H into A
 183  0011 BA           	cp d		;0011	Compare with D
 184  0012 C0           	ret nz		;0012	Return if not equal
 185  0013 7D           	ld a,l		;0013	Load L into A
 186  0014 BB           	cp e		;0014	Compare with E
 187  0015 C9           	ret		;0015	Return
 188  0016
 189  0016              ; 'SLOW MODE'
 190  0016              ; ===========
 191  0016              ; Enable video interrupt.
 192  0016
 193  0016              ;; SLOW
 194  0016              l0016h:
 195  0016 FB           	ei		;0016
 196  0017 C9           	ret		;0017
 197  0018
 198  0018              ; 'READ PARAMETER'
 199  0018              ; ================
 200  0018              ; This function reads the byte following the calling "rst" instruction and
 201  0018              ; returns to a different location (specified with the second following byte)
 202  0018              ; if the byte doesn't match the first non-space character in the string pointed
 203  0018              ; to by DE register.
 204  0018
 205  0018              ; Example:
 206  0018              ;	rst 18h		; 0005
 207  0018              ;	db ','		; 0006
 208  0018              ;	db 02ch		; 0007
 209  0018              ;       ...		; 0008
 210  0018
 211  0018              ; This compares the first non-space character in DE with ASCII comma ','
 212  0018              ; ignoring any leading space. If it matches, READ PARAMETER returns to the next
 213  0018              ; instruction following the two bytes (at 0008h). If not, it adds 02ch to this
 214  0018              ; return address (in this case it would return to 0034h). In the first case
 215  0018              ; DE is also incremented to account for the matched byte.
 216  0018
 217  0018              ; In pseudo-code:
 218  0018              ;
 219  0018              ; If (**SP) == (EAT_SPACE(DE)) Then
 220  0018              ;	*SP=*SP+2
 221  0018              ; 	DE=DE+1
 222  0018              ; Else
 223  0018              ;	*SP=*SP+2+(*(*SP+1))
 224  0018              ; End
 225  0018
 226  0018              ; Parameters:
 227  0018              ;	DE: Pointer a string.
 228  0018              ; Returns:
 229  0018              ;	DE: Skips leading space and increments DE, if there is a match.
 230  0018              ;	A: First non-space character in DE.
 231  0018              ;	Zf: Set if character matches, reset if not.
 232  0018              ; Destroys:
 233  0018              ;	flags.
 234  0018
 235  0018              ;; READ_PAR
 236  0018              l0018h:
 237  0018 E3           	ex (sp),hl	;0018	Load a pointer from top of stack into HL
 238  0019
 239  0019 CD 05 01     	call l0105h	;0019	Call EAT_SPACE
 240  001C
 241  001C BE           	cp (hl)		;001c	Compare memory pointed by HL with A
 242  001D C3 94 01     	jp l0194h	;001d	Jump to the rest of the function at READ_PAR_2
 243  0020
 244  0020              ; 'PUT CHARACTER ON SCREEN'
 245  0020              ; =========================
 246  0020              ; Print a character in A to the screen at the current cursor position
 247  0020              ; (CURSOR_POS)
 248  0020
 249  0020              ; Parameters:
 250  0020              ;	A: Character to print
 251  0020              ; Returns:
 252  0020              ;	HL': Position of the printed character + 1
 253  0020              ; Destroys:
 254  0020              ;	flags
 255  0020
 256  0020              ;; PUTCH_RST
 257  0020              l0020h:
 258  0020 D9           	exx		;0020	Save BC, DE and HL registers
 259  0021
 260  0021 FE 20        	cp 020h		;0021	Set C flag if character is ASCII special.
 261  0023              			;	(ASCII code less than 20h)
 262  0023
 263  0023 CD B5 09     	call l09b5h	;0023	Jump to remainder of function.
 264  0026 D9           	exx		;0026	Restore BC, DE and HL registers.
 265  0027 C9           	ret		;0027	Return
 266  0028
 267  0028              ; 'CLEAR HL'
 268  0028              ; ==========
 269  0028              ; Loads 0000h into HL
 270  0028
 271  0028              ;; CLEAR_HL
 272  0028              l0028h:
 273  0028 21 00 00     	ld hl,l0000h	;0028	Load 0000h into HL
 274  002B C9           	ret		;002b	Return
 275  002C
 276  002C
 277  002C              ; 'ONE OVER TEN FLOATING POINT CONSTANT'
 278  002C              ; ======================================
 279  002C              ; Approximately 0.1 in four-byte floating point format.
 280  002C
 281  002C              ;; FP_ONE_OVER_TEN
 282  002C              l002ch:
 283  002C CC           	db	0cch	;002c	Mantissa: cccccch
 284  002D CC           	db	0cch	;002d
 285  002E CC           	db 	0cch	;002e	Sign: 00h
 286  002F 7E           	db	07eh	;002f   Exponent: fdh
 287  0030
 288  0030              ; 'NEXT BASIC STATEMENT'
 289  0030              ; ======================
 290  0030              ; Continue execution of the next BASIC statement. BASIC commands call this
 291  0030              ; function at the end. It never returns.
 292  0030
 293  0030              ;; BASIC_NEXT
 294  0030              l0030h:
 295  0030 F1           	pop af		;0030	Remove return address from stack
 296  0031 CD 14 04     	call l0414h	;0031	Call CONTINUE
 297  0034
 298  0034              l0034h:
 299  0034 C3 8F 07     	jp l078fh	;0034	Jump to WHAT_RST if CONTINUE found no
 300  0037              			;	valid next command.
 301  0037
 302  0037              ; 'ROM A VERSION'
 303  0037              ; ===============
 304  0037
 305  0037              ;; ROM_VERSION
 306  0037 1C           	db	28	;0037
 307  0038
 308  0038              ; 'VIDEO INTERRUPT DRIVER'
 309  0038              ; ========================
 310  0038              ; This routine gets called 50 times per second via the Z80's maskable
 311  0038              ; interrupt.
 312  0038
 313  0038              ; Interrupt gets triggered on the vertical sync impulse. Video synchronization
 314  0038              ; hardware then makes sure (by inserting WAIT states) that the first opcode
 315  0038              ; starts to execute exactly in sync with the next horizontal sync.
 316  0038
 317  0038              ; Timing is very important here! This routine must execute in perfect sync
 318  0038              ; with the video hardware.
 319  0038
 320  0038              ; The routine must make sure that the R and I registers are properly set at
 321  0038              ; exactly the right time so that the Z80's memory refresh feature can start
 322  0038              ; reading video line data from video RAM. It also must latch the correct video
 323  0038              ; line number into the register connected to the character generator ROM and
 324  0038              ; adjust the RAM memory map if needed (A7 line).
 325  0038
 326  0038              ; The address of a character on screen:
 327  0038              ;
 328  0038              ;					A7 from latch
 329  0038              ;                                       |
 330  0038              ;                    <-- I register |   | | R register -->
 331  0038              ;              ||                   ||  v |              ||
 332  0038              ; Address bits || 11 | 10 |  9 |  8 ||  7 |  6 |  5 |  4 ||  3 |  2 |  1 |  0
 333  0038              ;              ||              |    ||              |    ||
 334  0038              ;                              |                    |
 335  0038              ;     <-- Base address (2800h) |  Row (4 bits)      | Column (5 bits)
 336  0038
 337  0038              ;; VIDEO_INT			T states
 338  0038              l0038h:
 339  0038 F5           	push af		;0038	11	Save all used registers on the stack.
 340  0039 C5           	push bc		;0039	11
 341  003A D5           	push de		;003a	11
 342  003B E5           	push hl		;003b	11
 343  003C
 344  003C 21 B0 2B     	ld hl,02bb0h	;003c	10	Load SCROLL_CNT address to HL
 345  003F 3E C0        	ld a,0c0h	;003f	7	Load A with 192
 346  0041 96           	sub (hl)	;0041	7
 347  0042 96           	sub (hl)	;0042	7
 348  0043 96           	sub (hl)	;0043	7	Subtract 3 * SCROLL_CNT from A
 349  0044 5F           	ld e,a		;0044 	4	Load result into E
 350  0045
 351  0045 7E           	ld a,(hl)	;0045	7	Load A with value from SCROLL_CNT
 352  0046 0F           	rrca		;0046	4	Rotate right A three times
 353  0047 0F           	rrca		;0047	4
 354  0048 0F           	rrca		;0048	4
 355  0049 47           	ld b,a		;0049	4 	Load result into B
 356  004A
 357  004A B7           	or a		;004a	4 	set Z flag if A = 0
 358  004B              			;		reset C flag
 359  004B              			;	-----
 360  004B              			;       113
 361  004B
 362  004B              ; The following code is a pause with length (24 + B * 18) T states.
 363  004B              ; This determines the vertical position of the screen.
 364  004B
 365  004B 28 00        	jr z,l004dh	;004b	12/7	Wait 5 T states if Z set...
 366  004D              l004dh:
 367  004D 28 05        	jr z,l0054h	;004d	12/7	and jump forward
 368  004F 35           	dec (hl)	;004f	11	... else decrement SCROLL_CNT
 369  0050 AF           	xor a		;0050	4	    clear A (reset C flag)
 370  0051              l0051h:
 371  0051 D8           	ret c		;0051	5	    wait 5 T states
 372  0052              			;		    (C flag always reset)
 373  0052 10 FD        	djnz l0051h	;0052	13/8        ... loop B times
 374  0054
 375  0054
 376  0054              l0054h:
 377  0054 23           	inc hl		;0054	6	Load SCROLL_FLAG address to HL
 378  0055 77           	ld (hl),a	;0055	13	Set SCROLL_FLAG = 0
 379  0056
 380  0056 43           	ld b,e		;0056	4	Set B = 192 - 3 * SCROLL_CNT
 381  0057 21 7F 20     	ld hl,0207fh	;0057	10	Load latch address to HL
 382  005A 4D           	ld c,l		;005a	4	Load C with 7fh
 383  005B
 384  005B 3A A8 2B     	ld a,(02ba8h)	;005b	13	Load A with HORIZ_POS
 385  005E 1F           	rra		;005e	4 	Divide A with 2 (C flag always reset)
 386  005F              			;		load bit 0 into C flag.
 387  005F              			;	----
 388  005F              			;	54
 389  005F
 390  005F              ; B holds the total number of scanlines to be drawn.
 391  005F
 392  005F              ; C holds the current line number
 393  005F
 394  005F              ; During one iteration of VIDEO_DISPLAY_LOOP one line of characters is drawn.
 395  005F
 396  005F              ; Here is another pause with length (2 + 5 * Cf + 16 * A) T states.
 397  005F              ; This determines the horizontal position of the screen.
 398  005F              ; Note: HORIZ_POS must be >= 2.
 399  005F
 400  005F              ; On later iterations of VIDEO_DISPLAY_LOOP A is always set to 3, this means
 401  005F              ; a constant pause of 43 T states
 402  005F
 403  005F 38 00        	jr c,l0061h	;005f	12/7	Wait 5 T if HORIZ_POS odd.
 404  0061
 405  0061              ;; VIDEO_DISPLAY_LOOP
 406  0061              l0061h:
 407  0061 3D           	dec a		;0061	4	Decrement A
 408  0062 20 FD        	jr nz,l0061h	;0062	12/7	...loop A times
 409  0064
 410  0064 18 07        	jr l006dh	;0064	12	Jump forward
 411  0066
 412  0066              ; 'HARD BREAK'
 413  0066              ; ============
 414  0066              ; On a non-maskable interrupt, Z80 jumps here. This is used as a "hard break"
 415  0066              ; button on Galaksija.
 416  0066
 417  0066              ;; HARD_BREAK
 418  0066 F3           	di		;0066		Disable interrupts.
 419  0067
 420  0067              ; 'RESET BASIC'
 421  0067              ; =============
 422  0067              ; Resets BASIC interpreter.
 423  0067
 424  0067              ;; RESET_BASIC
 425  0067              l0067h:
 426  0067 31 A8 2B     	ld sp,02ba8h	;0067	Load HORIZ_POS address to SP
 427  006A C3 17 03     	jp l0317h	;006a	Jump to the rest at RESET_BASIC_2
 428  006D
 429  006D              ; Continuing VIDEO_DISPLAY_LOOP
 430  006D
 431  006D              l006dh:
 432  006D 0C           	inc c		;006d	4	Increment C
 433  006E
 434  006E 79           	ld a,c		;006e	4	Load A with C
 435  006F E6 08        	and 008h	;006f	7	Set A = A & 08h
 436  0071 0F           	rrca		;0071	4	Rotate A right 3 times
 437  0072 0F           	rrca		;0072	4
 438  0073 0F           	rrca		;0073	4
 439  0074 F6 28        	or 028h		;0074	7 	Set A = A | 28h
 440  0076 ED 47        	ld i,a		;0076	9	Load I with result
 441  0078
 442  0078              			;		I now has the upper 8 bits of the
 443  0078              			;		address for the line that will
 444  0078              			;		be drawn to the sceeen (either 28h
 445  0078              			;		or 29h)
 446  0078
 447  0078 13           	inc de		;0078	6	NOP
 448  0079 11 0C 08     	ld de,0080ch	;0079	10	Load DE with 080ch
 449  007C 79           	ld a,c		;007c	4	Load A with C
 450  007D 0F           	rrca		;007d	4	Rotate A right 3 times
 451  007E 0F           	rrca		;007e	4
 452  007F 0F           	rrca		;007f	4
 453  0080 3F           	ccf		;0080	4	Complement C flag
 454  0081 CB 1A        	rr d		;0081	8	Rotate D right through C flag
 455  0083              			;		D is now 84h or 04h
 456  0083
 457  0083              			;		The MSB determines whether the RAM
 458  0083              			;		address line A7 will be forced to 1
 459  0083
 460  0083 F6 1F        	or 01fh		;0083	7	Set A = A | 1fh
 461  0085 07           	rlca		;0085	4	Rotate left
 462  0086 D6 40        	sub 040h	;0086	7	Subtract 40h
 463  0088 0F           	rrca		;0088	4	Rotate right
 464  0089 ED 4F        	ld r,a		;0089	9	Load R with A
 465  008B
 466  008B              ; E holds the number of scan lines to be drawn for this line of characters.
 467  008B
 468  008B              ; During one iteration of VIDEO_LINE_LOOP one scanline of video is drawn.
 469  008B
 470  008B              ;; VIDEO_LINE_LOOP
 471  008B              l008bh:
 472  008B 72           	ld (hl),d	;008b	7 	Latch value in D to the character
 473  008C              			;		generator register
 474  008C
 475  008C              ; Opcodes are arbitrary, but must all consist of 4 T states (one M state) -
 476  008C              ; 8 pixels are drawn during each opcode.
 477  008C
 478  008C 14           	inc d		;008c	4
 479  008D 14           	inc d		;008d	4
 480  008E 14           	inc d		;008e	4
 481  008F 14           	inc d		;008f	4
 482  0090 AF           	xor a		;0090	4
 483  0091 37           	scf		;0091	4
 484  0092 1F           	rra		;0092	4
 485  0093 1F           	rra		;0093	4
 486  0094 AA           	xor d		;0094	4
 487  0095 57           	ld d,a		;0095	4
 488  0096 61           	ld h,c		;0096	4
 489  0097 78           	ld a,b		;0097	4
 490  0098
 491  0098              ;; BREAK_STRING
 492  0098              l0098h:
 493  0098
 494  0098              ; This part of the line drawing code also serves as a string "BREAK" for the
 495  0098              ; basic interepreter.
 496  0098
 497  0098 42           	ld b,d		;0098	4 	B
 498  0099 52           	ld d,d		;0099	4 	R
 499  009A 45           	ld b,l		;009a	4 	E
 500  009B 41           	ld b,c		;009b	4 	A
 501  009C 4B           	ld c,e		;009c	4 	K
 502  009D 00           	nop		;009d	4 	\0
 503  009E
 504  009E 47           	ld b,a		;009e	4
 505  009F 4C           	ld c,h		;009f	4
 506  00A0
 507  00A0              ; This part of the line drawing code also serves as a constant 1.0 in four-byte
 508  00A0              ; floating point format.
 509  00A0
 510  00A0              ;; FP_ONE
 511  00A0              l00a0h:
 512  00A0 00           	nop		;00a0	4	00h	Mantissa: 800000h
 513  00A1 00           	nop		;00a1	4	00h
 514  00A2 80           	add a,b		;00a2	4	80h	Sign bit: 00h
 515  00A3 00           	nop		;00a3	4	00h	Exponent: 01h
 516  00A4
 517  00A4 AF           	xor a		;00a4	4
 518  00A5 37           	scf		;00a5	4
 519  00A6 1F           	rra		;00a6	4
 520  00A7 1F           	rra		;00a7	4
 521  00A8 1F           	rra		;00a8	4
 522  00A9 67           	ld h,a		;00a9	4
 523  00AA 17           	rla		;00aa	4
 524  00AB
 525  00AB              ; At the end of line drawing:
 526  00AB              ; 	A = 40h
 527  00AB              ;	B remains unmodified
 528  00AB              ;	C remains unmodified
 529  00AB              ;	D = 40h XOR (D + 4)
 530  00AB              ;	E remains unmodified
 531  00AB              ; 	HL remains unmodified (207fh)
 532  00AB
 533  00AB 77           	ld (hl),a	;00ab	10	During the last character we clear
 534  00AC              			;		the register so nothing gets
 535  00AC              			;		drawn outside the screen (character
 536  00AC              			;		generator line 0)
 537  00AC
 538  00AC              ; End of line drawing
 539  00AC
 540  00AC 05           	dec b		;00ac	4	Decrement B
 541  00AD 28 0F        	jr z,l00beh	;00ad	12/7	Break from loop if B is zero.
 542  00AF
 543  00AF ED 5F        	ld a,r		;00af	9	Load A with R
 544  00B1 D6 27        	sub 027h	;00b1	7	Subtract 27h
 545  00B3 A5           	and l		;00b3	4	Clear the top bit (L = 7fh)
 546  00B4              			;		This bit is provided by A7 clamp
 547  00B4 ED 4F        	ld r,a		;00b4	9	Load R with A
 548  00B6
 549  00B6 1D           	dec e		;00b6	4	Decrement E
 550  00B7 C2 8B 00     	jp nz,l008bh	;00b7	12/7	If not zero jump to VIDEO_LINE_LOOP
 551  00BA
 552  00BA 3E 03        	ld a,003h	;00ba	7	Load A with 03h
 553  00BC 18 A3        	jr l0061h	;00bc	12	Jump to VIDEO_DISPLAY_LOOP
 554  00BE
 555  00BE              ; At this point the screen has been drawn. Timing is no longer critical.
 556  00BE              l00beh:
 557  00BE 36 BC        	ld (hl),0bch	;00be	Latch bch into the register
 558  00C0              			;	This disables A7 clamp and sets character
 559  00C0              			;	generator to an empty line 15 so that nothing
 560  00C0              			;	gets drawn outside the screen
 561  00C0
 562  00C0              ; The following code increments the real-time clock in BASIC string $Y.
 563  00C0
 564  00C0              ; The clock only works correctly if Y$ contains one of the following
 565  00C0              ; ASCII combinations:
 566  00C0
 567  00C0              ; Y$ = "HH:MM:SS:PP\0", Y$ = "HH:MM:SS\0PP", Y$ = "HH:MM\0SS:PP"
 568  00C0
 569  00C0              ; Where HH are hours, MM minutes, SS seconds and PP 1/100th of a second
 570  00C0
 571  00C0 3A 82 2A     	ld a,(02a82h)	;00c0	Load memory location 2a82h into A
 572  00C3              			;	This is third character in Y$
 573  00C3 FE 3A        	cp 03ah		;00c3	Compare A with 3ah (ASCII ':')
 574  00C5 20 34        	jr nz,l00fbh	;00c5	Jump to VIDEO_END if not equal
 575  00C7
 576  00C7 3A AF 2B     	ld a,(02bafh)	;00c7 	Load CLOCK_ON into A
 577  00CA 07           	rlca		;00ca	Move MSB into C flag
 578  00CB 30 2E        	jr nc,l00fbh	;00cb	Jump to VIDEO_END if MSB is zero
 579  00CD
 580  00CD              ; Clock is enabled and seems to contain a valid ASCII string.
 581  00CD              ; HL contains pointer to the current character
 582  00CD              ; B contains number of characters left
 583  00CD
 584  00CD 21 8A 2A     	ld hl,02a8ah	;00cd	Load 2a8ah into HL
 585  00D0              			;	This is the last (11th) character in string Y$
 586  00D0 11 30 39     	ld de,03930h	;00d0	Load 3930h into DE
 587  00D3              			;	D = '9' E = '0'
 588  00D3 06 08        	ld b,008h	;00d3	Load 08h into B
 589  00D5 7A           	ld a,d		;00d5	Load 39h into A
 590  00D6              			;	A = '9'
 591  00D6
 592  00D6 34           	inc (hl)	;00d6	Increment last character (1/100th s) two times
 593  00D7 34           	inc (hl)	;00d7 	(this routine is called 50 times per second)
 594  00D8 BE           	cp (hl)		;00d8	Compare last character with '9'
 595  00D9
 596  00D9 18 04        	jr l00dfh	;00d9	Jump forward
 597  00DB
 598  00DB              ; This code propagates change in the 1/100th field to seconds, minutes and
 599  00DB              ; hours
 600  00DB
 601  00DB              l00dbh:
 602  00DB 34           	inc (hl)	;00db	Increment character
 603  00DC BE           	cp (hl)		;00dc	Compare character with A
 604  00DD 3E 35        	ld a,035h	;00dd	Load '5' into A
 605  00DF
 606  00DF              l00dfh:
 607  00DF 30 0A        	jr nc,l00ebh	;00df	If character less or equal to A ('9' or '5')
 608  00E1              			;	then jump forward.
 609  00E1
 610  00E1 73           	ld (hl),e	;00e1	Replace current character with '0'
 611  00E2 2B           	dec hl		;00e2	Move pointer to the next character.
 612  00E3 CB 40        	bit 0,b		;00e3	If B even...
 613  00E5 28 02        	jr z,l00e9h	;00e5	...jump forward
 614  00E7
 615  00E7 2B           	dec hl		;00e7	Else move pointer again (to skip ':' or '\0')
 616  00E8 7A           	ld a,d		;00e8	Load '9' into A
 617  00E9
 618  00E9              l00e9h:
 619  00E9 10 F0        	djnz l00dbh	;00e9	Loop until B equals 0
 620  00EB              l00ebh:
 621  00EB
 622  00EB 05           	dec b		;00eb	Decrement B
 623  00EC 10 0D        	djnz l00fbh	;00ec	Jump to VIDEO_END if B not equal to 0...
 624  00EE              			;	...else hours field was updated and must
 625  00EE              			;	   be checkd for overflow
 626  00EE
 627  00EE 7E           	ld a,(hl)	;00ee	Load the character into A
 628  00EF FE 34        	cp 034h		;00ef	Compare with '4'
 629  00F1 38 08        	jr c,l00fbh	;00f1	If character less or equal to '4' jump to
 630  00F3              			;	VIDEO_END
 631  00F3
 632  00F3 2B           	dec hl		;00f3	Move pointer to the next character
 633  00F4 CB 4E        	bit 1,(hl)	;00f4	Test bit 1 (character equal to '2' or more)
 634  00F6 28 03        	jr z,l00fbh	;00f6	If bit 1 not set jump to VIDEO_END...
 635  00F8
 636  00F8 73           	ld (hl),e	;00f8	Else load '0' in the last two characters
 637  00F9 23           	inc hl		;00f9
 638  00FA 73           	ld (hl),e	;00fa
 639  00FB
 640  00FB              ;; VIDEO_END
 641  00FB              l00fbh:
 642  00FB FD E9        	jp (iy)		;00fb	Jump to video hook (jumps to l00fdh by
 643  00FD              			;	default)
 644  00FD
 645  00FD              l00fdh:
 646  00FD E1           	pop hl		;00fd	Restore all registers from stack
 647  00FE D1           	pop de		;00fe
 648  00FF C1           	pop bc		;00ff
 649  0100 F1           	pop af		;0100
 650  0101
 651  0101 FB           	ei		;0101	Enable interrupts
 652  0102 ED 4D        	reti		;0102	Return from interrupt
 653  0104
 654  0104              ; 'EAT SPACE'
 655  0104              ; ===========
 656  0104              ; Increments DE until it points to a non-ASCII space (20h) character
 657  0104
 658  0104              ; Parameters:
 659  0104              ;	DE: starting position
 660  0104              ; Returns:
 661  0104              ;	A:  first non-space character
 662  0104              ;	DE: address of the character in A
 663  0104              ; Destroys:
 664  0104              ;	flags
 665  0104
 666  0104              l0104h:
 667  0104 13           	inc de		;0104	Increment DE
 668  0105
 669  0105              ;; EAT_SPACE
 670  0105              l0105h:
 671  0105 1A           	ld a,(de)	;0105	Load memory byte pointed by DE into A
 672  0106 FE 20        	cp 020h		;0106	Compare A with ASCII ' '
 673  0108 28 FA        	jr z,l0104h	;0108	Loop if equal...
 674  010A C9           	ret		;010a	...else Return
 675  010B
 676  010B              ; 'ARR$'
 677  010B              ; ======
 678  010B              ;; ARR$ BASIC command
 679  010B
 680  010B              ;; ARR$
 681  010B              l010bh:
 682  010B 23           	inc hl			;010b	23 	#
 683  010C AF           	xor a			;010c	af
 684  010D CD F3 0D     	call l0df3h		;010d	cd f3 0d
 685  0110 22 99 2A     	ld (02a99h),hl		;0110	22 99 2a 	"   *
 686  0113 F7           	rst 30h			;0113	f7
 687  0114              l0114h:
 688  0114 CF           	rst 8			;0114	cf
 689  0115 23           	inc hl			;0115	23 	#
 690  0116 AF           	xor a			;0116	af
 691  0117 CD F3 0D     	call l0df3h		;0117	cd f3 0d
 692  011A D5           	push de			;011a	d5
 693  011B ED 5B 99 2A  	ld de,(02a99h)		;011b	ed 5b 99 2a 	  [   *
 694  011F 13           	inc de			;011f	13
 695  0120 D7           	rst 10h			;0120	d7
 696  0121 30 31        	jr nc,l0154h		;0121	30 31 	0 1
 697  0123 18 21        	jr l0146h		;0123	18 21 	  !
 698  0125
 699  0125              ; 'LOCATE BASIC NUMERIC VARIABLE'
 700  0125              ; ===============================
 701  0125              ; Locates a BASIC variable containing 4-byte floating point number and stores
 702  0125              ; its address in HL.
 703  0125
 704  0125              ; Recognizes ordinary variables from A - Z and A(I) array.
 705  0125
 706  0125              ; Returns:
 707  0125              ;	HL: Location of the variable
 708  0125
 709  0125              ;; LOCATE_VARIABLE
 710  0125              l0125h:
 711  0125 CD 05 01     	call l0105h	;0125	Fetch the next character (call EAT_SPACE)
 712  0128
 713  0128              ; Return with Cf set if character not between 'A' and 'Z'
 714  0128
 715  0128 D6 41        	sub 041h	;0128	Subtract ASCII value 'A'
 716  012A D8           	ret c		;012a	Return if less
 717  012B
 718  012B FE 1A        	cp 01ah		;012b 	Compare character with ASCII value 'Z' + 1
 719  012D 3F           	ccf		;012d
 720  012E D8           	ret c		;012e	Return if greater or equal
 721  012F
 722  012F 13           	inc de		;012f	Move to the next character
 723  0130 A7           	and a		;0130
 724  0131 20 2B        	jr nz,l015eh	;0131	Jump to LOCATE_VARIABLE_BZ if character
 725  0133              			;	is not A
 726  0133
 727  0133 DF           	rst 18h		;0133	Call READ_PAR
 728  0134 28           	db '('		;0134
 729  0135 27           	db l015dh-$-1	;0135	Jump to LOCATE_VARIABLE_A if character A is
 730  0136              			;	not followed by '('
 731  0136
 732  0136              ; A(I) array
 733  0136
 734  0136 CF           	rst 8		;0136 	HL = index (call EVAL_INT_EXP)
 735  0137 23           	inc hl		;0137	Increment index
 736  0138
 737  0138 29           	add hl,hl	;0138	HL = index * 4
 738  0139 29           	add hl,hl	;0139
 739  013A
 740  013A D5           	push de		;013a	Save DE on stack
 741  013B 38 17        	jr c,l0154h	;013b	Jump to SORRY_RST on carry (index too large)
 742  013D
 743  013D ED 5B 99 2A  	ld de,(02a99h)	;013d	HL = index * 4 + ARRAY_LEN
 744  0141 19           	add hl,de	;0141
 745  0142
 746  0142 D1           	pop de		;0142	Fetch DE from stack
 747  0143 D5           	push de		;0143
 748  0144
 749  0144 38 0D        	jr c,l0153h	;0144	Jump to SORRY_RST_PUSH_DE on carry
 750  0146              			;	(index too large)
 751  0146              l0146h:
 752  0146 D1           	pop de		;0146	Restore DE
 753  0147
 754  0147 DF           	rst 18h		;0147	Call READ_PAR
 755  0148 29           	db ')'		;0148
 756  0149 09           	db l0153h-$-1	;0149	Jump to SORRY_RST_PUSH_DE if no closing ')'
 757  014A              			;	found.
 758  014A
 759  014A D5           	push de		;014a	Save DE
 760  014B
 761  014B EB           	ex de,hl	;014b	DE = index * 4 + ARRAY_LEN
 762  014C CD 83 01     	call l0183h	;014c	Call FREE_MEM
 763  014F
 764  014F D7           	rst 10h		;014f	Call CMP_HL_DE
 765  0150
 766  0150 30 36        	jr nc,l0188h	;0150	Jump to SUB_RAMTOP_HL if enough memory and
 767  0152              			;	return
 768  0152
 769  0152 3E           	db 03eh		;0152	Dummy ld a,nn (ignore push de command)
 770  0153
 771  0153              ; '"SORRY" ERROR RESTART'
 772  0153              ; =======================
 773  0153              ; This restart is called when there is not enough memory available to
 774  0153              ; complete a function or command.
 775  0153
 776  0153              ;; SORRY_RST_PUSH_DE
 777  0153              l0153h:
 778  0153 D5           	push de		;0153	Push current parser address to stack.
 779  0154              ;; SORRY_RST
 780  0154              l0154h:
 781  0154 CD 99 07     	call l0799h		;0154	Call BASIC_ERROR
 782  0157 53 4F 52 52  	dm "SORRY", 00dh	;0157
 782  015B 59 0D
 783  015D
 784  015D              ; Ordinary variable
 785  015D
 786  015D              ;; LOCATE_VARIABLE_A
 787  015D              l015dh:
 788  015D AF           	xor a		;015d	Clear A
 789  015E              ;; LOCATE_VARIABLE_BZ
 790  015E              l015eh:
 791  015E 26 2A        	ld h,02ah	;015e	HL = 2a00h + A * 4
 792  0160 17           	rla		;0160
 793  0161 17           	rla		;0161
 794  0162 6F           	ld l,a		;0162
 795  0163
 796  0163 AF           	xor a		;0163	Clear A and Cf
 797  0164
 798  0164 C9           	ret		;0164	Return
 799  0165
 800  0165              ; 'CONVERT ASCII HEX CHAR TO AN INTEGER'
 801  0165              ; ======================================
 802  0165              ; This function converts a single ASCII character to its hexadecimal numerical
 803  0165              ; value (for example 'B' returns 11) and increments DE.
 804  0165
 805  0165              ; Parameters:
 806  0165              ;	DE: Pointer to the character to be converted
 807  0165              ; Returns:
 808  0165              ;	A: Numerical value of character in (DE) or the character in (DE) on
 809  0165              ;	   error (character not between ASCII '0' and '9').
 810  0165              ;	DE: Incremented by 1 or unmodified on error.
 811  0165              ;	C flag: Set on error, reset otherwise
 812  0165              ; Destroys:
 813  0165              ;	Flags
 814  0165
 815  0165              ;; HEXCHAR_TO_INT
 816  0165              l0165h:
 817  0165 CD 72 01     	call l0172h	;0165	First try to convert an ASCII integer
 818  0168 D0           	ret nc		;0168	return if call to CHAR_TO_INT succeeded
 819  0169
 820  0169 FE 41        	cp 041h		;0169	Return with Cf set if character less than 'A'
 821  016B D8           	ret c		;016b
 822  016C
 823  016C C6 09        	add a,009h	;016c	Add 09h to ASCII code (lower 4 bits are now
 824  016E              			;	equal to the hex value)
 825  016E
 826  016E FE 50        	cp 050h		;016e	Compare with 'F' + 09h + 1
 827  0170
 828  0170 18 06        	jr l0178h	;0170	Jump forward (check for error, clear upper
 829  0172              			;	for bits and return)
 830  0172
 831  0172              ; 'CONVERT ASCII CHAR TO AN INTEGER'
 832  0172              ; ==================================
 833  0172              ; This function converts a single ASCII character to its decimal numerical
 834  0172              ; value and increments DE.
 835  0172
 836  0172              ; Parameters:
 837  0172              ;	DE: Pointer to the character to be converted
 838  0172              ; Returns:
 839  0172              ;	A: Numerical value of character in (DE) or the character in (DE) on
 840  0172              ;	   error (character not between ASCII '0' and '9').
 841  0172              ;	DE: Incremented by 1 or unmodified on error.
 842  0172              ;	C flag: Set on error, reset otherwise
 843  0172              ; Destroys:
 844  0172              ;	Flags
 845  0172
 846  0172              ;; CHAR_TO_INT
 847  0172              l0172h:
 848  0172 1A           	ld a,(de)	;0172	Load (DE) into A
 849  0173 FE 30        	cp 030h		;0173	Compare with 30h (ASCII '0')...
 850  0175 D8           	ret c		;0175	...and return if smaller.
 851  0176
 852  0176 FE 3A        	cp 03ah		;0176	Compare with 3ah (ASCII '9' + 1)...
 853  0178              l0178h:
 854  0178 3F           	ccf		;0178	   (complement carry flag)
 855  0179 D8           	ret c		;0179	...and return if larger or equal.
 856  017A
 857  017A 13           	inc de		;017a	Increment DE
 858  017B              l017bh:
 859  017B E6 0F        	and 00fh	;017b	A = A & 0fh (clear upper 4 bits)
 860  017D              			;	also resets carry flag
 861  017D
 862  017D C9           	ret		;017d	Return
 863  017E
 864  017E              l017eh:
 865  017E 77           	ld (hl),a			;017e	77 	w
 866  017F              l017fh:
 867  017F 23           	inc hl			;017f	23 	#
 868  0180 7D           	ld a,l			;0180	7d 	}
 869  0181 18 F8        	jr l017bh		;0181	18 f8
 870  0183
 871  0183              ; 'FREE MEMORY REMAINING'
 872  0183              ; =======================
 873  0183              ; Calculate bytes available from end of BASIC program to top of RAM
 874  0183
 875  0183              ; Returns:
 876  0183              ;	HL: Free bytes available.
 877  0183
 878  0183              ;; FREE_MEM
 879  0183              l0183h:
 880  0183 D5           	push de		;0183	Save DE to stack
 881  0184
 882  0184 ED 5B 38 2C  	ld de,(02c38h)	;0184	Load BASIC_END into DE
 883  0188
 884  0188              ; 'SUBTRACT HL FROM RAM_TOP'
 885  0188              ; ==========================
 886  0188
 887  0188              ; Returns:
 888  0188              ;	HL: HL = RAM_TOP - HL
 889  0188
 890  0188              ;; SUB_RAMTOP_HL
 891  0188              l0188h:
 892  0188 2A 6A 2A     	ld hl,(02a6ah)	;0188	Load RAM_TOP into DE
 893  018B
 894  018B 7D           	ld a,l		;018b	HL = HL & 0fff0h
 895  018C E6 F0        	and 0f0h	;018c	(resets Cf)
 896  018E 6F           	ld l,a		;018e
 897  018F
 898  018F ED 52        	sbc hl,de	;018f	HL = HL - DE - 0
 899  0191
 900  0191 D1           	pop de		;0191	Restore DE
 901  0192 AF           	xor a		;0192	Clear A (resets carry)
 902  0193
 903  0193 C9           	ret		;0193	Return
 904  0194
 905  0194              ; 'READ PARAMETER (cont.)'
 906  0194              ; ========================
 907  0194
 908  0194              ;; READ_PAR_2
 909  0194              l0194h:
 910  0194 23           	inc hl		;0194	Increment HL
 911  0195 28 07        	jr z,l019eh	;0195	Jump forward if character in DE matches
 912  0197
 913  0197 C5           	push bc		;0197	Save BC on stack
 914  0198 4E           	ld c,(hl)	;0198	Load (HL) into BC
 915  0199 06 00        	ld b,000h	;0199
 916  019B 09           	add hl,bc	;019b	Add BC to HL
 917  019C C1           	pop bc		;019c	Restore BC from stack
 918  019D
 919  019D 1B           	dec de		;019d	Decrement DE
 920  019E
 921  019E              l019eh:
 922  019E 13           	inc de		;019e	Increment DE
 923  019F 23           	inc hl		;019f	Increment HL
 924  01A0 E3           	ex (sp),hl	;01a0	Store HL back to the top of the stack
 925  01A1 C9           	ret		;01a1	Return
 926  01A2
 927  01A2              ; 'CONVERT STRING TO FLOATING POINT NUMBER'
 928  01A2              ; =========================================
 929  01A2              ; Converts a string at DE to a floating point number and pushes it to the
 930  01A2              ; arithmetic stack.
 931  01A2
 932  01A2              ; Returns:
 933  01A2              ;	Zf: Set if no errors occured
 934  01A2
 935  01A2              ;; STRING_TO_FP
 936  01A2              l01a2h:
 937  01A2 CD 48 02     	call l0248h	;01a2	Clear HL' C' (call CLEAR_CX_HLX_B6)
 938  01A5
 939  01A5 06 00        	ld b,000h	;01a5	Clear B and C
 940  01A7 48           	ld c,b		;01a7
 941  01A8
 942  01A8 CD 05 01     	call l0105h	;01a8	Skip any leading whitespace (call EAT_SPACE)
 943  01AB
 944  01AB              l01abh:
 945  01AB CD B0 01     	call l01b0h	;01ab	Call STRING_TO_FP_FETCH_DECIMAL
 946  01AE 18 FB        	jr l01abh	;01ae	Loop
 947  01B0
 948  01B0              ;		L'	H'	C'	L	H
 949  01B0              ; ----------------------------------------------------------
 950  01B0              ;		24 bit mantissa		Exp	Sign
 951  01B0
 952  01B0              ; B register (holds status of the conversion)
 953  01B0
 954  01B0              ; bit	7	6	5	4	3	2	1	0
 955  01B0              ; ----------------------------------------------------------------------
 956  01B0              ; 	Mantissa overflow
 957  01B0
 958  01B0              ;		Mantissa started with a number
 959  01B0
 960  01B0              ;			Exponent started with a number
 961  01B0
 962  01B0              ;							Negative exponent
 963  01B0
 964  01B0              ;								Decimal part
 965  01B0
 966  01B0              ; C register holds (negative) number of decimals after the decimal point.
 967  01B0
 968  01B0
 969  01B0              ; Stack: Top
 970  01B0              ;	 -> STRING_TO_FP
 971  01B0
 972  01B0              ;; STRING_TO_FP_FETCH_DECIMAL
 973  01B0              l01b0h:
 974  01B0 CD 72 01     	call l0172h	;01b0	Call CHAR_TO_INT
 975  01B3 38 20        	jr c,l01d5h	;01b3	Jump on conversion error
 976  01B5
 977  01B5 CB F0        	set 6,b		;01b5	Set bit 6 of B
 978  01B7
 979  01B7 CB 78        	bit 7,b		;01b7
 980  01B9 20 15        	jr nz,l01d0h	;01b9	Jump forward on mantissa overflow.
 981  01BB
 982  01BB CD C3 01     	call l01c3h	;01bb	Call STRING_TO_FP_ADD_DECIMAL
 983  01BE
 984  01BE CB 40        	bit 0,b		;01be
 985  01C0 C8           	ret z		;01c0	Decrement C if after decimal point.
 986  01C1
 987  01C1 0D           	dec c		;01c1
 988  01C2 C9           	ret		;01c2	Return
 989  01C3
 990  01C3
 991  01C3              ; Stack: Top
 992  01C3              ;	 -> STRING_TO_FP
 993  01C3              ;        -> STRING_TO_FP_FETCH_DECIMAL
 994  01C3
 995  01C3              ;; STRING_TO_FP_ADD_DECIMAL
 996  01C3              l01c3h:
 997  01C3 CD 4F 02     	call l024fh	;01c3	Call FP_MUL_10_ADD_A
 998  01C6
 999  01C6 C8           	ret z		;01c6	Return if no overflow in mantissa
1000  01C7
1001  01C7              ; Restore original mantissa if there was an overflow
1002  01C7
1003  01C7 D9           	exx		;01c7
1004  01C8 62           	ld h,d		;01c8	Load DE' into HL'
1005  01C9 6B           	ld l,e		;01c9
1006  01CA 08           	ex af,af'	;01ca
1007  01CB 4F           	ld c,a		;01cb	Load A' into C'
1008  01CC D9           	exx		;01cc
1009  01CD
1010  01CD CB F8        	set 7,b		;01cd	Set bit 7 of B
1011  01CF
1012  01CF F1           	pop af		;01cf	Remove top return address from stack.
1013  01D0              			;	(will return to STRING_TO_FP)
1014  01D0
1015  01D0              l01d0h:
1016  01D0 CB 40        	bit 0,b		;01d0
1017  01D2 C0           	ret nz		;01d2	Increment C if before decimal point.
1018  01D3
1019  01D3 0C           	inc c		;01d3
1020  01D4 C9           	ret		;01d4	Return
1021  01D5
1022  01D5              ; Stack: Top
1023  01D5              ;	 -> STRING_TO_FP
1024  01D5
1025  01D5              l01d5h:
1026  01D5 DF           	rst 18h		;01d5	Call READ_PAR
1027  01D6 2E           	db '.'		;01d6
1028  01D7 05           	db l01ddh-$-1	;01d7
1029  01D8
1030  01D8              ; Decimal point found
1031  01D8
1032  01D8 CB 40        	bit 0,b		;01d8
1033  01DA CB C0        	set 0,b		;01da
1034  01DC C8           	ret z		;01dc	Return if bit 0 not set,
1035  01DD              			;	else set bit 0 of B.
1036  01DD
1037  01DD              			;	Two decimal points found
1038  01DD              l01ddh:
1039  01DD F1           	pop af		;01dd	Remove top return address from stack.
1040  01DE
1041  01DE CB 70        	bit 6,b		;01de
1042  01E0 C8           	ret z		;01e0	Return from STRING_TO_FP if first character
1043  01E1              			;	of mantissa was not a number.
1044  01E1
1045  01E1 21 18 00     	ld hl,l0018h	;01e1	Exponent = 24, sign = positive
1046  01E4 C5           	push bc		;01e4	Save BC on stack
1047  01E5 D5           	push de		;01e5	Save DE on stack
1048  01E6
1049  01E6 D9           	exx		;01e6
1050  01E7 CD 14 09     	call l0914h	;01e7	Call CORRECT_EXP_ADD_IX_10
1051  01EA
1052  01EA D1           	pop de		;01ea	Restore DE from stack
1053  01EB
1054  01EB 01 F3 01     	ld bc,l01f3h	;01eb	Push STRING_TO_FP_PARSE_EXP address on stack.
1055  01EE C5           	push bc		;01ee
1056  01EF
1057  01EF D5           	push de		;01ef	Save DE on stack
1058  01F0 C3 6D 0B     	jp l0b6dh	;01f0	Jump to STORE_ARITHM_RET and return
1059  01F3              			;	to STRING_TO_FP_PARSE_EXP
1060  01F3
1061  01F3              ; At this point mantissa is on the top of arithmetic stack and DE points
1062  01F3              ; to the beginning of the exponent.
1063  01F3
1064  01F3              ; Stack: Top
1065  01F3              ;	 -> STRING_TO_FP
1066  01F3
1067  01F3              ;; STRING_TO_FP_PARSE_EXP
1068  01F3              l01f3h:
1069  01F3 C1           	pop bc		;01f3	Restore BC from stack
1070  01F4 D5           	push de		;01f4	Save DE on stack
1071  01F5
1072  01F5 DF           	rst 18h		;01f5	Call READ_PAR
1073  01F6 45           	db 'E' 		;01f6
1074  01F7 1B           	db l0213h-$-1	;01f7	No exponent
1075  01F8
1076  01F8 DF           	rst 18h		;01f8	Call READ_PAR
1077  01F9 2B           	db '+'		;01f9
1078  01FA 02           	db l01fdh-$-1	;01fa	Ignore leading + sign
1079  01FB
1080  01FB 18 05        	jr l0202h	;01fb
1081  01FD
1082  01FD              l01fdh:
1083  01FD DF           	rst 18h		;01fd	Call READ_PAR
1084  01FE 2D           	db '-'		;01fe
1085  01FF 02           	db l0202h-$-1	;01ff
1086  0200
1087  0200 CB C8        	set 1,b		;0200	Mark negative exponent
1088  0202
1089  0202              ;; STRING_TO_FP_GET_EXP
1090  0202              l0202h:
1091  0202 CD 4A 02     	call l024ah	;0202	Call CLEAR_CX_HLX
1092  0205
1093  0205              l0205h:
1094  0205 CD 72 01     	call l0172h	;0205	Call CHAR_TO_INT
1095  0208 38 0D        	jr c,l0217h	;0208	Break from loop on conversion error
1096  020A
1097  020A CB E8        	set 5,b		;020a	Mark exponent started with number
1098  020C
1099  020C CD 4F 02     	call l024fh	;020c	Add decimal to the exponent
1100  020F              			;	(call FP_MUL_10_ADD_A)
1101  020F
1102  020F 20 14        	jr nz,l0225h	;020f	Jump to HOW_RST_PUSH_DE on exponent overflow
1103  0211
1104  0211 18 F2        	jr l0205h	;0211	Loop
1105  0213
1106  0213              l0213h:
1107  0213 D1           	pop de		;0213	Restore DE
1108  0214 AF           	xor a		;0214	Clear A
1109  0215 18 17        	jr l022eh	;0215
1110  0217
1111  0217              l0217h:
1112  0217 CB 68        	bit 5,b		;0217
1113  0219 28 F8        	jr z,l0213h	;0219	Jump to FIXME if exponent did not start with
1114  021B              			;	a number
1115  021B
1116  021B F1           	pop af		;021b	FIXME
1117  021C
1118  021C D9           	exx		;021c
1119  021D 79           	ld a,c		;021d
1120  021E B4           	or h		;021e	Test C' and H'
1121  021F
1122  021F 7D           	ld a,l		;021f	A = L'
1123  0220
1124  0220 D9           	exx		;0220
1125  0221
1126  0221 20 02        	jr nz,l0225h	;0221	If C' or H' not equal to zero, call HOW_RST
1127  0223              			;	(exponent overflowed)
1128  0223 CB 7F        	bit 7,a		;0223
1129  0225              l0225h:
1130  0225 C2 5A 06     	jp nz,l065ah	;0225	If mantissa overflowed, call HOW_RST
1131  0228
1132  0228 CB 48        	bit 1,b		;0228	If exponent negative, negate A
1133  022A 28 02        	jr z,l022eh	;022a
1134  022C ED 44        	neg		;022c
1135  022E              l022eh:
1136  022E
1137  022E 81           	add a,c		;022e	Add exponent and number of decimal points
1138  022F
1139  022F              ; Mantissa is still on the top of the arithmetic stack. Exponent is in A.
1140  022F
1141  022F              ; Multiply mantissa with 10^A.
1142  022F
1143  022F              ;; STRING_TO_FP_EXP_LOOP
1144  022F              l022fh:
1145  022F A7           	and a		;022f
1146  0230 28 13        	jr z,l0245h	;0230	If A zero, jump to STRING_TO_FP_END
1147  0232
1148  0232 CB 7F        	bit 7,a		;0232
1149  0234 28 07        	jr z,l023dh	;0234	Multiply by 10 if exponent positive,
1150  0236              			;	else divide by 10
1151  0236
1152  0236 3C           	inc a		;0236	Increment A
1153  0237 F5           	push af		;0237	Save A on stack
1154  0238 CD F4 0A     	call l0af4h	;0238	Call FP_DIV_10
1155  023B 18 05        	jr l0242h	;023b
1156  023D
1157  023D              l023dh:
1158  023D 3D           	dec a		;023d	Decrement A
1159  023E F5           	push af		;023e	Save A on stack
1160  023F CD E3 0A     	call l0ae3h	;023f	Call FP_MUL_10
1161  0242
1162  0242              l0242h:
1163  0242 F1           	pop af		;0242	Restore A from stack
1164  0243 18 EA        	jr l022fh	;0243	Jump to STRING_TO_FP_EXP_LOOP
1165  0245
1166  0245              ;; STRING_TO_FP_END
1167  0245              l0245h:
1168  0245 CB 70        	bit 6,b		;0245	Test bit 6 of B (valid mantissa)
1169  0247 C9           	ret		;0247	Return
1170  0248
1171  0248
1172  0248              ; 'CLEAR C' HL''
1173  0248              ; ==============
1174  0248              ; Loads 00 0000h into the mantissa in C' HL' and clears bit 6 of B
1175  0248
1176  0248              ;; CLEAR_CX_HLX_B6
1177  0248              l0248h:
1178  0248 CB B0        	res 6,b		;0248	Clear bit 6 of B
1179  024A
1180  024A              ;; CLEAR_CX_HLX
1181  024A              l024ah:
1182  024A D9           	exx		;024a	Exchange BC,DE,HL with BC',DE',HL'
1183  024B EF           	rst 28h		;024b	Call CLEAR_HL
1184  024C 4D           	ld c,l		;024c	Load 00h into C
1185  024D D9           	exx		;024d	Exchange BC,DE,HL with BC',DE',HL'
1186  024E C9           	ret		;024e	Return
1187  024F
1188  024F              ; 'ADD A DECIMAL NUMBER TO MANTISSA'
1189  024F              ; ==================================
1190  024F              ; Multiplies floating point number's mantissa in HL' C' by 10 and adds integer
1191  024F              ; in A to it.
1192  024F
1193  024F              ; Parameters:
1194  024F              ;	HL' C': Input mantissa (24 bit)
1195  024F              ;	A: Integer to add
1196  024F              ; Returns:
1197  024F              ;	HL' BC': Output mantissa (32 bit)
1198  024F              ;	DE' A': Unmodified input mantissa (24 bit)
1199  024F              ;	Zf: Set if B' is zero
1200  024F
1201  024F              ;; FP_MUL_10_ADD_A
1202  024F              l024fh:
1203  024F 08           	ex af,af'	;024f
1204  0250 D9           	exx		;0250
1205  0251
1206  0251 54           	ld d,h		;0251	DE' A' = HL' C'
1207  0252 5D           	ld e,l		;0252
1208  0253 79           	ld a,c		;0253
1209  0254
1210  0254 06 00        	ld b,000h	;0254	Clear B'
1211  0256
1212  0256 F5           	push af		;0256	Push AF' on stack
1213  0257
1214  0257              ;		L'	H'	C'	B'	L	H
1215  0257              ; ----------------------------------------------------------
1216  0257              ;		32 bit mantissa		(MSB)	Exp	Sign
1217  0257
1218  0257 29           	add hl,hl	;0257	HL' BC' = HL' BC' * 2
1219  0258 CB 11        	rl c		;0258
1220  025A CB 10        	rl b		;025a
1221  025C
1222  025C 29           	add hl,hl	;025c	HL' C' = HL' C' * 2
1223  025D CB 11        	rl c		;025d
1224  025F CB 10        	rl b		;025f
1225  0261
1226  0261 19           	add hl,de	;0261	HL' BC' = HL' BC' + DE' A'
1227  0262 89           	adc a,c		;0262
1228  0263 4F           	ld c,a		;0263
1229  0264
1230  0264 3E 00        	ld a,000h	;0264
1231  0266 88           	adc a,b		;0266
1232  0267 47           	ld b,a		;0267
1233  0268
1234  0268              ; We now have HL' BC' = HL' BC' * 5
1235  0268
1236  0268 F1           	pop af		;0268	Pop AF' from stack
1237  0269
1238  0269 D5           	push de		;0269	Push DE' to stack
1239  026A
1240  026A 16 00        	ld d,000h	;026a	Clear D'
1241  026C
1242  026C 29           	add hl,hl	;026c	HL' BC' = HL' BC' * 2
1243  026D CB 11        	rl c		;026d
1244  026F CB 10        	rl b		;026f
1245  0271
1246  0271              ; We now have HL' BC' = HL' BC' * 10
1247  0271
1248  0271 08           	ex af,af'	;0271	Exchange AF with AF'
1249  0272
1250  0272 5F           	ld e,a		;0272	Load A into E'
1251  0273
1252  0273 19           	add hl,de	;0273	HL' BC' = HL' BC' + E'
1253  0274
1254  0274 7A           	ld a,d		;0274
1255  0275 89           	adc a,c		;0275
1256  0276 4F           	ld c,a		;0276
1257  0277
1258  0277 7A           	ld a,d		;0277
1259  0278 88           	adc a,b		;0278
1260  0279 47           	ld b,a		;0279
1261  027A
1262  027A D1           	pop de		;027a	Pop DE' from stack
1263  027B
1264  027B D9           	exx		;027b
1265  027C C9           	ret		;027c	Return
1266  027D
1267  027D              ; 'EDIT'
1268  027D              ; ======
1269  027D              ; "EDIT" BASIC command.
1270  027D
1271  027D              ; Edit a line of BASIC with a simple line editor. Takes one integer argument
1272  027D              ; which is the line number to edit.
1273  027D
1274  027D              ; Delete key was pressed while in line editor mode. Remove one character
1275  027D              ; at '_' cursor position.
1276  027D
1277  027D              ;; EDIT_DELETE
1278  027D              l027dh:
1279  027D 5D           	ld e,l		;027d	DE' = HL'
1280  027E 54           	ld d,h		;027e
1281  027F
1282  027F              l027fh:
1283  027F 13           	inc de		;027f	(DE') = (DE' + 1)
1284  0280 1A           	ld a,(de)	;0280
1285  0281 1B           	dec de		;0281
1286  0282 12           	ld (de),a	;0282
1287  0283
1288  0283 13           	inc de		;0283	Increment DE'
1289  0284
1290  0284 FE 0D        	cp 00dh		;0284 	Loop until end of line is reached
1291  0286 20 F7        	jr nz,l027fh	;0286
1292  0288
1293  0288 18 25        	jr l02afh	;0288	Continue with EDIT_LOOP
1294  028A
1295  028A              ;; EDIT_LEFT
1296  028A              l028ah:
1297  028A 7D           	ld a,l		;028a	Check if cursor is at the beginning of buffer.
1298  028B FE B6        	cp 0b6h		;028b
1299  028D 28 20        	jr z,l02afh	;028d
1300  028F
1301  028F 2B           	dec hl		;028f	Move cursor one position left
1302  0290 18 1D        	jr l02afh	;0290	Continue with EDIT_LOOP
1303  0292
1304  0292              ;; EDIT_RIGHT
1305  0292              l0292h:
1306  0292 7E           	ld a,(hl)	;0292	Check if cursor is at the end of buffer.
1307  0293 FE 0D        	cp 00dh		;0293
1308  0295 28 18        	jr z,l02afh	;0295
1309  0297
1310  0297 18 51        	jr l02eah	;0297	Move cursor one position right
1311  0299              			;	and continue with EDIT_LOOP
1312  0299
1313  0299              ; Entry point to the function
1314  0299
1315  0299              ;; EDIT
1316  0299              l0299h:
1317  0299 CD D3 0C     	call l0cd3h	;0299	HL = line number to edit or 0 on error
1318  029C              			;	(call STRING_TO_INT)
1319  029C
1320  029C CD F2 07     	call l07f2h	;029c	DE = start of the BASIC line
1321  029F              			;	(call FIND_LINE)
1322  029F
1323  029F DA 5A 06     	jp c,l065ah	;029f	Jump to HOW_RST_PUSH_DE if exact line number
1324  02A2              			;	in argument was not found.
1325  02A2
1326  02A2 3E 0C        	ld a,00ch	;02a2	Clear screen with PUTCH_RST
1327  02A4 E7           	rst 20h		;02a4	(print ASCII FF)
1328  02A5
1329  02A5 21 B6 2B     	ld hl,02bb6h	;02a5	Load INPUT_BUFFER address into HL
1330  02A8
1331  02A8 22 68 2A     	ld (02a68h),hl	;02a8	Move cursor at the beggining of the buffer
1332  02AB              			;	(update CURSOR_POS)
1333  02AB
1334  02AB CD 31 09     	call l0931h	;02ab	Print the selected line into buffer
1335  02AE              			;	(call PRINT_BASIC_LINE)
1336  02AE
1337  02AE              			;	HL' = address of the last character
1338  02AE              			;             in buffer + 1
1339  02AE
1340  02AE D9           	exx		;02ae
1341  02AF
1342  02AF              ;; EDIT_LOOP
1343  02AF              l02afh:
1344  02AF 11 00 28     	ld de,02800h	;02af	Set CURSOR_POS to the top left corner of the
1345  02B2 ED 53 68 2A  	ld (02a68h),de	;02b2	screen.
1346  02B6
1347  02B6              ; Print the BASIC line in buffer on the screen with the '_' cursor inserted
1348  02B6              ; at HL'.
1349  02B6
1350  02B6 11 B6 2B     	ld de,02bb6h	;02b6	DE' = INPUT_BUFFER
1351  02B9
1352  02B9 4E           	ld c,(hl)	;02b9	Save character at HL' in C'
1353  02BA 36 00        	ld (hl),000h	;02ba	and overwrite it with ASCII NUL
1354  02BC
1355  02BC CD 37 09     	call l0937h	;02bc	Call PRINTSTR
1356  02BF
1357  02BF              			;	DE' = address of the first character after
1358  02BF              			;	      inserted ASCII NUL
1359  02BF
1360  02BF 3E 5F        	ld a,05fh	;02bf	Load cursor character (ASCII '_') into A
1361  02C1
1362  02C1 CD B6 07     	call l07b6h	;02c1	Decrement DE'
1363  02C4              			;	Restore character in C' to HL'
1364  02C4              			;	Call PUTCH_PRINTSTR
1365  02C4
1366  02C4              			;	DE' = address of the last character in the
1367  02C4              			;	      buffer.
1368  02C4
1369  02C4 CD F5 0C     	call l0cf5h	;02c4	Wait for a keypress (call KEY)
1370  02C7
1371  02C7 FE 0D        	cp 00dh		;02c7	"RETURN" pressed...
1372  02C9 28 71        	jr z,l033ch	;02c9	...call BASIC_CMDLINE_ENTRY and proceed as if
1373  02CB              			;	   the buffer was entered on the command line.
1374  02CB
1375  02CB B7           	or a		;02cb	"DELETE" pressed...
1376  02CC 28 AF        	jr z,l027dh	;02cc	...jump to EDIT_DELETE
1377  02CE
1378  02CE FE 1D        	cp 01dh		;02ce	"LEFT" pressed...
1379  02D0 28 B8        	jr z,l028ah	;02d0	...jump to EDIT_LEFT
1380  02D2
1381  02D2 FE 1E        	cp 01eh		;02d2	"RIGHT" pressed...
1382  02D4 28 BC        	jr z,l0292h	;02d4	...jump to EDIT_RIGHT
1383  02D6
1384  02D6 38 D7        	jr c,l02afh	;02d6	Ignore any other special keys (scancode < 1eh)
1385  02D8              			;	(loop to EDIT_LOOP)
1386  02D8
1387  02D8              ; Alfanumeric key was pressed...
1388  02D8
1389  02D8 47           	ld b,a		;02d8	Load ASCII code into B
1390  02D9
1391  02D9 E5           	push hl		;02d9	Save '_' cursor address on stack
1392  02DA
1393  02DA 21 34 2C     	ld hl,02c34h	;02da	Check there is space in the buffer for
1394  02DD              			;	another character.
1395  02DD D7           	rst 10h		;02dd	(call CMP_HL_DE)
1396  02DE
1397  02DE E1           	pop hl		;02de	Restore '_' cursor address.
1398  02DF
1399  02DF 38 CE        	jr c,l02afh	;02df	Ignore key press that would overflow the
1400  02E1              			;	buffer (loop to EDIT_LOOP)
1401  02E1
1402  02E1              ; Make space for the inserted character by moving all character in front
1403  02E1              ; one position to the right.
1404  02E1
1405  02E1              l02e1h:
1406  02E1 1B           	dec de		;02e1	(DE') = (DE' - 1)
1407  02E2 1A           	ld a,(de)	;02e2
1408  02E3 13           	inc de		;02e3
1409  02E4 12           	ld (de),a	;02e4
1410  02E5
1411  02E5 1B           	dec de		;02e5	Decrement DE'
1412  02E6 D7           	rst 10h		;02e6	Compare with '_' cursor position in HL'
1413  02E7
1414  02E7 20 F8        	jr nz,l02e1h	;02e7	Loop until cursor position is reached
1415  02E9
1416  02E9 70           	ld (hl),b	;02e9	Insert ASCII code into string
1417  02EA
1418  02EA              l02eah:
1419  02EA 23           	inc hl		;02ea	Move '_' cursor to the right.
1420  02EB 18 C2        	jr l02afh	;02eb	Loop to EDIT_LOOP
1421  02ED
1422  02ED              ; 'MOVE CURSOR INTO A NEW LINE'
1423  02ED              ; =============================
1424  02ED              ; This routine prints a new line if the cursor is not in the upper left corner
1425  02ED              ; of the screen.
1426  02ED
1427  02ED              ;; NEWLINE
1428  02ED              l02edh:
1429  02ED 3A 68 2A     	ld a,(02a68h)	;02ed	Set Zf if cursor in upper left corner of the
1430  02F0 E6 1F        	and 01fh	;02f0	screen.
1431  02F2
1432  02F2 3E 0D        	ld a,00dh	;02f2	Load ASCII CR into A
1433  02F4 32 B5 2B     	ld (02bb5h),a	;02f4	Load 0dh into FIXME
1434  02F7
1435  02F7 C8           	ret z		;02f7	Print ASCII CR if Zf not set.
1436  02F8 E7           	rst 20h		;02f8
1437  02F9 C9           	ret		;02f9
1438  02FA
1439  02FA              ; 'CHECK IF "BREAK" KEY IS PRESSED'
1440  02FA              ; =================================
1441  02FA              ; This function checks if "BREAK" key is pressed. If so it executes the BREAK
1442  02FA              ; routine.
1443  02FA
1444  02FA              l02fah:
1445  02FA 3A 33 20     	ld a,(02033h)	;02fa	Check for "DELETE" key press.
1446  02FD 0F           	rrca		;02fd
1447  02FE D8           	ret c		;02fe	Return if key is not pressed. Else check for
1448  02FF              			;	BREAK keypress again.
1449  02FF
1450  02FF              			;	FIXME: Phantom keypress recognition?
1451  02FF
1452  02FF              ;; CHECK_BREAK
1453  02FF              l02ffh:
1454  02FF 3A 31 20     	ld a,(02031h)	;02ff	Check for "BREAK" key press.
1455  0302 0F           	rrca		;0302
1456  0303 38 F5        	jr c,l02fah	;0303	If key is pressed (LSB of A is 0), continue
1457  0305              			;	to the BREAK function. Else jump.
1458  0305
1459  0305              ; 'BREAK BASIC INTERPRETER'
1460  0305              ; =========================
1461  0305              ; This function gets called whenever the "BREAK" key is pressed during the
1462  0305              ; execution of the BASIC interpreter.
1463  0305
1464  0305              ;; BREAK
1465  0305              l0305h:
1466  0305 CD ED 02     	call l02edh		;0305	cd ed 02
1467  0308 11 98 00     	ld de,l0098h		;0308	11 98 00
1468  030B CD 37 09     	call l0937h		;030b	cd 37 09 	  7
1469  030E ED 5B 9F 2A  	ld de,(02a9fh)		;030e	ed 5b 9f 2a 	  [   *
1470  0312 7A           	ld a,d			;0312	7a 	z
1471  0313 B3           	or e			;0313	b3
1472  0314 C4 ED 08     	call nz,l08edh		;0314	c4 ed 08
1473  0317
1474  0317              ; 'RESET BASIC (cont.)'
1475  0317              ; =====================
1476  0317
1477  0317              ;; RESET_BASIC_2
1478  0317              l0317h:
1479  0317 FB           	ei		;0317	Enable interrupts
1480  0318
1481  0318 CD ED 02     	call l02edh	;0318	Call NEWLINE
1482  031B
1483  031B 11 07 0F     	ld de,l0f07h	;031b	Print "READY" string
1484  031E CD 37 09     	call l0937h	;031e	(call PRINTSTR)
1485  0321
1486  0321              ;; BASIC_CMDLINE_LOOP
1487  0321              l0321h:
1488  0321
1489  0321              ; Reset BASIC interpreter variables
1490  0321
1491  0321 EF           	rst 28h		;0321	Call CLEAR_HL
1492  0322 11 31 30     	ld de,03031h	;0322
1493  0325 31 A7 2A     	ld sp,02aa7h	;0325
1494  0328
1495  0328 D5           	push de		;0328	Load 3031h into KEY_DIFF	(2aa5-2aa6)
1496  0329 E5           	push hl		;0329	Clear FIXME			(2aa3-2aa4)
1497  032A E5           	push hl		;032a	Clear FIXME 			(2aa1-2aa2)
1498  032B E5           	push hl		;032b	Clear BASIC_LINE                (2a9f-2aa0)
1499  032C
1500  032C 2A 36 2C     	ld hl,(02c36h)	;032c	Load BASIC_START+2 into HL
1501  032F 23           	inc hl		;032f
1502  0330 23           	inc hl		;0330
1503  0331
1504  0331 E5           	push hl		;0331	Load HL into 2a9dh (FIXME)
1505  0332
1506  0332 31 A8 2B     	ld sp,02ba8h	;0332	Restore CPU and arithmetic stack pointers.
1507  0335 DD 21 AC 2A  	ld ix,02aach	;0335
1508  0339
1509  0339 CD BB 07     	call l07bbh	;0339	Get command line (call GETSTR)
1510  033C
1511  033C              ; Process string in input buffer and either store a BASIC line to memory or
1512  033C              ; execute and immediate command.
1513  033C
1514  033C              ;; BASIC_CMDLINE_ENTRY
1515  033C              l033ch:
1516  033C D5           	push de		;033c	Push address of the end of the string to stack,
1517  033D
1518  033D 11 B6 2B     	ld de,02bb6h	;033d	Load INPUT_BUFFER address into DE
1519  0340
1520  0340 CD D3 0C     	call l0cd3h	;0340	Call STRING_TO_INT
1521  0343
1522  0343              			;	Stores line number in HL, or set Zf if
1523  0343              			;	no line number was entered.
1524  0343
1525  0343 C1           	pop bc		;0343	Restore end address into BC.
1526  0344
1527  0344 CA 8C 03     	jp z,l038ch	;0344	No line number, jump to IMMEDIATE
1528  0347
1529  0347              ; Store the entered BASIC line in memory
1530  0347
1531  0347              ; Example: 20 XXX entered on the command line
1532  0347
1533  0347 1B           	dec de		;0347	Store line number at (DE-2)
1534  0348 7C           	ld a,h		;0348	(two bytes before the start of the line
1535  0349 12           	ld (de),a	;0349   contents)
1536  034A 1B           	dec de		;034a
1537  034B 7D           	ld a,l		;034b
1538  034C 12           	ld (de),a	;034c
1539  034D
1540  034D C5           	push bc		;034d	Save line end address and line start address
1541  034E D5           	push de		;034e	on stack.
1542  034F
1543  034F 79           	ld a,c		;034f	A = C - E
1544  0350 93           	sub e		;0350
1545  0351
1546  0351 F5           	push af		;0351
1547  0352
1548  0352 CD F2 07     	call l07f2h	;0352	(call FIND_LINE)
1549  0355
1550  0355 D5           	push de		;0355	Store start address of the next line on stack
1551  0356 20 10        	jr nz,l0368h	;0356
1552  0358
1553  0358              ; Entered line number doesn't exist yet
1554  0358
1555  0358 D5           	push de		;0358
1556  0359
1557  0359 CD 11 08     	call l0811h	;0359	Move DE to the beginning of the line
1558  035C              			;	(call FIND_LINE_NEXT)
1559  035C
1560  035C C1           	pop bc		;035c	BC = start address of the next line
1561  035D
1562  035D 2A 38 2C     	ld hl,(02c38h)	;035d	2a 38 2c 	* 8 ,
1563  0360
1564  0360 CD 44 09     	call l0944h	;0360	Call MOVE_MEM
1565  0363
1566  0363 60           	ld h,b		;0363	60 	`
1567  0364 69           	ld l,c		;0364	69 	i
1568  0365 22 38 2C     	ld (02c38h),hl	;0365	22 38 2c 	" 8 ,
1569  0368              l0368h:
1570  0368 C1           	pop bc		;0368	c1
1571  0369 2A 38 2C     	ld hl,(02c38h)	;0369	2a 38 2c 	* 8 ,
1572  036C F1           	pop af		;036c	f1
1573  036D E5           	push hl		;036d	e5
1574  036E FE 03        	cp 003h		;036e	fe 03
1575  0370 28 AF        	jr z,l0321h	;0370	28 af 	(
1576  0372 5F           	ld e,a		;0372	5f 	_
1577  0373 16 00        	ld d,000h	;0373	16 00
1578  0375 19           	add hl,de	;0375	19
1579  0376 ED 5B 6A 2A  	ld de,(02a6ah)	;0376	ed 5b 6a 2a 	  [ j *
1580  037A D7           	rst 10h		;037a	d7
1581  037B D2 53 01     	jp nc,00153h	;037b	d2 53 01 	  S
1582  037E 22 38 2C     	ld (02c38h),hl	;037e	22 38 2c 	" 8 ,
1583  0381 D1           	pop de		;0381	d1
1584  0382 CD 4C 09     	call l094ch	;0382	cd 4c 09 	  L
1585  0385 D1           	pop de		;0385	d1
1586  0386 E1           	pop hl		;0386	e1
1587  0387 CD 44 09     	call l0944h	;0387	cd 44 09 	  D
1588  038A 18 95        	jr l0321h	;038a	Jump to BASIC_CMDLINE_LOOP
1589  038C
1590  038C              ; 'PARSE AN IMMEDIATE COMMAND'
1591  038C              ; ============================
1592  038C              ; Parses and executes a BASIC command entered on the command line.
1593  038C
1594  038C              ; Calls PARSE with BASIC_CMDLINE_TABLE
1595  038C
1596  038C              ;; IMMEDIATE
1597  038C              l038ch:
1598  038C 21 17 03     	ld hl,l0317h	;038c	Push RESET_BASIC_2 address on stack
1599  038F E5           	push hl		;038f
1600  0390
1601  0390 2E 0E        	ld l,(l0f0fh-1)&00ffh
1602  0392              			;0390					HL = 0f0eh
1603  0392 01           	db 1		;0392  					BC = xx
1604  0393
1605  0393              ; 'EVALUATE NUMERIC FUNCTIONS'
1606  0393              ; ============================
1607  0393              ; Evaluates any functions from the numeric function table that appear at DE.
1608  0393
1609  0393              ; Calls PARSE with BASIC_FUNC_TABLE.
1610  0393
1611  0393              ;; EVAL_FUNCTIONS
1612  0393              l0393h:
1613  0393 2E 9B        	ld l,(l0f9ch-1)&00ffh
1614  0395              			;0393			HL = 0f9bh
1615  0395 01           	db 1		;0395   		BC = xx		BC = xx
1616  0396              l0396h:
1617  0396 2E EE        	ld l,0eeh	;0396	HL = 0feeh
1618  0398
1619  0398              ; 'BASIC FUNCTION PARSER'
1620  0398              ; =======================
1621  0398              ; Parse BASIC commands at DE.
1622  0398
1623  0398              ; Parameters:
1624  0398              ;	DE: String containing BASIC commands.
1625  0398              ;	L: Low byte of a pointer to the appropriate command table.
1626  0398
1627  0398              ;; PARSE
1628  0398              l0398h:
1629  0398 26 0F        	ld h,00fh	;0398
1630  039A
1631  039A              ;; PARSE_FIRST
1632  039A              l039ah:
1633  039A CD 05 01     	call l0105h	;039a	Skip leading space and get first character
1634  039D              			;	from string in DE (Call EAT_SPACE)
1635  039D
1636  039D D5           	push de		;039d	Store address of the first character on stack
1637  039E
1638  039E 13           	inc de		;039e	Increment DE and HL
1639  039F 23           	inc hl		;039f
1640  03A0
1641  03A0 BE           	cp (hl)		;03a0	Compare first character with first character
1642  03A1              			;	in table
1643  03A1
1644  03A1 28 06        	jr z,l03a9h	;03a1	Jump to PARSE_COMPARE if equal.
1645  03A3
1646  03A3 CB 7E        	bit 7,(hl)	;03a3	Test MSB of (HL)
1647  03A5 20 0C        	jr nz,l03b3h	;03a5	Jump to PARSE_END if set
1648  03A7
1649  03A7 18 11        	jr l03bah	;03a7	Jump to PARSE_NEXT if characters do not match
1650  03A9
1651  03A9              ; Compares string in DE (BASIC line) with string in HL (BASIC command table)
1652  03A9
1653  03A9              ;; PARSE_COMPARE
1654  03A9              l03a9h:
1655  03A9 1A           	ld a,(de)	;03a9	Get next character
1656  03AA
1657  03AA 13           	inc de		;03aa	Increment DE and HL
1658  03AB 23           	inc hl		;03ab
1659  03AC
1660  03AC BE           	cp (hl)		;03ac	Compare character
1661  03AD 28 FA        	jr z,l03a9h	;03ad	Loop if they match
1662  03AF
1663  03AF CB 7E        	bit 7,(hl)	;03af	Test MSB of (HL)
1664  03B1 28 03        	jr z,l03b6h	;03b1	Jump to PARSE_DOT if not set.
1665  03B3
1666  03B3              ; Complete table has been checked and no matching BASIC command has been found
1667  03B3
1668  03B3              ;; PARSE_END
1669  03B3              l03b3h:
1670  03B3 1B           	dec de		;03b3	Decrement DE
1671  03B4 18 12        	jr l03c8h	;03b4	Jump to PARSE_MATCH
1672  03B6
1673  03B6              ; A matching BASIC command has been found
1674  03B6
1675  03B6              ;; PARSE_DOT
1676  03B6              l03b6h:
1677  03B6 FE 2E        	cp 02eh		;03b6	Compare last character with ASCII '.'
1678  03B8 28 09        	jr z,l03c3h	;03b8	If equal then jump to PARSE_MATCH_PARTIAL
1679  03BA              			;	else continue checking with next command in
1680  03BA              			;	the command table.
1681  03BA
1682  03BA              ; Move (HL) to the next entry in the BASIC command table
1683  03BA
1684  03BA              ;; PARSE_NEXT
1685  03BA              l03bah:
1686  03BA 23           	inc hl		;03ba	Increment HL until MSB of (HL) is set
1687  03BB CB 7E        	bit 7,(hl)	;03bb
1688  03BD 28 FB        	jr z,l03bah	;03bd
1689  03BF
1690  03BF 23           	inc hl		;03bf	Increment HL
1691  03C0 D1           	pop de		;03c0	Restore DE
1692  03C1 18 D7        	jr l039ah	;03c1	Jump to PARSE_FIRST
1693  03C3
1694  03C3              ;; PARSE_MATCH_PARTIAL
1695  03C3              l03c3h:
1696  03C3 23           	inc hl		;03c3	Increment HL until MSB of (HL) is set
1697  03C4 CB 7E        	bit 7,(hl)	;03c4
1698  03C6 28 FB        	jr z,l03c3h	;03c6
1699  03C8
1700  03C8              ;; PARSE_MATCH
1701  03C8              l03c8h:
1702  03C8 7E           	ld a,(hl)	;03c8	HL = (HL) & 7fffh
1703  03C9 23           	inc hl		;03c9	number in (HL) is big endian!
1704  03CA 6E           	ld l,(hl)	;03ca
1705  03CB E6 7F        	and 07fh	;03cb
1706  03CD 67           	ld h,a		;03cd
1707  03CE
1708  03CE F1           	pop af		;03ce	Removed saved DE from stack
1709  03CF CB 74        	bit 6,h		;03cf	Test bit 6 of H
1710  03D1 CB B4        	res 6,h		;03d1	Reset bit 6 of H
1711  03D3
1712  03D3 E5           	push hl		;03d3	Push HL to stack
1713  03D4
1714  03D4 C4 6A 0A     	call nz,l0a6ah	;03d4	Call EVAL_PAREN_INT if bit 6 of H set.
1715  03D7              			;	(get function's argument)
1716  03D7
1717  03D7 C3 A9 2B     	jp 02ba9h	;03d7	Jump to BASIC_LINK (Returns to address in HL)
1718  03DA
1719  03DA              ; 'START (cont.)'
1720  03DA              ; ===============
1721  03DA              ; This is the rest of the boot code (it is executed only once, at power on)
1722  03DA
1723  03DA              ;; START_2
1724  03DA              l03dah:
1725  03DA ED 56        	im 1		;03da	Set interrupt mode 1
1726  03DC FD 21 FD 00  	ld iy,l00fdh	;03dc	Load 00fdh into IY
1727  03E0              			;	(default video interrupt hook)
1728  03E0
1729  03E0 21 FF 27     	ld hl,027ffh	;03e0	Load latch address (27ffh) into HL
1730  03E3 75           	ld (hl),l	;03e3	Load ffh into the latch (disable A7 clamp,
1731  03E4              			;	empty character scanline)
1732  03E4
1733  03E4 45           	ld b,l		;03e4	Load ffh into B.
1734  03E5
1735  03E5              ; This routine clears the entire RAM, starting at 2800h, if A holds 00h.
1736  03E5
1737  03E5              l03e5h:
1738  03E5 23           	inc hl		;03e5	Increment HL
1739  03E6 70           	ld (hl),b	;03e6	Load B (ffh) into (HL)
1740  03E7 34           	inc (hl)	;03e7	Increment (HL)
1741  03E8              			;	(HL) should now hold 00h if the address in HL
1742  03E8              			;	is mapped to RAM.
1743  03E8
1744  03E8 20 03        	jr nz,l03edh	;03e8	If not zero, break from loop
1745  03EA              			;	(reached the end of RAM)
1746  03EA
1747  03EA B6           	or (hl)		;03ea	If (HL) | A ...
1748  03EB 28 F8        	jr z,l03e5h	;03eb	... is zero, loop
1749  03ED
1750  03ED              l03edh:
1751  03ED 22 6A 2A     	ld (02a6ah),hl	;03ed	Store the last address in RAM + 1 into RAM_TOP
1752  03F0
1753  03F0 31 AD 2B     	ld sp,02badh	;03f0	Set SP to 2badh
1754  03F3 21 0B C9     	ld hl,0c90bh	;03f3	Load c90bh into HL
1755  03F6 E5           	push hl		;03f6	Store c9h (ret) into 2bach (VIDEO_LINK)
1756  03F7              			;	Store 0bh into 2babh
1757  03F7
1758  03F7 3B           	dec sp		;03f7	Decrement SP (2baah)
1759  03F8 E5           	push hl		;03f8	Store c9h (ret) into 2ba9h (BASIC_LINK)
1760  03F9              			;	Store 0bh into 2ba8h (HORIZ_POS)
1761  03F9
1762  03F9 3E 0C        	ld a,00ch	;03f9	Load 0ch (ASCII FF) into A
1763  03FB E7           	rst 20h		;03fb	Call PUTCH_RST
1764  03FC              			;	This clears the screen and places cursor in
1765  03FC              			;	the top left corner
1766  03FC
1767  03FC              ; Execution now continues to the NEW command. DE is (probably) set to 0000h
1768  03FC              ; after reset (points to the start of the ROM). Since there is no valid ASCII
1769  03FC              ; string there the code below behaves as if NEW command was called without an
1770  03FC              ; argument.
1771  03FC
1772  03FC              ; 'NEW'
1773  03FC              ; =====
1774  03FC              ; "NEW" BASIC command line command.
1775  03FC
1776  03FC              ;; NEW
1777  03FC              l03fch:
1778  03FC CD D3 0C     	call l0cd3h	;03fc	Read command argument (BASIC offset)
1779  03FF              			;	into HL (if any)
1780  03FF              			;	(call STRING_TO_INT)
1781  03FF
1782  03FF 11 3A 2C     	ld de,02c3ah	;03ff	Load 2c3ah (USER_MEM) into DE
1783  0402 19           	add hl,de	;0402	Add DE to HL
1784  0403
1785  0403 31 3A 2C     	ld sp,02c3ah	;0403	Load 2c3ah (USER_MEM) into SP
1786  0406 E5           	push hl		;0406	Store HL to 2c38 (BASIC_END)
1787  0407 E5           	push hl		;0407	Store HL to 2c36 (BASIC_START)
1788  0408              l0408h:
1789  0408 C3 67 00     	jp l0067h	;0408	Jump to RESET_BASIC
1790  040B
1791  040B              ; 'RUN'
1792  040B              ; =====
1793  040B              ; "RUN" BASIC command line command
1794  040B
1795  040B              ;; RUN
1796  040B              l040bh:
1797  040B CD D3 0C     	call l0cd3h	;040b	Read command argument
1798  040E              			;	(call STRING_TO_INT)
1799  040E
1800  040E ED 5B 36 2C  	ld de,(02c36h)	;040e	Load BASIC_START address into DE
1801  0412              l0412h:
1802  0412 18 0E        	jr l0422h	;0412	Jump to RUN_DO
1803  0414
1804  0414              ; 'CONTINUE'
1805  0414              ; ==========
1806  0414              ; Continue execution of a BASIC program.
1807  0414
1808  0414              ; A call to this function will try to execute the next command on the line
1809  0414              ; or will continue to the next line. If a valid command is found this function
1810  0414              ; never returns. On the other hand if neither ':' nor line end is encountered,
1811  0414              ; it returns.
1812  0414
1813  0414              ;; CONTINUE
1814  0414              l0414h:
1815  0414 32 B5 2B     	ld (02bb5h),a	;0414	Load A into FIXME
1816  0417
1817  0417 DF           	rst 18h		;0417	Call READ_PAR
1818  0418 3A           	db ':'		;0418
1819  0419 03           	db l041dh-$-1	;0419	Check for ':'. If not found jump to CONTINUE_CR
1820  041A
1821  041A              ;; ELSE
1822  041A              l041ah:
1823  041A F1           	pop af		;041a	Remove return address from stack.
1824  041B 18 10        	jr l042dh	;041b	Execute the rest of the line
1825  041D              			;	(jump to RUN_CONT_LINE)
1826  041D
1827  041D              ;; CONTINUE_CR
1828  041D              l041dh:
1829  041D DF           	rst 18h		;041d	Call READ_PAR
1830  041E 0D           	db 00dh		;041e
1831  041F 20           	db l0440h-$-1	;041f	Check for ASCII CR. If not found return.
1832  0420
1833  0420 F1           	pop af		;0420	Remove return address from stack and
1834  0421              			;	execute next BASIC line.
1835  0421
1836  0421              ; 'INTERPRET NEXT LINE OF BASIC'
1837  0421              ; =============================
1838  0421              ; Jump to this location finds the next BASIC line following DE and starts BASIC
1839  0421              ; interpreter at the BASIC.
1840  0421
1841  0421              ;; RUN_NEXT_LINE
1842  0421              l0421h:
1843  0421 EF           	rst 28h		;0421	Call CLEAR_HL
1844  0422
1845  0422              ;; RUN_DO
1846  0422              l0422h:
1847  0422 CD F6 07     	call l07f6h	;0422	Call FIND_LINE_SCOPE
1848  0425
1849  0425 38 E1        	jr c,l0408h	;0425	Jump to RESET_BASIC if line was not found.
1850  0427
1851  0427              ; 'INTERPRET A LINE OF BASIC'
1852  0427              ; =============================
1853  0427              ; Jump to this location starts BASIC interpreter at the BASIC line at DE.
1854  0427
1855  0427              ;; RUN_THIS_LINE
1856  0427              l0427h:
1857  0427 ED 53 9F 2A  	ld (02a9fh),de	;0427	Load DE into BASIC_LINE
1858  042B 13           	inc de		;042b	DE = DE + 2
1859  042C 13           	inc de		;042c	(points to the ASCII part of the line)
1860  042D
1861  042D              ; 'INTERPRET THE REST OF THE LINE'
1862  042D              ; ================================
1863  042D              ; Jump to this location interprets the rest of the line at DE.
1864  042D
1865  042D              ;; RUN_CONT_LINE
1866  042D              l042dh:
1867  042D CD FF 02     	call l02ffh	;042d	Call CHECK_BREAK
1868  0430
1869  0430 DD 21 AC 2A  	ld ix,02aach	;0430	Load ARITHM_STACK into IX
1870  0434
1871  0434 2E 2F        	ld l,(l0f30h-1)&00ffh
1872  0436              			;0434	Load 2fh into L
1873  0436
1874  0436 C3 98 03     	jp l0398h	;0436	Jump to PARSE with pointer to the
1875  0439              			;	BASIC_CMD_TABLE.
1876  0439
1877  0439              ; 'EVALUATE RELATIONAL OPERATORS (cont.)'
1878  0439              ; =======================================
1879  0439              ; Fetches the next expression at DE and compares its value with the top of
1880  0439              ; the stack.
1881  0439
1882  0439              ; Returns:
1883  0439              ;	HL: 0000h
1884  0439              ;	Flags: result of comparisson
1885  0439
1886  0439              ;; EVAL_RELATIONAL_2
1887  0439              l0439h:
1888  0439 CD 8E 06     	call l068eh	;0439	Call EVAL_ARITHMETIC
1889  043C CD 10 0B     	call l0b10h	;043c	Call FP_COMPARE
1890  043F EF           	rst 28h		;043f	Call CLEAR_HL
1891  0440              l0440h:
1892  0440 C9           	ret		;0440	Return
1893  0441
1894  0441              ;; IF
1895  0441              l0441h:
1896  0441 CF           	rst 8			;0441	cf
1897  0442 7C           	ld a,h			;0442	7c 	|
1898  0443 B5           	or l			;0443	b5
1899  0444 20 E7        	jr nz,l042dh		;0444	20 e7
1900  0446 CD 1C 08     	call l081ch		;0446	cd 1c 08
1901  0449
1902  0449              l0449h:
1903  0449 30 DC        	jr nc,l0427h	;0449	Jump to RUN_THIS_LINE
1904  044B 18 BB        	jr l0408h	;044b	...else jump to RESET_BASIC
1905  044D
1906  044D              ; 'COMMENT'
1907  044D              ; =========
1908  044D              ; "!" BASIC command. Does nothing. NOTE: An ELSE with IF also points here.
1909  044D
1910  044D              ;; COMMENT
1911  044D              l044dh:
1912  044D EF           	rst 28h		;044d	Call CLEAR_HL
1913  044E CD 13 08     	call l0813h	;044e	Find next line (call FIND_LINE_NEXT_2)
1914  0451 18 F6        	jr l0449h	;0451
1915  0453
1916  0453              ; 'GOTO'
1917  0453              ; ======
1918  0453              ; "GOTO" BASIC command.
1919  0453
1920  0453              ;; GOTO
1921  0453              l0453h:
1922  0453 CF           	rst 8		;0453	Get command argument
1923  0454 D5           	push de		;0454	Save DE on stack
1924  0455
1925  0455 CD F2 07     	call l07f2h	;0455	Call FIND_LINE.
1926  0458 C2 5B 06     	jp nz,l065bh	;0458	Jump to HOW_RST, if exact line number in
1927  045B              			;	argument was not found.
1928  045B
1929  045B              l045bh:
1930  045B F1           	pop af		;045b	Remove saved DE from stack.
1931  045C 18 C9        	jr l0427h	;045c	Jump to RUN_THIS_LINE.
1932  045E
1933  045E              ; 'LIST'
1934  045E              ; ======
1935  045E              ; "LIST" BASIC command line command.
1936  045E
1937  045E              ;; LIST
1938  045E              l045eh:
1939  045E CD D3 0C     	call l0cd3h	;045e	Read argument into HL (call STRING_TO_INT)
1940  0461
1941  0461              ; Note: if called from KEY, HL contains 0000h.
1942  0461
1943  0461              ;; LIST_KEY
1944  0461              l0461h:
1945  0461 CD ED 02     	call l02edh	;0461	Move cursor to a new line (call NEWLINE)
1946  0464 CD F2 07     	call l07f2h	;0464	Find the required BASIC line (call FIND_LINE)
1947  0467              l0467h:
1948  0467 38 9F        	jr c,l0408h	;0467	Jump to RESET_BASIC if line not found
1949  0469
1950  0469              ; Keep printing BASIC lines as long as RETURN or LIST key is pressed.
1951  0469
1952  0469              ;; LIST_LOOP
1953  0469              l0469h:
1954  0469 CD 31 09     	call l0931h	;0469	Call PRINT_BASIC_LINE
1955  046C CD F6 07     	call l07f6h	;046c	Find the following line (call FIND_LINE_SCOPE)
1956  046F
1957  046F 38 F6        	jr c,l0467h	;046f	Jump to RESET_BASIC if line not found
1958  0471
1959  0471              ;; LIST_KEY_LOOP
1960  0471              l0471h:
1961  0471 CD FF 02     	call l02ffh	;0471	Call CHECK_BREAK
1962  0474
1963  0474 3A 30 20     	ld a,(02030h)	;0474	Load "RETURN" key status into A
1964  0477 21 34 20     	ld hl,02034h	;0477	Load "LIST" key address into HL
1965  047A A6           	and (hl)	;047a
1966  047B 0F           	rrca		;047b
1967  047C 30 EB        	jr nc,l0469h	;047c	If either "RETURN" or "LIST" is pressed, loop
1968  047E              			;	to LIST_LOOP
1969  047E
1970  047E 18 F1        	jr l0471h	;047e	Else loop to LIST_KEY_LOOP
1971  0480
1972  0480              ; 'PRINT'
1973  0480              ; =======
1974  0480              ; "PRINT" BASIC command.
1975  0480
1976  0480              ;; PRINT
1977  0480              l0480h:
1978  0480 DF           	rst 18h		;0480	Call READ_PAR
1979  0481 3A           	db ':'		;0481
1980  0482 05           	db l0488h-$-1	;0482
1981  0483
1982  0483              			;	If ':' follows the PRINT command, just print
1983  0483              			;	a carriage return and continue execution
1984  0483              			;	at the rest of the line.
1985  0483
1986  0483 3E 0D        	ld a,00dh	;0483	Print ASCII CR
1987  0485 E7           	rst 20h		;0485	(call PUTCH_RST)
1988  0486 18 A5        	jr l042dh	;0486	Jump to RUN_CONT_LINE
1989  0488
1990  0488              l0488h:
1991  0488 DF           	rst 18h		;0488	Call READ_PAR
1992  0489 0D           	db 00dh		;0489	(ASCII CR)
1993  048A 46           	db l04d1h-$-1	;048a
1994  048B
1995  048B              			;	Jump to PRINT_DO if there is an argument
1996  048B
1997  048B              			;	Just PRINT without and argument prints a
1998  048B              			;	carriage return.
1999  048B
2000  048B E7           	rst 20h		;048b	Print ASCII CR
2001  048C              l048ch:
2002  048C 18 93        	jr l0421h	;048c	Jump to RUN_NEXT_LINE
2003  048E
2004  048E              ;; PRINTSTR_QUOTE
2005  048E              l048eh:
2006  048E DF           	rst 18h		;048e	Call READ_PAR
2007  048F 22           	db '"'		;048f
2008  0490 54           	db l04e5h-$-1	;0490
2009  0491
2010  0491              			;	If the argument doesn't begin with a quote
2011  0491              			;	evaluate its contents. Jump to FIXME
2012  0491
2013  0491              			;	If the argument begins with a quote, print
2014  0491              			;	the quoted string.
2015  0491
2016  0491 CD 38 09     	call l0938h	;0491	Print string following command ending with
2017  0494              			;	'"'. (call PRINTSTR_A)
2018  0494
2019  0494 20 F6        	jr nz,l048ch	;0494	No closing '"' found. Ignore this error and
2020  0496              			;	jump to RUN_NEXT_LINE
2021  0496
2022  0496 18 15        	jr l04adh	;0496	Jump FIXME
2023  0498              ;; X$
2024  0498              l0498h:
2025  0498 2E 5C        	ld l,05ch		;0498	2e 5c 	. \
2026  049A 01           	db 001h		;049a	Dummy ld bc,nn (skip next instruction)
2027  049B              ;; Y$
2028  049B              l049bh:
2029  049B 2E 60        	ld l,060h	;049b
2030  049D              l049dh:
2031  049D 26 2A        	ld h,02ah		;049d	26 2a 	& *
2032  049F CD 0E 06     	call l060eh		;049f	cd 0e 06
2033  04A2              l04a2h:
2034  04A2 7E           	ld a,(hl)			;04a2	7e 	~
2035  04A3 23           	inc hl			;04a3	23 	#
2036  04A4 B7           	or a			;04a4	b7
2037  04A5 28 06        	jr z,l04adh		;04a5	28 06 	(
2038  04A7 E7           	rst 20h			;04a7	e7
2039  04A8 7D           	ld a,l			;04a8	7d 	}
2040  04A9 E6 0F        	and 00fh		;04a9	e6 0f
2041  04AB 20 F5        	jr nz,l04a2h		;04ab	20 f5
2042  04AD
2043  04AD              l04adh:
2044  04AD DF           	rst 18h		;04ad	Call READ_PAR
2045  04AE 2C           	db ','		;04ae
2046  04AF 1B           	db l04cbh-$-1	;04af
2047  04B0
2048  04B0              l04b0h:
2049  04B0 3A 68 2A     	ld a,(02a68h)		;04b0	3a 68 2a 	: h *
2050  04B3 E6 07        	and 007h		;04b3	e6 07
2051  04B5 28 17        	jr z,l04ceh		;04b5	28 17 	(
2052  04B7 3E 20        	ld a,020h		;04b7	3e 20 	>
2053  04B9 E7           	rst 20h			;04b9	e7
2054  04BA 18 F4        	jr l04b0h		;04ba	18 f4
2055  04BC              ;; AT
2056  04BC              l04bch:
2057  04BC CF           	rst 8			;04bc	cf
2058  04BD 7C           	ld a,h			;04bd	7c 	|
2059  04BE F6 28        	or 028h		;04be	f6 28 	  (
2060  04C0 E6 29        	and 029h		;04c0	e6 29 	  )
2061  04C2 67           	ld h,a			;04c2	67 	g
2062  04C3 22 68 2A     	ld (02a68h),hl		;04c3	22 68 2a 	" h *
2063  04C6 DF           	rst 18h			;04c6	df
2064  04C7 2C           	inc l			;04c7	2c 	,
2065  04C8 02           	ld (bc),a			;04c8	02
2066  04C9 18 03        	jr l04ceh		;04c9	18 03
2067  04CB              l04cbh:
2068  04CB DF           	rst 18h		;04cb	Call READ_PAR
2069  04CC 3B           	db ';'		;04cc
2070  04CD 13           	db l04e1h-$-1	;04cd
2071  04CE
2072  04CE              l04ceh:
2073  04CE CD 14 04     	call l0414h		;04ce	cd 14 04
2074  04D1
2075  04D1              ; 'PRINT (cont.)'
2076  04D1              ; ===============
2077  04D1
2078  04D1              ;; PRINT_DO
2079  04D1              l04d1h:
2080  04D1 2E E0        	ld l,(l0fe1h-1)&00ffh
2081  04D3              			;04d1	Jump to PARSE with pointer to the
2082  04D3 C3 98 03     	jp l0398h	;04d3	BASIC_PRINT_TABLE
2083  04D6
2084  04D6              ; 'HOME'
2085  04D6              ; ======
2086  04D6              ; "HOME" BASIC command
2087  04D6
2088  04D6              ;; HOME
2089  04D6              l04d6h:
2090  04D6 CD D3 0C     	call l0cd3h	;04d6	Get command argument (call STRING_TO_INT)
2091  04D9
2092  04D9 22 6C 2A     	ld (02a6ch),hl	;04d9	Store argument into WINDOW_LEN
2093  04DC
2094  04DC 20 06        	jr nz,l04e4h	;04dc	If there was a non-zero argument, that is all.
2095  04DE              			;	Call BASIC_NEXT
2096  04DE
2097  04DE 3E 0C        	ld a,00ch	;04de	Load ASCII FF into A
2098  04E0 01           	db 001h		;04e0	Dummy "ld bc,nn" (skip next two instructions)
2099  04E1              l04e1h:
2100  04E1 3E 0D        	ld a,00dh	;04e1	Load ASCII CR into A
2101  04E3
2102  04E3 E7           	rst 20h		;04e3	Call PUTCH_RST
2103  04E4              l04e4h:
2104  04E4 F7           	rst 30h		;04e4	Call BASIC_NEXT
2105  04E5
2106  04E5              l04e5h:
2107  04E5 CD 96 03     	call l0396h		;04e5	cd 96 03
2108  04E8 20 07        	jr nz,l04f1h		;04e8	20 07
2109  04EA CD B2 0A     	call l0ab2h		;04ea	cd b2 0a
2110  04ED CD F6 08     	call l08f6h		;04ed	cd f6 08
2111  04F0
2112  04F0              ; following two lines from Diss_019.jpg
2113  04F0 3E           	db 03eh			;04f0	Dummy LD A,
2114  04F1              l04f1h:
2115  04F1 E7           	rst 20h			;04f1	e7 	>
2116  04F2
2117  04F2 18 B9        	jr l04adh		;04f2	18 b9
2118  04F4              ;; CALL
2119  04F4              l04f4h:
2120  04F4 CD 74 09     	call l0974h		;04f4	cd 74 09 	  t
2121  04F7 CF           	rst 8			;04f7	cf
2122  04F8 D5           	push de			;04f8	d5
2123  04F9 CD F2 07     	call l07f2h		;04f9	cd f2 07
2124  04FC C2 5B 06     	jp nz,l065bh		;04fc	c2 5b 06 	  [
2125  04FF 2A 9F 2A     	ld hl,(02a9fh)		;04ff	2a 9f 2a 	*   *
2126  0502 E5           	push hl			;0502	e5
2127  0503 2A A3 2A     	ld hl,(02aa3h)		;0503	2a a3 2a 	*   *
2128  0506 E5           	push hl			;0506	e5
2129  0507 EF           	rst 28h			;0507	ef
2130  0508 22 A1 2A     	ld (02aa1h),hl		;0508	22 a1 2a 	"   *
2131  050B 39           	add hl,sp			;050b	39 	9
2132  050C 22 A3 2A     	ld (02aa3h),hl		;050c	22 a3 2a 	"   *
2133  050F C3 27 04     	jp l0427h		;050f	c3 27 04 	  '
2134  0512              ;; RET
2135  0512              l0512h:
2136  0512 2A A3 2A     	ld hl,(02aa3h)		;0512	2a a3 2a 	*   *
2137  0515 7C           	ld a,h			;0515	7c 	|
2138  0516 B5           	or l			;0516	b5
2139  0517 CA 5A 06     	jp z,l065ah		;0517	ca 5a 06 	  Z
2140  051A F9           	ld sp,hl			;051a	f9
2141  051B E1           	pop hl			;051b	e1
2142  051C 22 A3 2A     	ld (02aa3h),hl		;051c	22 a3 2a 	"   *
2143  051F E1           	pop hl			;051f	e1
2144  0520 22 9F 2A     	ld (02a9fh),hl		;0520	22 9f 2a 	"   *
2145  0523 D1           	pop de			;0523	d1
2146  0524              l0524h:
2147  0524 CD 59 09     	call l0959h		;0524	cd 59 09 	  Y
2148  0527 F7           	rst 30h			;0527	f7
2149  0528              ;; STEP
2150  0528              l0528h:
2151  0528 CF           	rst 8			;0528	cf
2152  0529 01           	db 001h		;0529	Dummy ld bc,nn (skip next two instructions)
2153  052A
2154  052A              l052ah:
2155  052A EF           	rst 28h		;052a
2156  052B 23           	inc hl		;052b
2157  052C 22 91 2A     	ld (02a91h),hl		;052c	22 91 2a 	"   *
2158  052F 2A 9F 2A     	ld hl,(02a9fh)		;052f	2a 9f 2a 	*   *
2159  0532 22 93 2A     	ld (02a93h),hl		;0532	22 93 2a 	"   *
2160  0535 EB           	ex de,hl			;0535	eb
2161  0536 22 95 2A     	ld (02a95h),hl		;0536	22 95 2a 	"   *
2162  0539 01 0A 00     	ld bc,l0005h+5		;0539	01 0a 00
2163  053C 2A A1 2A     	ld hl,(02aa1h)		;053c	2a a1 2a 	*   *
2164  053F EB           	ex de,hl			;053f	eb
2165  0540 EF           	rst 28h			;0540	ef
2166  0541 39           	add hl,sp		;0541	39 	9
2167  0542              ; Following two lines from Diss_019.jph
2168  0542 3E           	db 03eh			;0542	Dummy LD A,
2169  0543              l0543h:
2170  0543 09           	add hl,bc		;0543	09 	>
2171  0544
2172  0544 7E           	ld a,(hl)		;0544	7e 	~
2173  0545 23           	inc hl			;0545	23 	#
2174  0546 B6           	or (hl)			;0546	b6
2175  0547 28 16        	jr z,l055fh		;0547	28 16 	(
2176  0549 7E           	ld a,(hl)			;0549	7e 	~
2177  054A 2B           	dec hl			;054a	2b 	+
2178  054B BA           	cp d			;054b	ba
2179  054C 20 F5        	jr nz,l0543h		;054c	20 f5
2180  054E 7E           	ld a,(hl)			;054e	7e 	~
2181  054F BB           	cp e			;054f	bb
2182  0550 20 F1        	jr nz,l0543h		;0550	20 f1
2183  0552 EB           	ex de,hl			;0552	eb
2184  0553 EF           	rst 28h			;0553	ef
2185  0554 39           	add hl,sp			;0554	39 	9
2186  0555 44           	ld b,h			;0555	44 	D
2187  0556 4D           	ld c,l			;0556	4d 	M
2188  0557 21 0A 00     	ld hl,l0005h+5		;0557	21 0a 00 	!
2189  055A 19           	add hl,de			;055a	19
2190  055B CD 4C 09     	call l094ch		;055b	cd 4c 09 	  L
2191  055E F9           	ld sp,hl			;055e	f9
2192  055F              l055fh:
2193  055F 2A 95 2A     	ld hl,(02a95h)		;055f	2a 95 2a 	*   *
2194  0562 EB           	ex de,hl			;0562	eb
2195  0563 F7           	rst 30h			;0563	f7
2196  0564              ; 'NEXT'
2197  0564              ; ======
2198  0564              ; "NEXT" BASIC command
2199  0564
2200  0564              ;; NEXT
2201  0564              l0564h:
2202  0564 CD 8B 07     	call l078bh	;0564	Call LOCATE_VARIABLE_ERR
2203  0567 22 9B 2A     	ld (02a9bh),hl	;0567	Load variable location into NEXT_VAR
2204  056A              l056ah:
2205  056A D5           	push de		;056a	Save parser address on stack
2206  056B
2207  056B EB           	ex de,hl	;056b	DE = NEXT_VAR
2208  056C
2209  056C 2A A1 2A     	ld hl,(02aa1h)	;056c	Load FOR_POINTER into HL
2210  056F
2211  056F 7C           	ld a,h		;056f
2212  0570 B5           	or l		;0570
2213  0571 CA 5B 06     	jp z,l065bh	;0571	Jump to HOW_RST if FOR_POINTER is 0000h
2214  0574
2215  0574 D7           	rst 10h		;0574	Run CMP_HL_DE
2216  0575
2217  0575 28 09        	jr z,l0580h	;0575	Jump to FIXME if FOR_POINTER == NEXT_VAR
2218  0577
2219  0577 D1           	pop de		;0577	Remove DE from stack
2220  0578
2221  0578 CD 59 09     	call l0959h	;0578	cd 59 09 	  Y
2222  057B 2A 9B 2A     	ld hl,(02a9bh)	;057b	2a 9b 2a 	*   *
2223  057E 18 EA        	jr l056ah	;057e	18 ea
2224  0580
2225  0580              l0580h:
2226  0580 CD 45 0A     	call l0a45h	;0580	Call PUSH_FP
2227  0583 CD 6D 0A     	call l0a6dh	;0583	Call FP_TO_INT
2228  0586
2229  0586 EB           	ex de,hl	;0586	HL = NEXT variable address
2230  0587              			;	DE = NEXT variabe value
2231  0587
2232  0587 2A 91 2A     	ld hl,(02a91h)	;0587	Load FOR_STEP value into HL
2233  058A
2234  058A E5           	push hl		;058a	Save FOR_STEP to the stack
2235  058B
2236  058B 19           	add hl,de	;058b	HL = current NEXT variable value + FOR_STEP
2237  058C
2238  058C E5           	push hl		;058c	Save HL on stack
2239  058D
2240  058D CD BC 0A     	call l0abch	;058d	Call INT_TO_FP
2241  0590
2242  0590 2A A1 2A     	ld hl,(02aa1h)	;0590	Load FOR_POINTER into HL
2243  0593 CD 3B 07     	call l073bh	;0593	Store new value into variable (call POP_FP)
2244  0596
2245  0596 D1           	pop de		;0596	DE = value of the NEXT variable
2246  0597 2A 6E 2A     	ld hl,(02a6eh)	;0597	HL = FOR_TO value
2247  059A F1           	pop af	 	;059a	AF = FOR_STEP
2248  059B
2249  059B 07           	rlca		;059b	07
2250  059C 30 01        	jr nc,l059fh	;059c	30 01 	0
2251  059E
2252  059E EB           	ex de,hl		;059e	eb
2253  059F              l059fh:
2254  059F 7C           	ld a,h			;059f	7c 	|
2255  05A0 AA           	xor d			;05a0	aa
2256  05A1 F2 A5 05     	jp p,l05a5h		;05a1	f2 a5 05
2257  05A4 EB           	ex de,hl			;05a4	eb
2258  05A5              l05a5h:
2259  05A5 D7           	rst 10h			;05a5	d7
2260  05A6 D1           	pop de			;05a6	d1
2261  05A7 DA 24 05     	jp c,l0524h		;05a7	da 24 05 	  $
2262  05AA 2A 93 2A     	ld hl,(02a93h)		;05aa	2a 93 2a 	*   *
2263  05AD 22 9F 2A     	ld (02a9fh),hl		;05ad	22 9f 2a 	"   *
2264  05B0 18 AD        	jr l055fh		;05b0	18 ad
2265  05B2              l05b2h:
2266  05B2 CA 36 07     	jp z,l0736h		;05b2	ca 36 07 	  6
2267  05B5              l05b5h:
2268  05B5 E5           	push hl			;05b5	e5
2269  05B6 CD FC 05     	call l05fch		;05b6	cd fc 05
2270  05B9 38 0F        	jr c,l05cah		;05b9	38 0f 	8
2271  05BB 28 25        	jr z,l05e2h		;05bb	28 25 	( %
2272  05BD E3           	ex (sp),hl			;05bd	e3
2273  05BE C1           	pop bc			;05be	c1
2274  05BF              l05bfh:
2275  05BF 0A           	ld a,(bc)			;05bf	0a
2276  05C0 B7           	or a			;05c0	b7
2277  05C1 28 2A        	jr z,l05edh		;05c1	28 2a 	( *
2278  05C3 03           	inc bc			;05c3	03
2279  05C4 CD 7E 01     	call l017eh		;05c4	cd 7e 01 	  ~
2280  05C7 20 F6        	jr nz,l05bfh		;05c7	20 f6
2281  05C9 C9           	ret			;05c9	c9
2282  05CA              l05cah:
2283  05CA E1           	pop hl			;05ca	e1
2284  05CB DF           	rst 18h			;05cb	df
2285  05CC              ; Following lines from Diss_020.jpg
2286  05CC 22           	db '"'			;05cc
2287  05CD 00           	db 000h			;05cd
2288  05CE              l05ceh:
2289  05CE CD D9 05     	call l05d9h		;05ce	cd d9 05
2290  05D1 28 1A        	jr z,l05edh		;05d1	28 1a 	(
2291  05D3 13           	inc de			;05d3	13
2292  05D4 CD 7E 01     	call l017eh		;05d4	cd 7e 01 	  ~
2293  05D7 20 F5        	jr nz,l05ceh		;05d7	20 f5
2294  05D9              l05d9h:
2295  05D9 1A           	ld a,(de)		;05d9	1a
2296  05DA FE 0D        	cp 00dh		;05da	fe 0d
2297  05DC C8           	ret z			;05dc	c8
2298  05DD FE 22        	cp 022h		;05dd	fe 22 	  "
2299  05DF C0           	ret nz			;05df	c0
2300  05E0 13           	inc de			;05e0	13
2301  05E1 C9           	ret			;05e1	c9
2302  05E2              l05e2h:
2303  05E2 1B           	dec de			;05e2	1b
2304  05E3 CD 96 03     	call l0396h		;05e3	cd 96 03
2305  05E6 28 E2        	jr z,l05cah		;05e6	28 e2 	(
2306  05E8 E1           	pop hl			;05e8	e1
2307  05E9 CD 7E 01     	call l017eh		;05e9	cd 7e 01 	  ~
2308  05EC C8           	ret z			;05ec	c8
2309  05ED              l05edh:
2310  05ED DF           	rst 18h			;05ed	df
2311  05EE 2B           	dec hl			;05ee	2b 	+
2312  05EF 02           	ld (bc),a			;05ef	02
2313  05F0 18 C3        	jr l05b5h		;05f0	18 c3
2314  05F2 36 00        	ld (hl),000h		;05f2	36 00 	6
2315  05F4              l05f4h:
2316  05F4 CD 7F 01     	call l017fh		;05f4	cd 7f 01 	  
2317  05F7 C8           	ret z			;05f7	c8
2318  05F8 36 30        	ld (hl),030h		;05f8	36 30 	6 0
2319  05FA 18 F8        	jr l05f4h		;05fa	18 f8
2320  05FC              l05fch:
2321  05FC CD 25 01     	call l0125h		;05fc	cd 25 01 	  %
2322  05FF D8           	ret c			;05ff	d8
2323  0600              l0600h:
2324  0600 1B           	dec de			;0600	1b
2325  0601 1A           	ld a,(de)			;0601	1a
2326  0602 13           	inc de			;0602	13
2327  0603 FE 29        	cp 029h		;0603	fe 29 	  )
2328  0605 C8           	ret z			;0605	c8
2329  0606 1A           	ld a,(de)			;0606	1a
2330  0607 FE 24        	cp 024h		;0607	fe 24 	  $
2331  0609 28 02        	jr z,l060dh		;0609	28 02 	(
2332  060B              ;; FIXME catch all
2333  060B              l060bh:
2334  060B AF           	xor a			;060b	af
2335  060C C9           	ret			;060c	c9
2336  060D              l060dh:
2337  060D 13           	inc de			;060d	13
2338  060E              l060eh:
2339  060E 7D           	ld a,l			;060e	7d 	}
2340  060F D6 5C        	sub 05ch		;060f	d6 5c 	  \
2341  0611 20 0A        	jr nz,l061dh		;0611	20 0a
2342  0613 2E 70        	ld l,070h		;0613	2e 70 	. p
2343  0615 DF           	rst 18h			;0615	df
2344  0616 28 03        	jr z,l061bh		;0616	28 03 	(
2345  0618 CD 14 01     	call l0114h		;0618	cd 14 01
2346  061B              l061bh:
2347  061B B4           	or h			;061b	b4
2348  061C C9           	ret			;061c	c9
2349  061D              l061dh:
2350  061D FE 07        	cp 007h		;061d	fe 07
2351  061F D2 8F 07     	jp nc,l078fh		;061f	d2 8f 07
2352  0622 2E 80        	ld l,080h		;0622	2e 80 	.
2353  0624 B4           	or h			;0624	b4
2354  0625 C9           	ret			;0625	c9
2355  0626              ;; TAKE
2356  0626              l0626h:
2357  0626 CD FC 05     	call l05fch		;0626	cd fc 05
2358  0629 38 38        	jr c,l0663h		;0629	38 38 	8 8
2359  062B D5           	push de			;062b	d5
2360  062C F5           	push af			;062c	f5
2361  062D E5           	push hl			;062d	e5
2362  062E ED 5B 9D 2A  	ld de,(02a9dh)		;062e	ed 5b 9d 2a 	  [   *
2363  0632 2A 38 2C     	ld hl,(02c38h)		;0632	2a 38 2c 	* 8 ,
2364  0635              l0635h:
2365  0635 DF           	rst 18h			;0635	df
2366  0636 23           	inc hl			;0636	23 	#
2367  0637 02           	ld (bc),a			;0637	02
2368  0638 18 03        	jr l063dh		;0638	18 03
2369  063A DF           	rst 18h			;063a	df
2370  063B 2C           	inc l			;063b	2c 	,
2371  063C 0F           	rrca			;063c	0f
2372  063D              l063dh:
2373  063D E1           	pop hl			;063d	e1
2374  063E F1           	pop af			;063e	f1
2375  063F CD B2 05     	call l05b2h		;063f	cd b2 05
2376  0642              l0642h:
2377  0642 ED 53 9D 2A  	ld (02a9dh),de		;0642	ed 53 9d 2a 	  S   *
2378  0646 D1           	pop de			;0646	d1
2379  0647 DF           	rst 18h			;0647	df
2380  0648 2C           	inc l			;0648	2c 	,
2381  0649 43           	ld b,e			;0649	43 	C
2382  064A 18 DA        	jr l0626h		;064a	18 da
2383  064C              l064ch:
2384  064C 1A           	ld a,(de)			;064c	1a
2385  064D 13           	inc de			;064d	13
2386  064E FE 0D        	cp 00dh		;064e	fe 0d
2387  0650 20 FA        	jr nz,l064ch		;0650	20 fa
2388  0652 13           	inc de			;0652	13
2389  0653 13           	inc de			;0653	13
2390  0654 D7           	rst 10h			;0654	d7
2391  0655 30 DE        	jr nc,l0635h		;0655	30 de 	0
2392  0657 E1           	pop hl			;0657	e1
2393  0658              l0658h:
2394  0658 F1           	pop af			;0658	f1
2395  0659              ; from Diss_020.jph
2396  0659
2397  0659 0E           	db 00eh			;0659	Dummy LD,C
2398  065A
2399  065A              ; '"HOW?" ERROR RESTART'
2400  065A              ; =======================
2401  065A              ; This restart is called when an argument for a function or command is invalid.
2402  065A              ; (for example out of range)
2403  065A
2404  065A              ;; HOW_RST_PUSH_DE
2405  065A              l065ah:
2406  065A D5           	push de		;065a	Push current parser address on stack.
2407  065B
2408  065B              ;; HOW_RST
2409  065B              l065bh:
2410  065B CD 99 07     	call l0799h	;065b	Call BASIC_ERROR
2411  065E 48 4F 57 3F  	dm "HOW?", 00dh ;065e
2411  0662 0D
2412  0663
2413  0663              l0663h:
2414  0663 CF           	rst 8			;0663	cf
2415  0664 D5           	push de			;0664	d5
2416  0665 CD F2 07     	call l07f2h		;0665	cd f2 07
2417  0668 13           	inc de			;0668	13
2418  0669 13           	inc de			;0669	13
2419  066A 18 D6        	jr l0642h		;066a	18 d6
2420  066C              ;; INPUT
2421  066C              l066ch:
2422  066C D5           	push de			;066c	d5
2423  066D 3E 3F        	ld a,03fh		;066d	3e 3f 	> ?
2424  066F CD BD 07     	call l07bdh		;066f	cd bd 07
2425  0672 11 B6 2B     	ld de,02bb6h		;0672	11 b6 2b 	    +
2426  0675 DF           	rst 18h			;0675	df
2427  0676 0D           	dec c			;0676	0d
2428  0677 05           	dec b			;0677	05
2429  0678 D1           	pop de			;0678	d1
2430  0679 CD FC 05     	call l05fch		;0679	cd fc 05
2431  067C F7           	rst 30h			;067c	f7
2432  067D D1           	pop de			;067d	d1
2433  067E D5           	push de			;067e	d5
2434  067F CD FC 05     	call l05fch		;067f	cd fc 05
2435  0682 38 D7        	jr c,l065bh		;0682	38 d7 	8
2436  0684 D5           	push de			;0684	d5
2437  0685 11 B6 2B     	ld de,02bb6h		;0685	11 b6 2b 	    +
2438  0688 CD B2 05     	call l05b2h		;0688	cd b2 05
2439  068B D1           	pop de			;068b	d1
2440  068C F1           	pop af			;068c	f1
2441  068D F7           	rst 30h			;068d	f7
2442  068E
2443  068E              ; 'EVALUATE ARITHMETIC OPERATORS'
2444  068E              ; ===============================
2445  068E              ; Evaluates an arithmetic expression at DE and returns its value on arithmetic
2446  068E              ; stack.
2447  068E
2448  068E              ;; EVAL_ARITHMETIC
2449  068E              l068eh:
2450  068E
2451  068E              ; Start by checking for a leading "+" or "-" character.
2452  068E
2453  068E DF           	rst 18h		;068e	Call READ_PAR
2454  068F 2D           	db '-'		;068f
2455  0690 06           	db l0697h-$-1	;0690
2456  0691
2457  0691              ; Leading "-" sign - add an implicit 0 to arithmetic stack and jump to
2458  0691              ; subtraction.
2459  0691
2460  0691 EF           	rst 28h		;0691	Call CLEAR_HL
2461  0692 CD BC 0A     	call l0abch	;0692	Call INT_TO_FP
2462  0695 18 14        	jr l06abh	;0695	Jump to subtraction
2463  0697
2464  0697              l0697h:
2465  0697 DF           	rst 18h		;0697	Call READ_PAR
2466  0698 2B           	db '+'		;0698
2467  0699 00           	db 000h		;0699
2468  069A
2469  069A              ; Ignore a leading plus sign. Load level 2 value to arithmetic stack.
2470  069A
2471  069A CD B3 06     	call l06b3h	;069a	Call EVAL_LVL2
2472  069D
2473  069D              ; Level 1 - Evaluation of addition and subtraction
2474  069D
2475  069D              ;; EVAL_LVL1
2476  069D              l069dh:
2477  069D DF           	rst 18h		;069d	Call READ_PAR
2478  069E 2B           	db '+'		;069e
2479  069F 08           	db l06a8h-$-1	;069f
2480  06A0
2481  06A0              ; Addition. Load a value from level 2 and add them together
2482  06A0
2483  06A0 CD B3 06     	call l06b3h	;06a0	Call EVAL_LVL2
2484  06A3 CD 32 0B     	call l0b32h	;06a3	Call FP_ADD
2485  06A6 18 F5        	jr l069dh	;06a6	Jump back to EVAL_LVL1
2486  06A8
2487  06A8              l06a8h:
2488  06A8 DF           	rst 18h		;06a8	Call READ_PAR
2489  06A9 2D           	db '-'		;06a9
2490  06AA DF           	db l078ah-$-1	;06aa	Return if operand is neither "+" nor "-"
2491  06AB
2492  06AB              ; Subtraction. Load a value from level 2 and add them together
2493  06AB
2494  06AB              l06abh:
2495  06AB CD B3 06     	call l06b3h	;06ab	Call EVAL_LVL2
2496  06AE CD 1E 0B     	call l0b1eh	;06ae	Call FP_SUB
2497  06B1 18 EA        	jr l069dh	;06b1	Jump back to EVAL_LVL1
2498  06B3
2499  06B3              ; Level 2 - Evaluation of multiplication and division
2500  06B3
2501  06B3              ;; EVAL_LVL2
2502  06B3              l06b3h:
2503  06B3 CD 93 03     	call l0393h	;06b3	Call EVAL_FUNCTIONS
2504  06B6              l06b6h:
2505  06B6 DF           	rst 18h		;06b6	Call READ_PAR
2506  06B7 2A           	db '*'		;06b7
2507  06B8 08           	db l06c1h-$-1	;06b8
2508  06B9
2509  06B9              ; Multiplication
2510  06B9
2511  06B9 CD 93 03     	call l0393h 	;06b9	Call EVAL_FUNCTIONS
2512  06BC CD E6 0A     	call l0ae6h	;06bc	Call FP_MUL
2513  06BF 18 F5        	jr l06b6h	;06bf	Return back to level 2 evaluation
2514  06C1
2515  06C1              l06c1h:
2516  06C1 DF           	rst 18h		;06c1	Call READ_PAR
2517  06C2 2F           	db '/'		;06c2
2518  06C3 C6           	db l078ah-$-1 	;06c3	Return if operand is neither "+" nor "-"
2519  06C4
2520  06C4              ; Division
2521  06C4
2522  06C4 CD 93 03     	call l0393h	;06c4	Call EVAL_FUNCTIONS
2523  06C7 CD F7 0A     	call l0af7h	;06c7	Call FP_DIV
2524  06CA 18 EA        	jr l06b6h	;06ca	Return back to level 2 evaluation
2525  06CC
2526  06CC              ; 'UNDOT'
2527  06CC              ; =======
2528  06CC              ; "UNDOT" BASIC command.
2529  06CC
2530  06CC              ;; UNDOT
2531  06CC              l06cch:
2532  06CC 3E 01        	ld a,001h	;06cc	Load 01h into A (Zf = 0, Sf = 0)
2533  06CE
2534  06CE 01           	db 001h		;06ce	Dummy ld bc,nn (skip next instruction)
2535  06CF
2536  06CF              ; 'DOT'
2537  06CF              ; =====
2538  06CF              ; "DOT" BASIC command.
2539  06CF
2540  06CF              ;; DOT
2541  06CF              l06cfh:
2542  06CF 3E 80        	ld a,080h	;06cf	Load 80h into A (Zf = 0, Sf = 1)
2543  06D1
2544  06D1 F5           	push af		;06d1	Store AF on stack
2545  06D2
2546  06D2 DF           	rst 18h		;06d2	Call READ_PAR
2547  06D3 2A           	db '*'		;06d3
2548  06D4 05           	db l06dah-$-1	;06d4
2549  06D5
2550  06D5              ; DOT* and UNDOT* versions of command: turn clock on or off
2551  06D5
2552  06D5 F1           	pop af		;06d5	Restore AF from stack
2553  06D6
2554  06D6 32 AF 2B     	ld (02bafh),a	;06d6	Store A into CLOCK_ON
2555  06D9 F7           	rst 30h		;06d9	Continue with the next command (call BASIC_NEXT)
2556  06DA
2557  06DA              l06dah:
2558  06DA F1           	pop af		;06da	Restore AF from stack
2559  06DB 06           	db 006h		;06db	Dummy "ld b,nn" (skip next two commands so that
2560  06DC              			;	flags remain unchanged)
2561  06DC
2562  06DC              ; 'DOT FUNCTION'
2563  06DC              ; ==============
2564  06DC              ; "DOT" BASIC function.
2565  06DC
2566  06DC              ;; DOT_FUNC
2567  06DC              l06dch:
2568  06DC AF           	xor a		;06dc	Clear A, set Zf and clear Sf
2569  06DD A7           	and a		;06dd
2570  06DE
2571  06DE              ; Meaning of flags at this point:
2572  06DE              ;
2573  06DE              ; Zf	Sf	function
2574  06DE              ; -----------------------------------------
2575  06DE              ; 1	x	Query pixel (DOT function)
2576  06DE              ; 0	0	Clear pixel (UNDOT command)
2577  06DE              ; 0	1	Draw pixel  (DOT command)
2578  06DE
2579  06DE F5           	push af		;06de	Save A on stack
2580  06DF
2581  06DF CF           	rst 8		;06df	Get X coordinate (call EVAL_INT_EXP)
2582  06E0 E5           	push hl		;06e0	Save X on stack
2583  06E1
2584  06E1 CD 05 00     	call l0005h	;06e1	Get Y coordinate (call EVAL_INT_EXP_NEXT)
2585  06E4 D5           	push de		;06e4	Save DE on stack
2586  06E5 EB           	ex de,hl	;06e5	Move Y to DE (actually E, since Y < 48)
2587  06E6
2588  06E6 01 20 00     	ld bc,32	;06e6	Load 32 into BC
2589  06E9
2590  06E9 1C           	inc e		;06e9	Increment E
2591  06EA 21 00 28     	ld hl,02800h	;06ea	Load VIDEO_MEM into HL
2592  06ED
2593  06ED              ; HL = 2800h + 32 * (E / 3)
2594  06ED              ; A = 1 << (E % 3)
2595  06ED
2596  06ED              ;; DOT_DIV_3_LOOP
2597  06ED              l06edh:
2598  06ED 16 03        	ld d,3		;06ed	Load 3 into D
2599  06EF 3E 01        	ld a,1		;06ef	Load 1 into A
2600  06F1
2601  06F1              ;; DOT_DIV_1_LOOP
2602  06F1              l06f1h:
2603  06F1 1D           	dec e		;06f1	Decrement E
2604  06F2 28 0A        	jr z,l06feh	;06f2	Break from loop if E = 0
2605  06F4
2606  06F4 07           	rlca		;06f4	Rotate A left 2 times
2607  06F5 07           	rlca		;06f5
2608  06F6
2609  06F6 15           	dec d		;06f6	Decrement D, loop to DOT_DIV_1_LOOP if not zero
2610  06F7 20 F8        	jr nz,l06f1h	;06f7
2611  06F9
2612  06F9 09           	add hl,bc	;06f9	Add 32 to HL for each 3 decrements of E
2613  06FA CB 8C        	res 1,h		;06fa	HL = HL & 01ff
2614  06FC 18 EF        	jr l06edh	;06fc	Loop to DOT_DIV_3_LOOP
2615  06FE
2616  06FE              ; HL contains address of the character line that holds the required graphics
2617  06FE              ; coordinates.
2618  06FE
2619  06FE              l06feh:
2620  06FE 47           	ld b,a		;06fe	Save A to B (?)
2621  06FF D1           	pop de		;06ff	Restore DE from stack
2622  0700
2623  0700 E3           	ex (sp),hl	;0700	Save line address to stack, move X to HL
2624  0701
2625  0701 CB BD        	res 7,l		;0701	X = X & 001f
2626  0703 CB B5        	res 6,l		;0703
2627  0705
2628  0705 CB 3D        	srl l		;0705	X = X / 2
2629  0707
2630  0707 30 01        	jr nc,l070ah	;0707	Shift A left if X odd
2631  0709 07           	rlca		;0709
2632  070A              l070ah:
2633  070A
2634  070A 26 00        	ld h,000h	;070a	Clear H
2635  070C
2636  070C C1           	pop bc		;070c	Get line address from stack
2637  070D 09           	add hl,bc	;070d	Add X / 2.
2638  070E
2639  070E 47           	ld b,a		;070e	Save A to B
2640  070F
2641  070F F1           	pop af		;070f	Restore flags from stack
2642  0710 78           	ld a,b		;0710
2643  0711
2644  0711              ; HL now contains the address of the character, A contains the bitmask.
2645  0711
2646  0711 20 0C        	jr nz,l071fh	;0711	If Zf not set, jump to DOT_DRAW_OR_CLEAR
2647  0713
2648  0713              ; Check if pixel is set and return a floating point value 1 or 0
2649  0713
2650  0713 CB 7E        	bit 7,(hl)	;0713	If (HL) is not graphics character (bit 7 not
2651  0715 28 01        	jr z,l0718h	;0715	set), jump over and return 0.
2652  0717
2653  0717 A6           	and (hl)	;0717	Check if bit in A is set in (HL)
2654  0718              l0718h:
2655  0718 EF           	rst 28h		;0718	Call CLEAR_HL
2656  0719
2657  0719 28 01        	jr z,l071ch	;0719	If bit was set HL = 1 else HL = 0
2658  071B 23           	inc hl		;071b
2659  071C              l071ch:
2660  071C C3 BC 0A     	jp l0abch	;071c	Jump to INT_TO_FP and return
2661  071F
2662  071F              ; Draw or clear the pixel
2663  071F
2664  071F              ;; DOT_DRAW_OR_CLEAR
2665  071F              l071fh:
2666  071F F5           	push af		;071f	Save flags on stack
2667  0720
2668  0720 CB 7E        	bit 7,(hl)	;0720	If (HL) is not already a graphics character
2669  0722 20 02        	jr nz,l0726h	;0722	write a blank character (80h).
2670  0724 36 80        	ld (hl),080h	;0724
2671  0726              l0726h:
2672  0726
2673  0726 F1           	pop af		;0726	Restore flags from stack
2674  0727 FA 2D 07     	jp m,l072dh	;0727	If sign negative, draw a pixel, else clear
2675  072A              			;	a pixel.
2676  072A
2677  072A 2F           	cpl		;072a	Clear bit in A in (HL)
2678  072B A6           	and (hl)	;072b
2679  072C 06           	db 006h		;072c	Dummy ld b,nn (skip next instruction)
2680  072D              l072dh:
2681  072D B6           	or (hl)		;072d	Set bit in A in (HL)
2682  072E
2683  072E 77           	ld (hl),a	;072e	Store result back to (HL)
2684  072F F7           	rst 30h		;072f	Continue with the next command (call BASIC_NEXT)
2685  0730
2686  0730              l0730h:
2687  0730 CD 8B 07     	call l078bh	;0730	Call LOCATE_VARIABLE_ERR
2688  0733
2689  0733 DF           	rst 18h		;0733	Call READ_PAR
2690  0734 3D           	db '='		;0734
2691  0735 59           	db l078fh-$-1	;0735	Else jump to WHAT_RST
2692  0736
2693  0736              l0736h:
2694  0736 E5           	push hl			;0736	e5
2695  0737 CD B2 0A     	call l0ab2h		;0737	cd b2 0a
2696  073A E1           	pop hl			;073a	e1
2697  073B
2698  073B              ; 'POP FLOATING POINT NUMBER FROM STACK'
2699  073B              ; ======================================
2700  073B              ; Fetches a floating point number from the top of the arithmetic stack and
2701  073B              ; stores it in 4-byte format at (HL).
2702  073B
2703  073B              ; IX Offset	0	1	2	3	4
2704  073B              ; ---------------------------------------------------
2705  073B              ;		24 bit mantissa	(MSB)	Exp	Sign
2706  073B
2707  073B              ; IX Offset	0        1        2	   3        4
2708  073B              ; -------------------------------------------------------------
2709  073B              ;		MMMMMMMM MMMMMMMM 1MMMMMMM EEEEEEEE S0000000
2710  073B              ;		(LSB)		  (MSB)
2711  073B
2712  073B              ; HL Offset	0        1        2	   3
2713  073B              ; --------------------------------------------------
2714  073B              ;		MMMMMMMM MMMMMMMM EMMMMMMM SEEEEEEE
2715  073B              ;		(LSB)		  (MSB)
2716  073B
2717  073B              ;; POP_FP
2718  073B              l073bh:
2719  073B CD 0E 09     	call l090eh	;073b	Call SUB_IX_5
2720  073E
2721  073E 01 04 00     	ld bc,0004h	;073e	Load 4 into BC
2722  0741 D5           	push de		;0741	Save HL and DE to stack
2723  0742 E5           	push hl		;0742
2724  0743
2725  0743 EB           	ex de,hl	;0743	Store HL to DE
2726  0744 DD E5        	push ix		;0744   Store IX to HL
2727  0746 E1           	pop hl		;0746
2728  0747
2729  0747 ED B0        	ldir		;0747	Transfer 4 bytes from (IX) to (HL)
2730  0749              			;	DE = DE_orig + 4
2731  0749
2732  0749 EB           	ex de,hl	;0749	Restore HL and DE
2733  074A
2734  074A 2B           	dec hl		;074a	HL = HL_orig + 2
2735  074B 2B           	dec hl		;074b
2736  074C CB 16        	rl (hl)		;074c	Rotate left (HL_orig + 2)
2737  074E
2738  074E 23           	inc hl		;074e	HL = HL_orig + 3
2739  074F DD 7E 04     	ld a,(ix+4)	;074f	Sign bit to Cf
2740  0752 17           	rla		;0752
2741  0753 CB 1E        	rr (hl)		;0753	Store sign bit to MSB of (HL_orig + 3)
2742  0755              			;	LSB of exponent to Cf.
2743  0755
2744  0755 2B           	dec hl		;0755	HL = HL_orig + 2
2745  0756 CB 1E        	rr (hl)		;0756	Store LSB of exponent in MSB of (HL_orig + 2)
2746  0758
2747  0758 E1           	pop hl		;0758	Restore HL and DE from stack
2748  0759 D1           	pop de		;0759
2749  075A C9           	ret		;075a	Return
2750  075B
2751  075B              ;; CATCH-ALL-COMMAND
2752  075B              l075bh:
2753  075B CD FC 05     	call l05fch		;075b	cd fc 05
2754  075E 38 08        	jr c,l0768h		;075e	38 08 	8
2755  0760 F5           	push af			;0760	f5
2756  0761 DF           	rst 18h			;0761	df
2757  0762 3D           	dec a			;0762	3d 	=
2758  0763 2B           	dec hl			;0763	2b 	+
2759  0764 F1           	pop af			;0764	f1
2760  0765 CD B2 05     	call l05b2h		;0765	cd b2 05
2761  0768              l0768h:
2762  0768 F7           	rst 30h			;0768	f7
2763  0769
2764  0769              ;; PTR
2765  0769              l0769h:
2766  0769 62           	ld h,d			;0769	62 	b
2767  076A 6B           	ld l,e			;076a	6b 	k
2768  076B CD FC 05     	call l05fch		;076b	cd fc 05
2769  076E 18 AC        	jr l071ch		;076e	18 ac
2770  0770              ;; VAL
2771  0770              l0770h:
2772  0770 D5           	push de			;0770	d5
2773  0771 EB           	ex de,hl			;0771	eb
2774  0772 CD B2 0A     	call l0ab2h		;0772	cd b2 0a
2775  0775 D1           	pop de			;0775	d1
2776  0776 C9           	ret			;0776	c9
2777  0777
2778  0777              ; 'BASIC NUMERIC EXPRESSION EVALUATION'
2779  0777              ; =====================================
2780  0777              ; This function is called if no other BASIC function matches. It evaluates a
2781  0777              ; numeric expression at DE.
2782  0777
2783  0777              ;; NUMBER
2784  0777              l0777h:
2785  0777 CD 25 01     	call l0125h	;0777	Call LOCATE_VARIABLE
2786  077A
2787  077A D2 45 0A     	jp nc,l0a45h	;077a	Store variable contents on stack and return
2788  077D              			;	(call PUSH_FP)
2789  077D
2790  077D              ; Not a variable
2791  077D
2792  077D CD A2 01     	call l01a2h	;077d	Call STRING_TO_FP
2793  0780 C0           	ret nz		;0780	Return if valid.
2794  0781
2795  0781              ; Not a constant
2796  0781
2797  0781              ; 'EVALUATE PARENTHESIS'
2798  0781              ; ======================
2799  0781              ; This function evaluates an expression enclosed in parenthesis at DE
2800  0781              ; and returns its value on the top of arithmetic stack.
2801  0781
2802  0781              ;; EVAL_PAREN
2803  0781              l0781h:
2804  0781 DF           	rst 18h		;0781	Call READ_PAR
2805  0782 28           	db '('		;0782
2806  0783 0B           	db l078fh-$-1	;0783	If '(' not found, jump to WHAT_RST
2807  0784
2808  0784 CD B2 0A     	call l0ab2h	;0784	Call EVAL_EXPRESSION
2809  0787
2810  0787 DF           	rst 18h		;0787	Call READ_PAR
2811  0788 29           	db ')'		;0788
2812  0789 01           	db l078bh-$-1	;0789
2813  078A
2814  078A              l078ah:
2815  078A C9           	ret		;078a	Return if closing ')' found
2816  078B
2817  078B              ; Closing ')' not found.
2818  078B
2819  078B              ; 'LOCATE VARIABLE OR ERROR'
2820  078B              ; ==========================
2821  078B              ; Like LOCATE_VARIABLE, but jumps to "WHAT?" error if variable is not found.
2822  078B
2823  078B              ;; LOCATE_VARIABLE_ERR
2824  078B              l078bh:
2825  078B CD 25 01     	call l0125h	;078b	Call LOCATE_VARIABLE
2826  078E
2827  078E D0           	ret nc		;078e	Return if variable found, else continue to
2828  078F              			;	WHAT_RST
2829  078F
2830  078F              ; '"WHAT?" ERROR RESTART'
2831  078F              ; =======================
2832  078F              ; This restart is called when an unknown function or command is called.
2833  078F
2834  078F              ;; WHAT_RST
2835  078F              l078fh:
2836  078F D5           	push de			;078f	Store current parser address on stack.
2837  0790
2838  0790 CD 99 07     	call l0799h		;0790	Store address of the "WHAT?" string
2839  0793              				;	on the stack and call BASIC_ERROR.
2840  0793
2841  0793 57 48 41 54  	dm "WHAT?", 00dh	;0793
2841  0797 3F 0D
2842  0799
2843  0799              ; 'BASIC ERROR'
2844  0799              ; =============
2845  0799              ; Pointer to the error message is the first 16 bit value on the CPU stack.
2846  0799              ; Current parser address is the second 16 bit value on the CPU stack.
2847  0799
2848  0799              ;; BASIC_ERROR
2849  0799              l0799h:
2850  0799 D1           	pop de		;0799	Load address of the error message into DE
2851  079A
2852  079A CD 37 09     	call l0937h	;079a	Call PRINTSTR
2853  079D
2854  079D ED 5B 9F 2A  	ld de,(02a9fh)	;079d	Load BASIC_LINE into DE
2855  07A1
2856  07A1 7B           	ld a,e		;07a1
2857  07A2 B2           	or d		;07a2	Set Z flag if BASIC_LINE is zero.
2858  07A3
2859  07A3 21 17 03     	ld hl,l0317h	;07a3	Load RESET_BASIC_2 address into
2860  07A6 E3           	ex (sp),hl	;07a6	the address at the top of the stack
2861  07A7              			;	and store stack value into HL.
2862  07A7
2863  07A7              			;	Top of the stack stores the current parser
2864  07A7              			;	address or return address of the calling
2865  07A7              			;	function.
2866  07A7
2867  07A7 C8           	ret z		;07a7	Return into RESET_BASIC_2 if BASIC_LINE = 0
2868  07A8
2869  07A8 D7           	rst 10h		;07a8	Call CMP_HL_DE
2870  07A9
2871  07A9 D8           	ret c		;07a9	Return into RESET_BASIC_2 if
2872  07AA              			;	BASIC_LINE > current parser address
2873  07AA
2874  07AA              			;	(stack did not contain a valid parser address)
2875  07AA
2876  07AA 4E           	ld c,(hl)	;07aa	Save character at current parser addr. into C
2877  07AB C5           	push bc		;07ab	Store BC on stack
2878  07AC
2879  07AC 36 00        	ld (hl),000h	;07ac	Store 00h (ASCII NUL) to current parser addr.
2880  07AE E5           	push hl		;07ae	Store HL on stack
2881  07AF
2882  07AF CD 31 09     	call l0931h	;07af	Call PRINT_BASIC_LINE
2883  07B2
2884  07B2 E1           	pop hl		;07b2	Restore BC and HL from stack.
2885  07B3 C1           	pop bc		;07b3
2886  07B4
2887  07B4 3E 3F        	ld a,03fh	;07b4	Load ASCII '?' into A
2888  07B6
2889  07B6
2890  07B6
2891  07B6              l07b6h:
2892  07B6 1B           	dec de		;07b6	DE = BASIC_LINE - 1
2893  07B7 71           	ld (hl),c	;07b7	Restore character at the current parser
2894  07B8              			;	address.
2895  07B8
2896  07B8 C3 36 09     	jp l0936h	;07b8	Jump to	PUTCH_PRINTSTR and return into
2897  07BB              			;	RESET_BASIC_2
2898  07BB
2899  07BB              ; 'GET STRING FROM KEYBOARD'
2900  07BB              ; ==========================
2901  07BB              ; This function reads a string from the keyboard into the input buffer. String
2902  07BB              ; is terminated with ASCII CR. Some minimal editing is supported ("LEFT" key
2903  07BB              ; acts as a backspace, "SHIFT-DELECT" clears the buffer and screen)
2904  07BB
2905  07BB              ; Returns:
2906  07BB              ;	DE: Address of the last character in the string + 1
2907  07BB
2908  07BB              ;; GETSTR
2909  07BB              l07bbh:
2910  07BB 3E 3E        	ld a,'>'	;07bb	Load prompt into A
2911  07BD
2912  07BD              l07bdh:
2913  07BD 11 B6 2B     	ld de,02bb6h	;07bd	Load INPUT_BUFFER address into DE
2914  07C0 E7           	rst 20h		;07c0 	Display prompt.
2915  07C1
2916  07C1              ;; GETSTR_LOOP_CURS
2917  07C1              l07c1h:
2918  07C1 D9           	exx		;07c1
2919  07C2 36 5F        	ld (hl),'_'	;07c2	Print cursor at location (HL')
2920  07C4 D9           	exx		;07c4	Note: HL' is set by PUTCH_RST.
2921  07C5
2922  07C5              ;; GETSTR_LOOP
2923  07C5              l07c5h:
2924  07C5 CD F5 0C     	call l0cf5h	;07c5	Read a key and print it (call KEY)
2925  07C8 E7           	rst 20h		;07c8	(call PUTCH_RST)
2926  07C9
2927  07C9 D9           	exx		;07c9
2928  07CA 36 5F        	ld (hl),'_'	;07ca	Print cursor
2929  07CC D9           	exx		;07cc
2930  07CD
2931  07CD FE 0D        	cp 00dh		;07cd
2932  07CF 28 0C        	jr z,l07ddh	;07cf	"ENTER" pressed, jump to GETSTR_ADD
2933  07D1
2934  07D1 FE 1D        	cp 01dh		;07d1
2935  07D3 28 15        	jr z,l07eah	;07d3	"LEFT" pressed, jump to GETSTR_BACKSPACE
2936  07D5
2937  07D5 FE 0C        	cp 00ch		;07d5
2938  07D7 28 E2        	jr z,l07bbh	;07d7	"SHIFT-DELETE" pressed - begin from the start
2939  07D9
2940  07D9 FE 20        	cp 020h		;07d9
2941  07DB 38 E8        	jr c,l07c5h	;07db	Ignore if key code is less than 20h otherwise
2942  07DD
2943  07DD              ;; GETSTR_ADD
2944  07DD              l07ddh:
2945  07DD 12           	ld (de),a	;07dd	Load ASCII code of the pressed key into the
2946  07DE 13           	inc de		;07de	buffer and increment DE
2947  07DF
2948  07DF FE 0D        	cp 00dh		;07df	If "ENTER" was pressed, return.
2949  07E1 C8           	ret z		;07e1
2950  07E2
2951  07E2 7B           	ld a,e		;07e2	Compare DE with 2c36h (end of buffer)
2952  07E3 FE 34        	cp 034h		;07e3
2953  07E5
2954  07E5 20 DE        	jr nz,l07c5h	;07e5	If end of buffer not reached,
2955  07E7              			;	loop to GETSTR_LOOP...
2956  07E7
2957  07E7 3E 1D        	ld a,01dh	;07e7	...else delete last pressed character from the
2958  07E9 E7           	rst 20h		;07e9	   screen and buffer.
2959  07EA
2960  07EA              ;; GETSTR_BACKSPACE
2961  07EA              l07eah:
2962  07EA 7B           	ld a,e		;07ea	Compare DE with 2bb6h (start of buffer)
2963  07EB FE B6        	cp 0b6h		;07eb
2964  07ED 28 CC        	jr z,l07bbh	;07ed	If not at start of buffer decrement DE
2965  07EF 1B           	dec de		;07ef
2966  07F0 18 CF        	jr l07c1h	;07f0	Jump to GETSTR_LOOP_CURS
2967  07F2
2968  07F2              ; 'FIND BASIC LINE'
2969  07F2              ; =================
2970  07F2              ; Finds BASIC line with line number equal or greater than HL in the entire
2971  07F2              ; BASIC code.
2972  07F2
2973  07F2              ;; FIND_LINE
2974  07F2              l07f2h:
2975  07F2 ED 5B 36 2C  	ld de,(02c36h)	;07f2	Load BASIC_START into DE and continue with
2976  07F6              			;	FIND_LINE_SCOPE
2977  07F6
2978  07F6              ; 'FIND BASIC LINE IN SCOPE'
2979  07F6              ; ==========================
2980  07F6              ; Finds BASIC line with line number equal or greater than HL, starting at DE.
2981  07F6              ; If line number was not found after DE, Cf is set.
2982  07F6
2983  07F6              ; Parameters:
2984  07F6              ;	DE: Pointer to the start of a BASIC line where the search starts.
2985  07F6              ;	HL: Line number to find.
2986  07F6              ; Returns:
2987  07F6              ;	DE: Pointer to the start of the BASIC line if a matching line number
2988  07F6              ;           is found
2989  07F6              ;	Cf: Set if line number was not found.
2990  07F6              ;	Zf: Set if line number found is equal to HL.
2991  07F6
2992  07F6              ;; FIND_LINE_SCOPE
2993  07F6              l07f6h:
2994  07F6 E5           	push hl		;07f6	Save HL on stack
2995  07F7
2996  07F7              ; Check if DE is within the expected margins of the BASIC program.
2997  07F7
2998  07F7 2A 36 2C     	ld hl,(02c36h)	;07f7	Load BASIC_START-1 into HL
2999  07FA 2B           	dec hl		;07fa
3000  07FB
3001  07FB D7           	rst 10h		;07fb	(call CMP_HL_DE)
3002  07FC D2 17 03     	jp nc,l0317h	;07fc	Jump to RESET_BASIC_2 if DE < BASIC_START
3003  07FF
3004  07FF 2A 38 2C     	ld hl,(02c38h)	;07ff	Load BASIC_END-1 into HL
3005  0802 2B           	dec hl		;0802
3006  0803
3007  0803 D7           	rst 10h		;0803	(call CMP_HL_DE)
3008  0804
3009  0804 E1           	pop hl		;0804	Restore HL
3010  0805
3011  0805 D8           	ret c		;0805	Return if DE >= BASIC_END
3012  0806
3013  0806 1A           	ld a,(de)	;0806	Subtract HL from 16-bit line number at (DE)
3014  0807 95           	sub l		;0807
3015  0808 47           	ld b,a		;0808
3016  0809 13           	inc de		;0809
3017  080A 1A           	ld a,(de)	;080a
3018  080B 9C           	sbc a,h		;080b	BA = (DE)-HL
3019  080C
3020  080C              l080ch:
3021  080C 38 04        	jr c,l0812h	;080c	Jump to FIND_LINE_NEXT if HL > line number
3022  080E
3023  080E 1B           	dec de		;080e	Decrement DE
3024  080F
3025  080F B0           	or b		;080f	Check if HL is equal to line number at (DE)
3026  0810
3027  0810 C9           	ret		;0810	Return
3028  0811
3029  0811              l0811h:
3030  0811 13           	inc de		;0811	Increment DE
3031  0812
3032  0812              ; Increments DE until start of the next BASIC line.
3033  0812
3034  0812              ;; FIND_LINE_NEXT
3035  0812              l0812h:
3036  0812 13           	inc de		;0812	Increment DE (points to first character after
3037  0813              			;	line number)
3038  0813
3039  0813              ; 'FIND NEXT BASIC LINE'
3040  0813              ; ========================
3041  0813              ; A call to this location moves DE to the start of the next BASIC line if
3042  0813              ; HL contains 0000h.
3043  0813
3044  0813              ;; FIND_LINE_NEXT_2
3045  0813              l0813h:
3046  0813 1A           	ld a,(de)	;0813	Load character into A
3047  0814
3048  0814 FE 0D        	cp 00dh		;0814
3049  0816 20 FA        	jr nz,l0812h	;0816	Loop until equal to CR
3050  0818
3051  0818              l0818h:
3052  0818 13           	inc de		;0818	Increment DE (points to line number of the next
3053  0819              			;	line)
3054  0819
3055  0819 18 DB        	jr l07f6h	;0819	Loop
3056  081B
3057  081B              ;; FIXME: catch all
3058  081B              l081bh:
3059  081B 13           	inc de			;081b	13
3060  081C              l081ch:
3061  081C 1A           	ld a,(de)			;081c	1a
3062  081D EF           	rst 28h			;081d	ef
3063  081E FE 0D        	cp 00dh		;081e	fe 0d
3064  0820 28 F6        	jr z,l0818h		;0820	28 f6 	(
3065  0822 FE 21        	cp 021h		;0822	fe 21 	  !
3066  0824 28 EC        	jr z,l0812h		;0824	28 ec 	(
3067  0826 FE 22        	cp 022h		;0826	fe 22 	  "
3068  0828 20 0A        	jr nz,l0834h		;0828	20 0a
3069  082A              l082ah:
3070  082A 13           	inc de			;082a	13
3071  082B 1A           	ld a,(de)			;082b	1a
3072  082C FE 0D        	cp 00dh		;082c	fe 0d
3073  082E 28 E8        	jr z,l0818h		;082e	28 e8 	(
3074  0830 FE 22        	cp 022h		;0830	fe 22 	  "
3075  0832 20 F6        	jr nz,l082ah		;0832	20 f6
3076  0834              l0834h:
3077  0834 FE 45        	cp 045h		;0834	fe 45 	  E
3078  0836 20 E3        	jr nz,l081bh		;0836	20 e3
3079  0838 2E F6        	ld l,0f6h		;0838	2e f6 	.
3080  083A C3 98 03     	jp l0398h		;083a	c3 98 03
3081  083D
3082  083D              ; 'PRINT A FLOATING POINT NUMBER (cont.)'
3083  083D              ; =======================================
3084  083D              ; Prints a floating point number on the top of the arithmetic stack at the
3085  083D              ; current cursor position. Number must not be zero.
3086  083D
3087  083D              ; IX Offset	-5	-4	-3	-2	-1
3088  083D              ; ---------------------------------------------------
3089  083D              ;		24 bit mantissa	(MSB)	Exp	Sign
3090  083D
3091  083D              ;; PRINTFP_DO
3092  083D
3093  083D
3094  083D              ; First print the sign character and make the floating point number positive.
3095  083D
3096  083D              l083dh:
3097  083D DD 7E FF     	ld a,(ix-1)	;083d	Load sign bit into A
3098  0840 A7           	and a		;0840
3099  0841 3E 20        	ld a,' '	;0841	If sign is positive, store ASCII ' ' in A
3100  0843              			;	else store ASCII '-'.
3101  0843 28 02        	jr z,l0847h	;0843
3102  0845 3E 2D        	ld a,'-'	;0845
3103  0847              l0847h:
3104  0847
3105  0847 E7           	rst 20h		;0847	Print sign character (call PUTCH_RST)
3106  0848
3107  0848 AF           	xor a		;0848
3108  0849 DD 77 FF     	ld (ix-1),a	;0849	Clear sign bit.
3109  084C
3110  084C 3D           	dec a		;084c	A = -1
3111  084D
3112  084D              ; Convert the number into floating point format with base of exponent 10.
3113  084D
3114  084D              ;; PRINTFP_MUL10_LOOP
3115  084D              l084dh:
3116  084D F5           	push af		;084d	Store AF to stack
3117  084E
3118  084E 21 2C 00     	ld hl,l002ch	;084e	Load FP_ONE_OVER_TEN address into HL
3119  0851
3120  0851 CD 05 0B     	call l0b05h	;0851	Call FP_COMPARE_HL
3121  0854
3122  0854 30 0D        	jr nc,l0863h	;0854	If number printed is greater or equal to 0.1,
3123  0856              			;	jump to next step.
3124  0856
3125  0856 CD E3 0A     	call l0ae3h	;0856	Multiply number by 10 (call FP_MUL_10)
3126  0859
3127  0859 F1           	pop af		;0859	Restore AF from stack
3128  085A
3129  085A 3D           	dec a		;085a	Decrement A
3130  085B
3131  085B 18 F0        	jr l084dh	;085b	Jump to PRINTFP_MUL10_LOOP
3132  085D
3133  085D              ;; PRINTFP_DIV10_LOOP
3134  085D              l085dh:
3135  085D CD F4 0A     	call l0af4h	;085d	Divide number by 10 (call FP_DIV_10)
3136  0860 F1           	pop af		;0860	Restore AF from stack
3137  0861 3C           	inc a		;0861	Increment A
3138  0862 F5           	push af		;0862	Save AF to stack
3139  0863
3140  0863              l0863h:
3141  0863 21 A0 00     	ld hl,l00a0h	;0863	Load FP_ONE address into HL
3142  0866 CD 05 0B     	call l0b05h	;0866	Call FP_COMPARE_HL
3143  0869
3144  0869 30 F2        	jr nc,l085dh	;0869	If number is greater or equal to 1,
3145  086B              			;	jump to PRINTFP_DIV10_LOOP
3146  086B
3147  086B              ; M = abs( N * 10^(-1 - A) )
3148  086B
3149  086B              ; 1 > M >= 0.1
3150  086B
3151  086B              ; where N is the original number, and M is the number in HL' C' HL and at the
3152  086B              ; top of the arithmetic stack. A is stored at the top of the arithmetic stack.
3153  086B
3154  086B DD 7E FE     	ld a,(ix-2)	;086b	Load negative exponent (base 2) into A
3155  086E ED 44        	neg		;086e
3156  0870
3157  0870              ; Apply base 2 exponent to the number's mantissa
3158  0870
3159  0870              ;; PRINTFP_APPLY_EXP2
3160  0870              l0870h:
3161  0870 28 0B        	jr z,l087dh	;0870	Break from loop if exponent is zero.
3162  0872 D9           	exx		;0872
3163  0873 CB 39        	srl c		;0873	Shift mantissa right (divide by 2)
3164  0875 CB 1C        	rr h		;0875
3165  0877 CB 1D        	rr l		;0877
3166  0879 D9           	exx		;0879
3167  087A 3D           	dec a		;087a	Decrement exponent
3168  087B 18 F3        	jr l0870h	;087b	Loop to PRINTFP_APPLY_EXP2
3169  087D
3170  087D
3171  087D              ; M = O * 2^(-24)
3172  087D
3173  087D              ; where O is the number in HL' C'
3174  087D
3175  087D              ; Build 8 digit binary-coded decimal at the top of the arithmetic stack
3176  087D
3177  087D              l087dh:
3178  087D 06 07        	ld b,7		;087d	B = 7
3179  087F DD E5        	push ix		;087f	HL = IX (top of arithmetic stack)
3180  0881 E1           	pop hl		;0881
3181  0882 36 00        	ld (hl),000h	;0882	Load 0 into first BCD digit.
3182  0884 23           	inc hl		;0884	Increment HL
3183  0885
3184  0885              ; This loop multiplies O by 10 in each iteration and stores the part of O
3185  0885              ; that is before decimal point into (HL)
3186  0885
3187  0885              ;; PRINTFP_BCD_LOOP
3188  0885              l0885h:
3189  0885
3190  0885 AF           	xor a		;0885	Clear A
3191  0886 CD 4F 02     	call l024fh	;0886	Call FP_MUL_10_ADD_A
3192  0889
3193  0889 D9           	exx		;0889
3194  088A 78           	ld a,b		;088a
3195  088B D9           	exx		;088b
3196  088C 77           	ld (hl),a	;088c	Load B' (mantissa overflow) into HL
3197  088D 23           	inc hl		;088d	Increment HL
3198  088E
3199  088E 10 F5        	djnz l0885h	;088e	Loop 7 times to PRINTFP_BCD_LOOP
3200  0890
3201  0890              ; HL	-8	-7	-6	-5	-4	-3	-2	-1
3202  0890              ; -------------------------------------------------------------------
3203  0890              ;	0	X	X	X	X	X	X	Y
3204  0890
3205  0890              ;	<-- most significant                least significant -->
3206  0890
3207  0890              ; P = M * 10^7 = abs( N * 10^(6 - A) )
3208  0890
3209  0890              ; Round the lowest X digit up, if Y digit >= 5.
3210  0890
3211  0890 01 00 06     	ld bc,l0600h	;0890	B = 6
3212  0893              			;	C = 0
3213  0893
3214  0893 2B           	dec hl		;0893	Decrement HL
3215  0894 7E           	ld a,(hl)	;0894
3216  0895 FE 05        	cp 5		;0895	Compare last digit with 5
3217  0897
3218  0897              ; Propagate carry and also set the bitmap in C
3219  0897
3220  0897              ;; PRINTFP_ROUND_LOOP
3221  0897              l0897h:
3222  0897 3F           	ccf		;0897	Cf set if >=5, reset if <5
3223  0898              			;	Cf set if carry from the previous decimal digit.
3224  0898
3225  0898 3E 00        	ld a,0		;0898	Add 1 to the digit one place higher if Cf set.
3226  089A 2B           	dec hl		;089a
3227  089B 8E           	adc a,(hl)	;089b
3228  089C CB 21        	sla c		;089c	Shift C left
3229  089E FE 0A        	cp 10		;089e	Compare corrected digit with 10
3230  08A0
3231  08A0 38 02        	jr c,l08a4h	;08a0
3232  08A2 3E 00        	ld a,000h	;08a2	Load 0 into A if greater or equal to 10
3233  08A4              l08a4h:
3234  08A4
3235  08A4 77           	ld (hl),a	;08a4	Load corrected digit into (HL)
3236  08A5 F5           	push af		;08a5	Save Cf on stack
3237  08A6
3238  08A6 A7           	and a		;08a6
3239  08A7 28 02        	jr z,l08abh	;08a7	If digit not zero, set bit 0 of C.
3240  08A9 CB C1        	set 0,c		;08a9
3241  08AB              l08abh:
3242  08AB F1           	pop af		;08ab	Restore Cf from stack
3243  08AC 10 E9        	djnz l0897h	;08ac	Loop 6 times to PRINTFP_ROUND_LOOP
3244  08AE
3245  08AE 79           	ld a,c		;08ae	Load bitmask into A
3246  08AF
3247  08AF C1           	pop bc		;08af	Restore exponent from stack into B
3248  08B0 38 06        	jr c,l08b8h	;08b0	If no carry on the most significant digit,
3249  08B2              			;	break from loop...
3250  08B2 04           	inc b		;08b2   ...else increment base 10 exponent
3251  08B3 C5           	push bc		;08b3	   Save exponent back to stack
3252  08B4
3253  08B4 06 01        	ld b,001h	;08b4
3254  08B6 18 DF        	jr l0897h	;08b6      loop one more time to PRINTFP_ROUND_LOOP
3255  08B8
3256  08B8              ; P = abs( N * 10^(6 - A) )
3257  08B8
3258  08B8              l08b8h:
3259  08B8 4F           	ld c,a		;08b8	Move bitmask back to C
3260  08B9 78           	ld a,b		;08b9	Move exponent back to A
3261  08BA
3262  08BA 3C           	inc a		;08ba	Jump to PRINTFP_EXP if A not between 0 and 6
3263  08BB FA C8 08     	jp m,l08c8h	;08bb
3264  08BE FE 07        	cp 7		;08be
3265  08C0 30 06        	jr nc,l08c8h	;08c0
3266  08C2
3267  08C2              ; No exponential notation necessary. Just print the mantissa and exit.
3268  08C2
3269  08C2 47           	ld b,a		;08c2	Exponent to B
3270  08C3 CD 1C 09     	call l091ch	;08c3	Call PRINT_BCD
3271  08C6
3272  08C6 18 43        	jr l090bh	;08c6	Finish (remove stored values from stack, and
3273  08C8              			;	return)
3274  08C8
3275  08C8              ; Number either too large or too small. Print in exponential notation.
3276  08C8
3277  08C8              ;; PRINTFP_EXP
3278  08C8              l08c8h:
3279  08C8 C5           	push bc		;08c8	Save exponent and bitmask to stack
3280  08C9
3281  08C9 06 01        	ld b,001h	;08c9	Print mantissa
3282  08CB CD 1C 09     	call l091ch	;08cb	(call PRINT_BCD)
3283  08CE
3284  08CE 3E 45        	ld a,'E'	;08ce	Print exponent character 'E'
3285  08D0 E7           	rst 20h		;08d0
3286  08D1
3287  08D1              ; Convert exponent into decimal and print it.
3288  08D1
3289  08D1 C1           	pop bc		;08d1	Restore BC from stack
3290  08D2
3291  08D2 CB 78        	bit 7,b		;08d2	Check sign bit of the exponent
3292  08D4
3293  08D4 3E 2B        	ld a,'+'	;08d4
3294  08D6 28 08        	jr z,l08e0h	;08d6	If exponent positive, jump to PRINTFP_EXP_POS
3295  08D8
3296  08D8              ; Exponent base 10 is negative
3297  08D8
3298  08D8 3E 2D        	ld a,'-'	;08d8	Print minus sign
3299  08DA E7           	rst 20h		;08da	(call PUTCH_RST)
3300  08DB
3301  08DB 78           	ld a,b		;08db	Load negative exponent base 10 into A
3302  08DC ED 44        	neg		;08dc
3303  08DE 18 02        	jr l08e2h	;08de	Jump to PRINTFP_EXP_ABS
3304  08E0
3305  08E0              ;; PRINTFP_EXP_POS
3306  08E0              l08e0h:
3307  08E0 E7           	rst 20h		;08e0	Print plus sign (call PUTCH_RST)
3308  08E1 78           	ld a,b		;08e1	Load exponent base 10 into A
3309  08E2
3310  08E2              ; Absolute value of exponent base 10 in A. Now split exponent into two decimal
3311  08E2              ; digits: B contains tens (+ ASCII offset), A contains ones.
3312  08E2
3313  08E2              ;; PRINTFP_EXP_ABS
3314  08E2              l08e2h:
3315  08E2 06 30        	ld b,'0'	;08e2	Initialize B
3316  08E4              l08e4h:
3317  08E4 FE 0A        	cp 10		;08e4
3318  08E6 38 1C        	jr c,l0904h	;08e6	Jump to PRINTFP_END if number of ones is less
3319  08E8              			;	than 10.
3320  08E8
3321  08E8 C6 F6        	add a,-10	;08e8	Subtract 10 from number of ones and add 1 to
3322  08EA 04           	inc b		;08ea 	the number of tens.
3323  08EB
3324  08EB 18 F7        	jr l08e4h	;08eb	Loop
3325  08ED
3326  08ED              ; 'PRINT A 16 BIT NUMBER'
3327  08ED              ; =======================
3328  08ED              ; Prints a 16 bit number at DE to the screen at current cursor position.
3329  08ED
3330  08ED              ; Parameters:
3331  08ED              ;	DE: Pointer to the 16 bit number to print.
3332  08ED              ; Returns:
3333  08ED              ;	DE: DE + 2
3334  08ED
3335  08ED              ;; PRINT_WORD
3336  08ED              l08edh:
3337  08ED 1A           	ld a,(de)	;08ed	Load BASIC line number (at DE) into HL and
3338  08EE 6F           	ld l,a		;08ee	DE = DE + 2
3339  08EF 13           	inc de		;08ef
3340  08F0 1A           	ld a,(de)	;08f0
3341  08F1 67           	ld h,a		;08f1
3342  08F2 13           	inc de		;08f2
3343  08F3
3344  08F3 CD BC 0A     	call l0abch	;08f3	Push line number to arithmetic stack
3345  08F6              			;	(Call INT_TO_FP)
3346  08F6
3347  08F6              ; 'PRINT A FLOATING POINT NUMBER'
3348  08F6              ; ===============================
3349  08F6              ; Prints a floating point number on the top of the arithmetic stack at the
3350  08F6              ; current cursor position.
3351  08F6
3352  08F6              ; IX Offset	-5	-4	-3	-2	-1
3353  08F6              ; ---------------------------------------------------
3354  08F6              ;		24 bit mantissa	(MSB)	Exp	Sign
3355  08F6
3356  08F6              ;; PRINTFP
3357  08F6              l08f6h:
3358  08F6 D5           	push de		;08f6	Save BC,DE and HL to stack
3359  08F7 C5           	push bc		;08f7
3360  08F8 E5           	push hl		;08f8
3361  08F9
3362  08F9 DD 7E FE     	ld a,(ix-2)	;08f9
3363  08FC FE 80        	cp 080h		;08fc
3364  08FE C2 3D 08     	jp nz,l083dh	;08fe	Jump to PRINTFP_DO if line number is not 0
3365  0901
3366  0901 AF           	xor a		;0901	Clear A
3367  0902 06 20        	ld b,020h	;0902	Load ASCII ' ' into B
3368  0904
3369  0904              ;; PRINTFP_END
3370  0904              l0904h:
3371  0904 F6 30        	or 030h		;0904	Convert integer in A to ASCII numeral
3372  0906 4F           	ld c,a		;0906	and store it into C
3373  0907
3374  0907 78           	ld a,b		;0907	Print character in B
3375  0908 E7           	rst 20h		;0908	(Call PUTCH_RST)
3376  0909 79           	ld a,c		;0909	Print character in C
3377  090A E7           	rst 20h		;090a	(Call PUTCH_RST)
3378  090B
3379  090B              l090bh:
3380  090B E1           	pop hl		;090b	Restore HL and BC from stack
3381  090C C1           	pop bc		;090c
3382  090D
3383  090D              ; 'STORE ARITHMETIC RESULT & RETURN (cont.)'
3384  090D              ; ==========================================
3385  090D              ; Restores DE register from CPU stack, removes the top value from the
3386  090D              ; arithmetic stack and returns.
3387  090D
3388  090D              ;; STORE_ARITHM_RET_2
3389  090D              l090dh:
3390  090D D1           	pop de		;090d
3391  090E
3392  090E              ; 'SUB IX,5'
3393  090E              ; ==========
3394  090E              ; Subtracts 5 from the contents of the IX register. Stores -5 in BC.
3395  090E
3396  090E              ;; SUB_IX_5
3397  090E              l090eh:
3398  090E 01 FB FF     	ld bc,0fffbh	;090e	Load -5 into BC
3399  0911
3400  0911              ; ADD_IX_10 jumps here
3401  0911              l0911h:
3402  0911 DD 09        	add ix,bc	;0911	Add BC to IX
3403  0913 C9           	ret		;0913	Return
3404  0914
3405  0914              ; 'CORRECT EXPONENT & ADD IX,10'
3406  0914              ; ==============================
3407  0914              ; Corrects exponent of FP number in HL C' HL' and adds 10 to IX (
3408  0914
3409  0914              ;; CORRECT_EXP_ADD_IX_10
3410  0914              l0914h:
3411  0914 CD 4C 0C     	call l0c4ch	;0914	Call CORRECT_EXP
3412  0917
3413  0917              ; 'ADD IX,10'
3414  0917              ; ===========
3415  0917              ; Adds 10 to the contents of the IX register. Stores 10 in BC.
3416  0917
3417  0917              ;; ADD_IX_10
3418  0917              l0917h:
3419  0917 01 0A 00     	ld bc,0000ah	;0917	Load 10 into BC
3420  091A 18 F5        	jr l0911h	;091a	Jump forward
3421  091C
3422  091C              ; 'PRINT A BINARY-CODED DECIMAL NUMBER'
3423  091C              ; =====================================
3424  091C              ; Prints a BCD number at HL. Each byte represents one digit. B holds the number
3425  091C              ; of digits before decimal point.
3426  091C
3427  091C              ; Parameters:
3428  091C              ;	HL: Pointer to the BCD number.
3429  091C              ;	B: Location of the decimal point (after B digits)
3430  091C              ;	C: Bitmap of the digits (0 means zero digit, 1 means non-zero digit)
3431  091C
3432  091C              ; BCD digit	HL+7	HL+6	HL+5	HL+4	HL+3	HL+2	HL+1	HL
3433  091C              ; C bit		7	6	5	4	3	2	1	0
3434  091C
3435  091C              ;; PRINT_BCD
3436  091C              l091ch:
3437  091C 04           	inc b		;091c
3438  091D
3439  091D              ;; PRINT_BCD_LOOP
3440  091D              l091dh:
3441  091D 10 03        	djnz l0922h	;091d	Decrement B.
3442  091F
3443  091F 3E 2E        	ld a,'.'	;091f	Print decimal point if B == 0
3444  0921 E7           	rst 20h		;0921	(call PUTCH_RST)
3445  0922              l0922h:
3446  0922
3447  0922 7E           	ld a,(hl)	;0922	Print BCD digit in (HL)
3448  0923 F6 30        	or 030h		;0923
3449  0925 E7           	rst 20h		;0925	(call PUTCH_RST)
3450  0926
3451  0926 23           	inc hl		;0926	Move HL to the next digit.
3452  0927
3453  0927 CB 39        	srl c		;0927	Shift C right and...
3454  0929 20 F2        	jr nz,l091dh	;0929	...loop to PRINT_BCD_LOOP if there are further
3455  092B              			;	   non-zero digits
3456  092B
3457  092B              ; There are only zeroes left. Note: B remains unmodified.
3458  092B
3459  092B 05           	dec b		;092b
3460  092C 05           	dec b		;092c
3461  092D F8           	ret m		;092d	Return if B <= 1
3462  092E 04           	inc b		;092e
3463  092F
3464  092F 18 EB        	jr l091ch	;092f	Restart to PRINT_BCD.
3465  0931
3466  0931              ; 'PRINT A BASIC LINE TO SCREEN'
3467  0931              ; ==============================
3468  0931              ; Print a complete BASIC line to screen. First the line number is printed,
3469  0931              ; followed by ASCII space and line contents.
3470  0931
3471  0931              ; Parameters:
3472  0931              ;	DE: Pointer to the BASIC line.
3473  0931
3474  0931              ;; PRINT_BASIC_LINE
3475  0931              l0931h:
3476  0931 CD ED 08     	call l08edh	;0931	Print line number (call PRINT_WORD)
3477  0934 3E 20        	ld a,020h	;0934	Load ASCII ' ' into A
3478  0936
3479  0936              ; 'PRINT A CHARACTER FOLLOWED BY A STRING TO SCREEN'
3480  0936              ; ==================================================
3481  0936              ; Call PUTCH_RST and PRINTSTR
3482  0936
3483  0936              ;; PUTCH_PRINTSTR
3484  0936              l0936h:
3485  0936 E7           	rst 20h		;0936	Call PUTCH_RST
3486  0937
3487  0937              ; 'PRINT A STRING TO SCREEN'
3488  0937              ; ==========================
3489  0937              ; Print a string of characters at (DE) to the screen at the current cursor
3490  0937              ; position (CURSOR_POS).
3491  0937
3492  0937              ; String must be terminated with 00h (NUL) or 0d (CR). In the second case a
3493  0937              ; new line added at the end of the string.
3494  0937
3495  0937              ; Parameters:
3496  0937              ;	DE: Address of the first character in the string.
3497  0937              ; Returns:
3498  0937              ;	Zf: Set if string ended with NUL, reset if it ended with CR.
3499  0937              ;	HL': Address of the last printed character on screen + 1
3500  0937              ;	DE: Address of the last read character + 1
3501  0937              ; Destroys:
3502  0937              ;	A,B,flags
3503  0937
3504  0937              ;; PRINTSTR
3505  0937              l0937h:
3506  0937 AF           	xor a		;0937	A = ASCII NUL
3507  0938
3508  0938              ; 'PRINT A STRING TO SCREEN ENDING ON A'
3509  0938              ; ======================================
3510  0938              ; Like PRINTSTR, except string is terminated with character in A (which is not
3511  0938              ; printed) or CR (which is printed).
3512  0938
3513  0938              ; Returns:
3514  0938              ;	Zf: Set if string ended with character in A, reset if it ended with CR.
3515  0938
3516  0938              ;; PRINTSTR_A
3517  0938              l0938h:
3518  0938 47           	ld b,a		;0938	Load A into B
3519  0939
3520  0939              l0939h:
3521  0939 1A           	ld a,(de)	;0939	Load character pointed by DE into A
3522  093A 13           	inc de		;093a	Increment DE
3523  093B
3524  093B B8           	cp b		;093b	Compare A with B...
3525  093C C8           	ret z		;093c	...and return if equal
3526  093D
3527  093D E7           	rst 20h		;093d	Call PUTCH_RST
3528  093E
3529  093E FE 0D        	cp 00dh		;093e	Compare A with 0dh (CR)...
3530  0940 20 F7        	jr nz,l0939h	;0940	...and loop if not equal
3531  0942
3532  0942 3C           	inc a		;0942	Increment A
3533  0943 C9           	ret		;0943	Return.
3534  0944
3535  0944              ; 'MOVE MEMORY BLOCK'
3536  0944              ; ===================
3537  0944              ;
3538  0944              ; -------------     -------------
3539  0944              ; |source     |     |destination|
3540  0944              ; -------------     -------------
3541  0944              ; ^            ^    ^
3542  0944              ; |            |    |
3543  0944              ; DE           HL   BC
3544  0944
3545  0944              ;; MOVE_MEM
3546  0944              l0944h:
3547  0944 D7           	rst 10h		;0944	Call CMP_HL_DE
3548  0945 C8           	ret z		;0945	Return if HL == DE
3549  0946
3550  0946 1A           	ld a,(de)	;0946	(BC) = (DE)
3551  0947 02           	ld (bc),a	;0947
3552  0948
3553  0948 13           	inc de		;0948	Increment BC and DE
3554  0949 03           	inc bc		;0949
3555  094A
3556  094A 18 F8        	jr l0944h	;094a	Loop
3557  094C
3558  094C              l094ch:
3559  094C 78           	ld a,b			;094c	78 	x
3560  094D 92           	sub d			;094d	92
3561  094E 20 03        	jr nz,l0953h		;094e	20 03
3562  0950 79           	ld a,c			;0950	79 	y
3563  0951 93           	sub e			;0951	93
3564  0952 C8           	ret z			;0952	c8
3565  0953              l0953h:
3566  0953 1B           	dec de			;0953	1b
3567  0954 2B           	dec hl			;0954	2b 	+
3568  0955 1A           	ld a,(de)			;0955	1a
3569  0956 77           	ld (hl),a			;0956	77 	w
3570  0957 18 F3        	jr l094ch		;0957	18 f3
3571  0959              l0959h:
3572  0959 C1           	pop bc			;0959	c1
3573  095A E1           	pop hl			;095a	e1
3574  095B 22 A1 2A     	ld (02aa1h),hl		;095b	22 a1 2a 	"   *
3575  095E 7C           	ld a,h			;095e	7c 	|
3576  095F B5           	or l			;095f	b5
3577  0960 28 10        	jr z,l0972h		;0960	28 10 	(
3578  0962 E1           	pop hl			;0962	e1
3579  0963 22 91 2A     	ld (02a91h),hl		;0963	22 91 2a 	"   *
3580  0966 E1           	pop hl			;0966	e1
3581  0967 22 6E 2A     	ld (02a6eh),hl		;0967	22 6e 2a 	" n *
3582  096A E1           	pop hl			;096a	e1
3583  096B 22 93 2A     	ld (02a93h),hl		;096b	22 93 2a 	"   *
3584  096E E1           	pop hl			;096e	e1
3585  096F 22 95 2A     	ld (02a95h),hl		;096f	22 95 2a 	"   *
3586  0972              l0972h:
3587  0972 C5           	push bc			;0972	c5
3588  0973 C9           	ret			;0973	c9
3589  0974
3590  0974              l0974h:
3591  0974 21 C8 D4     	ld hl,-02b38h	;0974
3592  0977 C1           	pop bc		;0977	Remove BC from stack
3593  0978 39           	add hl,sp	;0978
3594  0979 D2 53 01     	jp nc,l0153h	;0979	Jump to SORRY_RST_PUSH_DE if SP < 2b38h
3595  097C
3596  097C 2A A1 2A     	ld hl,(02aa1h)	;097c	2a a1 2a 	*   *
3597  097F 7C           	ld a,h		;097f	7c 	|
3598  0980 B5           	or l		;0980	b5
3599  0981 28 13        	jr z,l0996h	;0981	28 13 	(
3600  0983
3601  0983 2A 95 2A     	ld hl,(02a95h)		;0983	2a 95 2a 	*   *
3602  0986 E5           	push hl			;0986	e5
3603  0987 2A 93 2A     	ld hl,(02a93h)		;0987	2a 93 2a 	*   *
3604  098A E5           	push hl			;098a	e5
3605  098B 2A 6E 2A     	ld hl,(02a6eh)		;098b	2a 6e 2a 	* n *
3606  098E E5           	push hl			;098e	e5
3607  098F 2A 91 2A     	ld hl,(02a91h)		;098f	2a 91 2a 	*   *
3608  0992 E5           	push hl			;0992	e5
3609  0993 2A A1 2A     	ld hl,(02aa1h)		;0993	2a a1 2a 	*   *
3610  0996
3611  0996              l0996h:
3612  0996 E5           	push hl			;0996	e5
3613  0997 C5           	push bc			;0997	c5
3614  0998 C9           	ret			;0998	c9
3615  0999
3616  0999              ; 'EVALUATE RELATIONAL OPERATORS'
3617  0999              ; ===============================
3618  0999              ; Evaluates a relational operator at DE and returns HL = 1 if true or HL = 0
3619  0999              ; if false.
3620  0999
3621  0999              ; If a relational expression is not found, it returns two functions up.
3622  0999
3623  0999              ; Returns:
3624  0999              ;	HL: Result of the relational operator.
3625  0999
3626  0999              ;; EVAL_RELATIONAL
3627  0999              l0999h:
3628  0999 DF           	rst 18h		;0999	Call READ_PAR
3629  099A 3E           	db '>'		;099a
3630  099B 07           	db l09a3h-$-1	;099b
3631  099C
3632  099C CD 39 04     	call l0439h	;099c	Call EVAL_RELATIONAL_2
3633  099F
3634  099F C8           	ret z		;099f	Return HL = 1 if greater
3635  09A0 D8           	ret c		;09a0
3636  09A1 23           	inc hl		;09a1
3637  09A2 C9           	ret		;09a2
3638  09A3
3639  09A3              l09a3h:
3640  09A3 DF           	rst 18h		;09a3	Call READ_PAR
3641  09A4 3D           	db '='		;09a4
3642  09A5 06           	db l09ach-$-1	;09a5
3643  09A6
3644  09A6 CD 39 04     	call l0439h	;09a6	Call EVAL_RELATIONAL_2
3645  09A9
3646  09A9 C0           	ret nz		;09a9	Return HL = 1 if equal
3647  09AA 23           	inc hl		;09aa
3648  09AB C9           	ret		;09ab
3649  09AC
3650  09AC              l09ach:
3651  09AC DF           	rst 18h		;09ac	Call READ_PAR
3652  09AD 3C           	db '<'		;09ad
3653  09AE 53           	db l0a02h-$-1	;09ae	Return two functions up.
3654  09AF
3655  09AF CD 39 04     	call l0439h	;09af	Call EVAL_RELATIONAL_2
3656  09B2 D0           	ret nc		;09b2	Return HL = 1 if less
3657  09B3 23           	inc hl		;09b3
3658  09B4 C9           	ret		;09b4
3659  09B5
3660  09B5              ; 'PUT CHARACTER ON SCREEN'
3661  09B5              ; =========================
3662  09B5              ; Print a character in A to the screen at the current cursor position
3663  09B5              ; (CURSOR_POS).
3664  09B5
3665  09B5              ; This function holds Galaksija's "terminal emulation" routines. Several
3666  09B5              ; special ASCII characters are recognized if C flag is set. Video output
3667  09B5              ; can be redirected with the use of VIDEO_LINK.
3668  09B5
3669  09B5              ; Parameters:
3670  09B5              ;	A: Character to print
3671  09B5              ;	C flag: Character is considered special if C flag is set
3672  09B5              ; Returns:
3673  09B5              ;	HL: Position of the printed character + 1
3674  09B5
3675  09B5              ; Destroys:
3676  09B5              ;	BC,DE
3677  09B5
3678  09B5              ;; PUTCH
3679  09B5              l09b5h:
3680  09B5 F5           	push af		;09b5	Push AF to stack
3681  09B6 CD AC 2B     	call 02bach	;09b6	Call VIDEO_LINK
3682  09B9 2A 68 2A     	ld hl,(02a68h)	;09b9	Load CURSOR_POS into HL
3683  09BC
3684  09BC 38 46        	jr c,l0a04h	;09bc	If carry set, jump to SPECIAL_CHAR
3685  09BE
3686  09BE 77           	ld (hl),a	;09be	Write character in A to screen
3687  09BF 23           	inc hl		;09bf	Increment HL
3688  09C0
3689  09C0              ; Scroll the screen if necessary
3690  09C0
3691  09C0              ;; PUTCH_SCROLL
3692  09C0              l09c0h:
3693  09C0 3E 2A        	ld a,02ah	;09c0	Load 2ah into A
3694  09C2 BC           	cp h		;09c2	Compare with H
3695  09C3 20 3A        	jr nz,l09ffh	;09c3	If cursor is still within video memory,
3696  09C5              			;	jump to PUTCH_END.
3697  09C5
3698  09C5              ; Scroll screen contents content up one line, skipping WINDOW_LEN characters
3699  09C5              ; on top.
3700  09C5
3701  09C5 21 B0 2B     	ld hl,02bb0h	;09c5	Load SCROLL_CNT address into HL
3702  09C8 CD 3D 0A     	call l0a3dh	;09c8	Call WAIT_INT (wait for soft scroll to finish)
3703  09CB
3704  09CB E5           	push hl		;09cb	Push HL to stack
3705  09CC 23           	inc hl		;09cc	Increment HL (now points to SCROLL_FLAG)
3706  09CD
3707  09CD 34           	inc (hl)	;09cd	Set SCROLL_FLAG
3708  09CE CD 3D 0A     	call l0a3dh	;09ce	Call WAIT_INT (sync to video refresh)
3709  09D1
3710  09D1 B7           	or a		;09d1	?
3711  09D2
3712  09D2 ED 5B 6C 2A  	ld de,(02a6ch)	;09d2	Load WINDOW_LEN into DE
3713  09D6 CB 8A        	res 1,d		;09d6	Reset bit 1 of D
3714  09D8
3715  09D8 21 E0 01     	ld hl,001e0h	;09d8	Load 480 into HL (32 characters * 15 lines)
3716  09DB ED 52        	sbc hl,de	;09db	Substract DE from HL
3717  09DD
3718  09DD 28 0E        	jr z,l09edh	;09dd	Jump forward if result is zero...
3719  09DF 38 0C        	jr c,l09edh	;09df	...or less
3720  09E1
3721  09E1 44           	ld b,h		;09e1	Load HL into BC
3722  09E2 4D           	ld c,l		;09e2	(number of characters moved)
3723  09E3
3724  09E3 CB DA        	set 3,d		;09e3	D = D | 28h
3725  09E5 CB EA        	set 5,d		;09e5
3726  09E7
3727  09E7 21 20 00     	ld hl,32	;09e7	HL (source) = DE (dest) + 32
3728  09EA 19           	add hl,de	;09ea	(one line of characters lower)
3729  09EB
3730  09EB ED B0        	ldir		;09eb	Block transfer
3731  09ED
3732  09ED              ; Soft scroll screen up one line, if WINDOW_LEN is zero
3733  09ED
3734  09ED              l09edh:
3735  09ED 2A 6C 2A     	ld hl,(02a6ch)	;09ed	Load WINDOW_LEN into HL
3736  09F0
3737  09F0 7C           	ld a,h		;09f0	Load top byte of WINDOW_LEN into A
3738  09F1 B5           	or l		;09f1	A = A | L
3739  09F2
3740  09F2 E1           	pop hl		;09f2	Pop HL from stack (HL points to SCROLL_CNT)
3741  09F3
3742  09F3 20 02        	jr nz,l09f7h	;09f3	If WINDOW_LEN is not zero, jump forward...
3743  09F5 36 03        	ld (hl),003h	;09f5	Else load 3 into SCROLL_CNT
3744  09F7
3745  09F7              ; Clear bottom line
3746  09F7
3747  09F7              l09f7h:
3748  09F7 21 E0 29     	ld hl,029e0h	;09f7	Load 29e0h into HL (start of the bottom line
3749  09FA              			;	on the screen)
3750  09FA E5           	push hl		;09fa	Push HL on stack
3751  09FB CD 34 0A     	call l0a34h	;09fb	Call CLEAR_LINE
3752  09FE E1           	pop hl		;09fe	Pop HL from stack
3753  09FF
3754  09FF              ; Update cursor position and return.
3755  09FF
3756  09FF              ;; PUTCH_END
3757  09FF              l09ffh:
3758  09FF 22 68 2A     	ld (02a68h),hl	;09ff	Update cursor position
3759  0A02
3760  0A02              l0a02h:
3761  0A02 F1           	pop af		;0a02	Pop AF from stack
3762  0A03 C9           	ret		;0a03	Return
3763  0A04
3764  0A04              ; Interpret special characters
3765  0A04
3766  0A04              ;; SPECIAL_CHAR
3767  0A04              l0a04h:
3768  0A04 FE 0D        	cp 00dh		;0a04	Compare A with 0dh (ASCII CR)
3769  0A06 20 0E        	jr nz,l0a16h	;0a06	If not equal jump forward
3770  0A08
3771  0A08              ; Put cursor on the next line
3772  0A08
3773  0A08 7C           	ld a,h		;0a08	Load A with H
3774  0A09 FE 2B        	cp 02bh		;0a09	Compare H with 2bh (is cursor on screen?)
3775  0A0B
3776  0A0B 38 04        	jr c,l0a11h	;0a0b	If H less than 2bh jump forward...
3777  0A0D 36 0D        	ld (hl),00dh	;0a0d	...else put character on screen
3778  0A0F 18 EE        	jr l09ffh	;0a0f	   and jump to PUTCH_END
3779  0A11
3780  0A11              l0a11h:
3781  0A11 CD 34 0A     	call l0a34h	;0a11	Call CLEAR_LINE (puts cursor on the start
3782  0A14              			;	of the next line)
3783  0A14 18 AA        	jr l09c0h	;0a14	Jump to PUTCH_SCROLL
3784  0A16
3785  0A16              l0a16h:
3786  0A16 FE 0C        	cp 00ch		;0a16	Compare A with 0ch (ASCII FF)
3787  0A18 20 0D        	jr nz,l0a27h	;0a18	If not equal jump forward
3788  0A1A
3789  0A1A              ; Clear screen
3790  0A1A
3791  0A1A 21 FF 29     	ld hl,029ffh	;0a1a	Load 29ffh to HL (last character on screen)
3792  0A1D              l0a1dh:
3793  0A1D 36 20        	ld (hl),020h	;0a1d	Load 20h (ASCII space) to (HL)
3794  0A1F 2B           	dec hl		;0a1f	Decrement HL
3795  0A20 CB 4C        	bit 1,h		;0a20	Test bit 1 of H
3796  0A22 28 F9        	jr z,l0a1dh	;0a22	If zero, loop
3797  0A24
3798  0A24              l0a24h:
3799  0A24 23           	inc hl		;0a24	Increment HL
3800  0A25              			;	(points to the first char on screen)
3801  0A25 18 D8        	jr l09ffh	;0a25	Jump to PUTCH_SCROLL
3802  0A27
3803  0A27              l0a27h:
3804  0A27 FE 1D        	cp 01dh		;0a27	Compare A with 1dh (ASCII GS)
3805  0A29 20 D4        	jr nz,l09ffh	;0a29	If not equal jump to PUTCH_END
3806  0A2B
3807  0A2B              ; Clear current character and move cursor one position back
3808  0A2B
3809  0A2B 36 20        	ld (hl),020h	;0a2b	Load 20h (ASCII space) to (HL)
3810  0A2D 2B           	dec hl		;0a2d	Decrement HL
3811  0A2E
3812  0A2E CB 4C        	bit 1,h		;0a2e	Test bit 1 of H
3813  0A30 20 F2        	jr nz,l0a24h	;0a30	If not zero (cursor went off screen), jump
3814  0A32              			;	to increment back HL.
3815  0A32 18 CB        	jr l09ffh	;0a32	Jump to PUTCH_END
3816  0A34
3817  0A34              ; 'CLEAR LINE'
3818  0A34              ; ============
3819  0A34              ; This function fills a line with ASCII space (20h) characters from the
3820  0A34              ; location pointed by HL to the end of the line.
3821  0A34
3822  0A34              ; Parameters:
3823  0A34              ;	HL: Pointer to the start of the line to be filled.
3824  0A34              ; Returns:
3825  0A34              ;	HL: Pointer to the start of the next line
3826  0A34              ; Destroys:
3827  0A34              ;	A, flags
3828  0A34
3829  0A34              ;; CLEAR_LINE
3830  0A34              l0a34h:
3831  0A34 36 20        	ld (hl),020h	;0a34	Store ASCII space at location pointed to by HL
3832  0A36 23           	inc hl		;0a36	Increment HL
3833  0A37
3834  0A37 7D           	ld a,l		;0a37	Load L into A
3835  0A38 E6 1F        	and 01fh	;0a38	A = A & 1fh
3836  0A3A
3837  0A3A 20 F8        	jr nz,l0a34h	;0a3a	If A not zero, loop...
3838  0A3C C9           	ret		;0a3c	...else return
3839  0A3D
3840  0A3D              ; 'WAIT FOR INTERRUPT'
3841  0A3D              ; ====================
3842  0A3D              ; This function waits for an interrupt routine to reset a flag pointed to
3843  0A3D              ; by HL register.
3844  0A3D
3845  0A3D              ; Function returns immediately if interrupts are disabled.
3846  0A3D
3847  0A3D              ; Parameters:
3848  0A3D              ;	HL: pointer to the flag (interrupt must set this to 0)
3849  0A3D              ; Destroys:
3850  0A3D              ;	A, flags
3851  0A3D
3852  0A3D              ;; WAIT_INT
3853  0A3D              l0a3dh:
3854  0A3D ED 57        	ld a,i		;0a3d	Load FF2 state into P/V flag
3855  0A3F E0           	ret po		;0a3f	Return if interrupts are disabled
3856  0A40
3857  0A40              l0a40h:
3858  0A40 7E           	ld a,(hl)	;0a40	Load flag byte into A
3859  0A41 B7           	or a		;0a41	Update Z flag
3860  0A42 20 FC        	jr nz,l0a40h	;0a42	If byte is not zero, loop...
3861  0A44 C9           	ret		;0a44	...else return
3862  0A45
3863  0A45              ; 'PUSH FLOATING POINT NUMBER ON STACK'
3864  0A45              ; =====================================
3865  0A45              ; Stores a 4-byte floating point number at (HL) on the arithmetic stack.
3866  0A45
3867  0A45              ; IX Offset	0	1	2	3	4
3868  0A45              ; ---------------------------------------------------
3869  0A45              ;		24 bit mantissa	(MSB)	Exp	Sign
3870  0A45
3871  0A45              ; IX Offset	0        1        2	   3        4
3872  0A45              ; -------------------------------------------------------------
3873  0A45              ;		MMMMMMMM MMMMMMMM 1MMMMMMM EEEEEEEE S0000000
3874  0A45              ;		(LSB)		  (MSB)
3875  0A45
3876  0A45              ; HL Offset	0        1        2	   3
3877  0A45              ; --------------------------------------------------
3878  0A45              ;		MMMMMMMM MMMMMMMM EMMMMMMM SEEEEEEE
3879  0A45              ;		(LSB)		  (MSB)
3880  0A45
3881  0A45              ;; PUSH_FP
3882  0A45              l0a45h:
3883  0A45 D5           	push de		;0a45	Save DE, HL and AF on stack
3884  0A46 E5           	push hl		;0a46
3885  0A47 F5           	push af		;0a47
3886  0A48
3887  0A48 01 04 00     	ld bc,00004h	;0a48	Load 4 into BC
3888  0A4B
3889  0A4B DD E5        	push ix		;0a4b	Load IX into DE
3890  0A4D D1           	pop de		;0a4d
3891  0A4E
3892  0A4E ED B0        	ldir		;0a4e	Transfer 4 bytes starting from (HL) into (IX)
3893  0A50
3894  0A50 DD CB 02 16  	rl (ix+2)	;0a50	Extract sign bit from IX+2 and IX+3
3895  0A54 DD CB 03 16  	rl (ix+3)	;0a54
3896  0A58
3897  0A58 78           	ld a,b		;0a58	Store sign bit in IX+4
3898  0A59 1F           	rra		;0a59
3899  0A5A DD 77 04     	ld (ix+4),a	;0a5a
3900  0A5D
3901  0A5D 37           	scf		;0a5d	Set top bit of mantissa
3902  0A5E DD CB 02 1E  	rr (ix+2)	;0a5e
3903  0A62
3904  0A62 0E 05        	ld c,005h	;0a62	IX = IX + 5
3905  0A64 DD 09        	add ix,bc	;0a64
3906  0A66
3907  0A66 F1           	pop af		;0a66	Restore DE, HL and AL from stack
3908  0A67 E1           	pop hl		;0a67
3909  0A68 D1           	pop de		;0a68
3910  0A69
3911  0A69 C9           	ret		;0a69	Return
3912  0A6A
3913  0A6A              ; 'EVALULATE INTEGER VALUE IN PARENTHESIS'
3914  0A6A              ; ========================================
3915  0A6A              ; Evaluates expression in parenthesis at DE, converts it to integer and returns
3916  0A6A              ; it in DE.
3917  0A6A
3918  0A6A              ;; EVAL_PAREN_INT
3919  0A6A              l0a6ah:
3920  0A6A CD 81 07     	call l0781h	;0a6a	Call EVAL_PAREN
3921  0A6D
3922  0A6D              ; 'FLOATING POINT TO INTEGER'
3923  0A6D              ; ===========================
3924  0A6D              ; Convert floating point at the top of the arithmetic stack to integer.
3925  0A6D
3926  0A6D              ; Returns:
3927  0A6D              ;	HL: Integer value
3928  0A6D
3929  0A6D              ;; FP_TO_INT
3930  0A6D              l0a6dh:
3931  0A6D D9           	exx		;0a6d
3932  0A6E CD 0E 09     	call l090eh	;0a6e	Call SUB_IX_5
3933  0A71
3934  0A71 11 00 00     	ld de,l0000h	;0a71	Clear DE'
3935  0A74
3936  0A74              ; IX Offset	0	1	2	3	4
3937  0A74              ; ---------------------------------------------------
3938  0A74              ;		24 bit mantissa	(MSB)	Exp	Sign
3939  0A74
3940  0A74 DD 7E 03     	ld a,(ix+3)	;0a74	Load exponent into A
3941  0A77 DD 4E 04     	ld c,(ix+4)	;0a77	Load sign into C'
3942  0A7A
3943  0A7A FE 80        	cp 080h		;0a7a	Return 0 if exponent equal to -128
3944  0A7C 28 2C        	jr z,l0aaah	;0a7c
3945  0A7E
3946  0A7E FE 01        	cp 001h		;0a7e	Return 0 if exponent less than 1
3947  0A80 FA AE 0A     	jp m,l0aaeh	;0a80	(why not jump to l0aaah like above?)
3948  0A83
3949  0A83 FE 10        	cp 010h		;0a83	Jump to error if exponent greater than 16
3950  0A85 D9           	exx		;0a85
3951  0A86 F2 5A 06     	jp p,l065ah	;0a86
3952  0A89 D9           	exx		;0a89
3953  0A8A
3954  0A8A              ; DE = mantissa * 2 ^ exponent
3955  0A8A
3956  0A8A 47           	ld b,a		;0a8a	Load exponent into B'
3957  0A8B
3958  0A8B DD 7E 00     	ld a,(ix+000h)	;0a8b	Load mantissa into HL' A'
3959  0A8E DD 6E 01     	ld l,(ix+001h)	;0a8e
3960  0A91 DD 66 02     	ld h,(ix+002h)	;0a91
3961  0A94
3962  0A94              l0a94h:
3963  0A94 CB 27        	sla a		;0a94	Shift left HL' A'
3964  0A96 ED 6A        	adc hl,hl	;0a96
3965  0A98
3966  0A98 CB 13        	rl e		;0a98	Shift left DE'
3967  0A9A CB 12        	rl d		;0a9a
3968  0A9C
3969  0A9C 10 F6        	djnz l0a94h	;0a9c	Loop
3970  0A9E
3971  0A9E              l0a9eh:
3972  0A9E CB 21        	sla c		;0a9e	Jump forward if sign is positive
3973  0AA0 30 08        	jr nc,l0aaah	;0aa0
3974  0AA2
3975  0AA2 B4           	or h		;0aa2	Increment DE' if HL' A' not zero
3976  0AA3 B5           	or l		;0aa3
3977  0AA4 28 01        	jr z,l0aa7h	;0aa4
3978  0AA6 13           	inc de		;0aa6
3979  0AA7              l0aa7h:
3980  0AA7 CD D7 0A     	call l0ad7h	;0aa7	DE' = -DE' (Call NEG_DE)
3981  0AAA
3982  0AAA              l0aaah:
3983  0AAA D5           	push de		;0aaa	Load result into HL
3984  0AAB D9           	exx		;0aab
3985  0AAC E1           	pop hl		;0aac
3986  0AAD C9           	ret		;0aad	Return
3987  0AAE
3988  0AAE              l0aaeh:
3989  0AAE 3E FF        	ld a,0ffh	;0aae	Set A to -1
3990  0AB0 18 EC        	jr l0a9eh	;0ab0
3991  0AB2
3992  0AB2              ; 'EVALUATE NUMERIC EXPRESSION'
3993  0AB2              ; =============================
3994  0AB2              ; Evaluate numeric expression at DE and push the result on the arithmetic
3995  0AB2              ; stack.
3996  0AB2
3997  0AB2              ;; EVAL_EXPRESSION
3998  0AB2              l0ab2h:
3999  0AB2 CD 8E 06     	call l068eh	;0ab2	Call EVAL_ARITHMETIC
4000  0AB5 CD 99 09     	call l0999h	;0ab5	Call EVAL_RELATIONAL
4001  0AB8              			;	Returns to the calling function, if no
4002  0AB8              			;	relational operator found.
4003  0AB8
4004  0AB8 01           	db 001h		;0ab8	Dummy ld bc,nn (skip the following instruction)
4005  0AB9
4006  0AB9              ; 'PUSH 10 TO ARITHMETIC STACK'
4007  0AB9              ; ============================
4008  0AB9              ; Pushes floating point constant 10 to the arithmetic stack.
4009  0AB9
4010  0AB9              ;; PUSH_FP_10
4011  0AB9              l0ab9h:
4012  0AB9 21 0A 00     	ld hl,0000ah	;0ab9
4013  0ABC
4014  0ABC              ; Push result from EVAL_RELATIONAL to stack.
4015  0ABC
4016  0ABC              ; 'INTEGER TO FLOATING POINT'
4017  0ABC              ; ===========================
4018  0ABC              ; Converts integer in HL to floating point and stores it into the arithmetic
4019  0ABC              ; stack.
4020  0ABC
4021  0ABC              ; Parameters:
4022  0ABC              ;	HL: Integer to convert.
4023  0ABC
4024  0ABC              ;; INT_TO_FP
4025  0ABC              l0abch:
4026  0ABC D5           	push de		;0abc	Save DE on stack.
4027  0ABD
4028  0ABD              ;; INT_TO_FP_2
4029  0ABD              l0abdh:
4030  0ABD EB           	ex de,hl	;0abd	DE = integer to convert
4031  0ABE
4032  0ABE CD 17 09     	call l0917h	;0abe	Call ADD_IX_10
4033  0AC1 CD D4 0A     	call l0ad4h	;0ac1	Call ABS_DE
4034  0AC4
4035  0AC4 D5           	push de		;0ac4	Save DE on stack
4036  0AC5
4037  0AC5 21 10 00     	ld hl,0010h	;0ac5	Load 16 into L
4038  0AC8 CB 1C        	rr h		;0ac8	Set MSB of H to sign bit.
4039  0ACA
4040  0ACA D9           	exx		;0aca
4041  0ACB
4042  0ACB D1           	pop de		;0acb	Restore DE' from stack
4043  0ACC EF           	rst 28h		;0acc	Clear HL' (Call CLEAR_HL)
4044  0ACD 63           	ld h,e		;0acd	Load E' into H'
4045  0ACE 4A           	ld c,d		;0ace	Load D' into C'
4046  0ACF
4047  0ACF              ; IX Offset	-5	-4	-3	-2	-1
4048  0ACF              ; ---------------------------------------------------
4049  0ACF              ;		L'	H'	C'	L	H
4050  0ACF              ; ---------------------------------------------------
4051  0ACF              ;		24 bit mantissa	(MSB)	Exp	Sign
4052  0ACF
4053  0ACF CD 4C 0C     	call l0c4ch	;0acf	Call CORRECT_EXP
4054  0AD2 18 2F        	jr l0b03h	;0ad2	Jump to STORE_ARITHM_RET_0
4055  0AD4
4056  0AD4              ; 'ABSOLUTE VALUE DE'
4057  0AD4              ; ===================
4058  0AD4              ; Calculates absolute value of integer in DE.
4059  0AD4
4060  0AD4              ; Parameters:
4061  0AD4              ;	DE
4062  0AD4              ; Returns:
4063  0AD4              ;	DE: Absolute value.
4064  0AD4              ;       Cf: Set if DE was negative, reset otherwise.
4065  0AD4              ; Destroys:
4066  0AD4              ;	A
4067  0AD4
4068  0AD4              ;; ABS_DE
4069  0AD4              l0ad4h:
4070  0AD4 AF           	xor a		;0ad4	Clear A
4071  0AD5 82           	add a,d		;0ad5	Add D to A.
4072  0AD6 F0           	ret p		;0ad6	Return if D positive, otherwise continue to
4073  0AD7              			;	NEG_DE
4074  0AD7
4075  0AD7              ; 'NEGATE DE'
4076  0AD7              ; ===========
4077  0AD7              ; Negates the value of integer in DE.
4078  0AD7
4079  0AD7              ; Parameters:
4080  0AD7              ;	DE
4081  0AD7              ; Returns:
4082  0AD7              ;	DE: Absolute value.
4083  0AD7              ;       Cf: Always Set.
4084  0AD7              ; Destroys:
4085  0AD7              ;	A
4086  0AD7
4087  0AD7              ;; NEG_DE
4088  0AD7              l0ad7h:
4089  0AD7 7B           	ld a,e		;0ad7	E = -E
4090  0AD8 ED 44        	neg		;0ad8
4091  0ADA 5F           	ld e,a		;0ada
4092  0ADB
4093  0ADB 7A           	ld a,d		;0adb	D = ~D + ~Cf
4094  0ADC 2F           	cpl		;0adc
4095  0ADD 3F           	ccf		;0add
4096  0ADE CE 00        	adc a,000h	;0ade
4097  0AE0 57           	ld d,a		;0ae0
4098  0AE1
4099  0AE1 37           	scf		;0ae1	Set carry flag
4100  0AE2 C9           	ret		;0ae2	Return
4101  0AE3
4102  0AE3              ; 'MULTIPLY BY 10'
4103  0AE3              ; ================
4104  0AE3              ; Multiplies the number on the top of the arithmetic stack by 10
4105  0AE3
4106  0AE3              ;; FP_MUL_10
4107  0AE3              l0ae3h:
4108  0AE3 CD B9 0A     	call l0ab9h	;0ae3	Push 10 on the arithmetic stack
4109  0AE6              			;	(call PUSH_FP_10)
4110  0AE6
4111  0AE6              ;; FP_MUL
4112  0AE6              l0ae6h:
4113  0AE6 CD 68 0C     	call l0c68h	;0ae6	Call FETCH_TWO_FP
4114  0AE9 28 3E        	jr z,l0b29h	;0ae9	If first operand is zero, just remove the
4115  0AEB              			;	second operand from stack and return (jumps
4116  0AEB              			;	to STORE_ARITHM_RET_2)
4117  0AEB
4118  0AEB BB           	cp e		;0aeb	If the second operand is zero, store a zero
4119  0AEC CA 6B 0B     	jp z,l0b6bh	;0aec	floating point value on stack and return
4120  0AEF              			;	(jump to STORE_ZERO_RET)
4121  0AEF
4122  0AEF CD 81 0B     	call l0b81h	;0aef	Call FP_MUL_DO
4123  0AF2 18 0F        	jr l0b03h	;0af2	Jump to STORE_ARITHM_RET_0
4124  0AF4
4125  0AF4              ; 'DIVIDE BY 10'
4126  0AF4              ; ================
4127  0AF4              ; Divides the number on the top of the arithmetic stack by 10
4128  0AF4
4129  0AF4              ;; FP_DIV_10
4130  0AF4              l0af4h:
4131  0AF4 CD B9 0A     	call l0ab9h	;0af4	Push 10 on the arithmetic stack
4132  0AF7              			;	(call PUSH_FP_10)
4133  0AF7              ;; FP_DIV
4134  0AF7              l0af7h:
4135  0AF7 CD 68 0C     	call l0c68h		;0af7	cd 68 0c 	  h
4136  0AFA 28 2D        	jr z,l0b29h		;0afa	28 2d 	( -
4137  0AFC BB           	cp e			;0afc	bb
4138  0AFD CA 5B 06     	jp z,l065bh		;0afd	ca 5b 06 	  [
4139  0B00 CD AE 0B     	call l0baeh		;0b00	cd ae 0b
4140  0B03
4141  0B03              ; 'STORE ARITHMETIC RESULT TRAMPOLINE'
4142  0B03              ; ====================================
4143  0B03
4144  0B03              ;; STORE_ARITHM_RET_0
4145  0B03              l0b03h:
4146  0B03 18 68        	jr l0b6dh		;0b03	Jump to STORE_ARITHM_RET
4147  0B05
4148  0B05              ; 'COMPARE VARIABLE WITH ARITHMETIC STACK'
4149  0B05              ; ========================================
4150  0B05              ; Compares the number at the top of the arithmetic stack with the 4-byte
4151  0B05              ; floating point at (HL)
4152  0B05
4153  0B05              ;; FP_COMPARE_HL
4154  0B05              l0b05h:
4155  0B05 CD 45 0A     	call l0a45h	;0b05	Call PUSH_FP
4156  0B08 CD 68 0C     	call l0c68h	;0b08	Call FETCH_TWO_FP
4157  0B0B
4158  0B0B 01 FB FF     	ld bc,0fffbh	;0b0b	Load -5 into BC
4159  0B0E 18 06        	jr l0b16h	;0b0e	Jump into FP_COMPARE (remove the only the value
4160  0B10              			;	pushed on the stach by PUSH_FP)
4161  0B10
4162  0B10
4163  0B10              ; 'COMPARE TWO FLOATING POINT NUMBERS'
4164  0B10              ; ====================================
4165  0B10              ; Pops two floating point numbers from the top of the arithmetic stack,
4166  0B10              ; compares them and returns the result in the flags register.
4167  0B10
4168  0B10              ;; FP_COMPARE
4169  0B10              l0b10h:
4170  0B10 CD 68 0C     	call l0c68h	;0b10	Call FETCH_TWO_FP
4171  0B13 01 F6 FF     	ld bc,0fff6h	;0b13
4172  0B16              l0b16h:
4173  0B16 DD 09        	add ix,bc	;0b16	Subtract -10 from IX
4174  0B18
4175  0B18 BD           	cp l		;0b18	Compare A (80h) with L
4176  0B19 CD E6 0B     	call l0be6h	;0b19	Jump to the rest of the function
4177  0B1C
4178  0B1C D1           	pop de		;0b1c	Restore DE
4179  0B1D C9           	ret		;0b1d	Return
4180  0B1E
4181  0B1E              ;; FP_SUB
4182  0B1E              l0b1eh:
4183  0B1E CD 68 0C     	call l0c68h		;0b1e	cd 68 0c 	  h
4184  0B21 20 05        	jr nz,l0b28h		;0b21	20 05
4185  0B23 CD 62 0B     	call l0b62h		;0b23	cd 62 0b 	  b
4186  0B26 18 30        	jr l0b58h		;0b26	18 30 	  0
4187  0B28              l0b28h:
4188  0B28 BB           	cp e			;0b28	bb
4189  0B29              l0b29h:
4190  0B29 28 53        	jr z,l0b7eh	;0b29	Jump to STORE_ARITHM_RET_2
4191  0B2B AA           	xor d			;0b2b	aa
4192  0B2C 57           	ld d,a			;0b2c	57 	W
4193  0B2D 18 0B        	jr l0b3ah		;0b2d	18 0b
4194  0B2F CD 45 0A     	call l0a45h		;0b2f	cd 45 0a 	  E
4195  0B32
4196  0B32              ; 'ADD TWO FLOATING POINT NUMBERS'
4197  0B32              ; ================================
4198  0B32              ; Pops two numbers from the top of the arithmetic stack, adds them and pushes
4199  0B32              ; the result on the stack.
4200  0B32
4201  0B32              ; IX Offset	-5	-4	-3	-2	-1
4202  0B32              ; ---------------------------------------------------
4203  0B32              ;		E'	D'	B'	E	D
4204  0B32              ; ---------------------------------------------------
4205  0B32              ;		24 bit mantissa	(MSB)	Exp	Sign
4206  0B32
4207  0B32              ; IX Offset	-10	-9	-8	-7	-6
4208  0B32              ; ---------------------------------------------------
4209  0B32              ;		L'	H'	C'	L	H
4210  0B32              ; ---------------------------------------------------
4211  0B32              ;		24 bit mantissa	(MSB)	Exp	Sign
4212  0B32
4213  0B32              ;; FP_ADD
4214  0B32              l0b32h:
4215  0B32 CD 68 0C     	call l0c68h	;0b32	Call FETCH_TWO_FP
4216  0B35 28 2C        	jr z,l0b63h	;0b35	Second number is zero.
4217  0B37
4218  0B37 BB           	cp e		;0b37
4219  0B38 28 44        	jr z,l0b7eh	;0b38	First number is zero. Just remove the second
4220  0B3A              			;	operand from stack.
4221  0B3A
4222  0B3A              			;	Jump to STORE_ARITHM_RET_2
4223  0B3A
4224  0B3A              l0b3ah:
4225  0B3A CD 04 0C     	call l0c04h	;0b3a	Call FP_COMPARE_ABS
4226  0B3D 28 0E        	jr z,l0b4dh	;0b3d	Mantissa and exponent are equal
4227  0B3F
4228  0B3F 30 07        	jr nc,l0b48h	;0b3f	If DE' B' DE > HL' C' HL, exchange operands
4229  0B41
4230  0B41 EB           	ex de,hl	;0b41	exchange DE' B' DE and HL' C' HL
4231  0B42 D9           	exx		;0b42
4232  0B43 EB           	ex de,hl	;0b43
4233  0B44 79           	ld a,c		;0b44
4234  0B45 48           	ld c,b		;0b45
4235  0B46 47           	ld b,a		;0b46
4236  0B47 D9           	exx		;0b47
4237  0B48
4238  0B48              l0b48h:
4239  0B48 CD 17 0C     	call l0c17h	;0b48	Call FP_ADD_DO
4240  0B4B 18 20        	jr l0b6dh	;0b4b	Jump to STORE_ARITHM_RET
4241  0B4D
4242  0B4D              ; Mantissa and exponent of operands are equal
4243  0B4D
4244  0B4D              l0b4dh:
4245  0B4D 7C           	ld a,h		;0b4d	A = XOR of both sign bits
4246  0B4E AA           	xor d		;0b4e
4247  0B4F 20 1A        	jr nz,l0b6bh	;0b4f	Signs different: jump to STORE_ZERO_RET
4248  0B51
4249  0B51 1E 01        	ld e,001h	;0b51	Signs equal: Multiply by 2
4250  0B53 CD 3F 0C     	call l0c3fh	;0b53	Jump to FP_MUL_EXP
4251  0B56
4252  0B56 18 15        	jr l0b6dh	;0b56	Jump to STORE_ARITHM_RET
4253  0B58
4254  0B58              l0b58h:
4255  0B58 DD 7E FF     	ld a,(ix-1)		;0b58	dd 7e ff 	  ~
4256  0B5B EE 80        	xor 080h		;0b5b	ee 80
4257  0B5D DD 77 FF     	ld (ix-1),a		;0b5d	dd 77 ff 	  w
4258  0B60 D1           	pop de			;0b60	d1
4259  0B61 C9           	ret			;0b61	c9
4260  0B62              l0b62h:
4261  0B62 D5           	push de			;0b62	d5
4262  0B63
4263  0B63              ; Second operand of addition is zero.
4264  0B63
4265  0B63              ;; FP_ADD_ZERO_2
4266  0B63              l0b63h:
4267  0B63 62           	ld h,d		;0b63	HL' C' HL = DE' B' DE
4268  0B64 6B           	ld l,e		;0b64
4269  0B65 D9           	exx		;0b65
4270  0B66 6B           	ld l,e		;0b66
4271  0B67 62           	ld h,d		;0b67
4272  0B68 48           	ld c,b		;0b68
4273  0B69 D9           	exx		;0b69
4274  0B6A
4275  0B6A 01           	db 001h		;0b6a	Dummy ld bc,nn (skip ld l,080h)
4276  0B6B
4277  0B6B              ; 'STORE ZERO RESULT & RETURN'
4278  0B6B              ; ============================
4279  0B6B
4280  0B6B              ;; STORE_ZERO_RET
4281  0B6B              l0b6bh:
4282  0B6B 2E 80        	ld l,080h	;0b6b
4283  0B6D
4284  0B6D              ; 'STORE ARITHMETIC RESULT & RETURN'
4285  0B6D              ; ==================================
4286  0B6D              ; JP to this location is used by arithmetic functions with two operands to
4287  0B6D              ; store the result on the arithmetic stack at IX.
4288  0B6D
4289  0B6D              ; DE pointer is restored from CPU stack before returning.
4290  0B6D
4291  0B6D              ; Top two values are removed from the stack and the Floating point number in
4292  0B6D              ; HL' C' HL is stored.
4293  0B6D
4294  0B6D              ; IX Offset	-5	-4	-3	-2	-1
4295  0B6D              ; ---------------------------------------------------
4296  0B6D              ;		L'	H'	C'	L	H
4297  0B6D              ; ---------------------------------------------------
4298  0B6D              ;		24 bit mantissa	(MSB)	Exp	Sign
4299  0B6D
4300  0B6D              ;; STORE_ARITHM_RET
4301  0B6D              l0b6dh:
4302  0B6D DD 74 FA     	ld (ix-6),h		;0b6d	Store result in the second-to-last
4303  0B70 DD 75 F9     	ld (ix-7),l		;0b70	stack location.
4304  0B73 D9           	exx			;0b73
4305  0B74 DD 75 F6     	ld (ix-10),l		;0b74
4306  0B77 DD 74 F7     	ld (ix-9),h		;0b77
4307  0B7A DD 71 F8     	ld (ix-8),c		;0b7a
4308  0B7D D9           	exx			;0b7d
4309  0B7E
4310  0B7E              l0b7eh:
4311  0B7E C3 0D 09     	jp l090dh		;0b7e	Jump to STORE_ARITHM_RET_2
4312  0B81
4313  0B81              ; 'MULTIPLY TWO FLOATING POINT NUMBERS (cont.)'
4314  0B81              ; =============================================
4315  0B81              ; Multiplies two floating point numbers (both not equal to zero).
4316  0B81
4317  0B81              ; (first operand, result)
4318  0B81
4319  0B81              ; IX Offset	-5	-4	-3	-2	-1
4320  0B81              ; ---------------------------------------------------
4321  0B81              ;		E'	D'	B'	E	D
4322  0B81              ; ---------------------------------------------------
4323  0B81              ;		24 bit mantissa	(MSB)	Exp	Sign
4324  0B81
4325  0B81              ; (second operand)
4326  0B81
4327  0B81              ; IX Offset	-10	-9	-8	-7	-6
4328  0B81              ; ---------------------------------------------------
4329  0B81              ;		L'	H'	C'	L	H
4330  0B81              ; ---------------------------------------------------
4331  0B81              ;		24 bit mantissa	(MSB)	Exp	Sign
4332  0B81
4333  0B81              ;; FP_MUL_DO
4334  0B81              l0b81h:
4335  0B81 7C           	ld a,h		;0b81	Sign bit of the result = XOR sign bits of
4336  0B82 AA           	xor d		;0b82	operands.
4337  0B83 67           	ld h,a		;0b83
4338  0B84
4339  0B84 1D           	dec e		;0b84	Decrement first exponent.
4340  0B85
4341  0B85 E5           	push hl		;0b85	Save HL and BC on stack
4342  0B86 C5           	push bc		;0b86
4343  0B87
4344  0B87 06 18        	ld b,018h	;0b87	06 18
4345  0B89 CD 81 0C     	call l0c81h	;0b89	cd 81 0c
4346  0B8C
4347  0B8C AF           	xor a		;0b8c	af
4348  0B8D
4349  0B8D EF           	rst 28h		;0b8d	Call CLEAR_HL
4350  0B8E
4351  0B8E 4F           	ld c,a			;0b8e	4f 	O
4352  0B8F              l0b8fh:
4353  0B8F D9           	exx			;0b8f	d9
4354  0B90 CB 39        	srl c		;0b90	cb 39 	  9
4355  0B92 CB 1C        	rr h		;0b92	cb 1c
4356  0B94 CB 1D        	rr l		;0b94	cb 1d
4357  0B96 D9           	exx			;0b96	d9
4358  0B97 30 04        	jr nc,l0b9dh		;0b97	30 04 	0
4359  0B99 19           	add hl,de			;0b99	19
4360  0B9A 79           	ld a,c			;0b9a	79 	y
4361  0B9B 88           	adc a,b			;0b9b	88
4362  0B9C 4F           	ld c,a			;0b9c	4f 	O
4363  0B9D              l0b9dh:
4364  0B9D D9           	exx			;0b9d	d9
4365  0B9E 10 05        	djnz l0ba5h		;0b9e	10 05
4366  0BA0 C1           	pop bc			;0ba0	c1
4367  0BA1 E1           	pop hl			;0ba1	e1
4368  0BA2 D9           	exx			;0ba2	d9
4369  0BA3 18 30        	jr l0bd5h		;0ba3	18 30 	  0
4370  0BA5              l0ba5h:
4371  0BA5 D9           	exx			;0ba5	d9
4372  0BA6 CB 19        	rr c		;0ba6	cb 19
4373  0BA8 CB 1C        	rr h		;0ba8	cb 1c
4374  0BAA CB 1D        	rr l		;0baa	cb 1d
4375  0BAC 18 E1        	jr l0b8fh		;0bac	18 e1
4376  0BAE              l0baeh:
4377  0BAE 7B           	ld a,e			;0bae	7b 	{
4378  0BAF ED 44        	neg		;0baf	ed 44 	  D
4379  0BB1 5F           	ld e,a			;0bb1	5f 	_
4380  0BB2 7C           	ld a,h			;0bb2	7c 	|
4381  0BB3 AA           	xor d			;0bb3	aa
4382  0BB4 67           	ld h,a			;0bb4	67 	g
4383  0BB5 E5           	push hl			;0bb5	e5
4384  0BB6 C5           	push bc			;0bb6	c5
4385  0BB7 06 19        	ld b,019h		;0bb7	06 19
4386  0BB9 D9           	exx			;0bb9	d9
4387  0BBA              l0bbah:
4388  0BBA ED 52        	sbc hl,de		;0bba	ed 52 	  R
4389  0BBC 79           	ld a,c			;0bbc	79 	y
4390  0BBD 98           	sbc a,b			;0bbd	98
4391  0BBE 4F           	ld c,a			;0bbe	4f 	O
4392  0BBF 30 03        	jr nc,l0bc4h		;0bbf	30 03 	0
4393  0BC1 19           	add hl,de		;0bc1	19
4394  0BC2 88           	adc a,b			;0bc2	88
4395  0BC3 4F           	ld c,a			;0bc3	4f 	O
4396  0BC4              l0bc4h:
4397  0BC4 D9           	exx			;0bc4	d9
4398  0BC5 3F           	ccf			;0bc5	3f 	?
4399  0BC6 ED 6A        	adc hl,hl		;0bc6	ed 6a 	  j
4400  0BC8 CB 11        	rl c		;0bc8	cb 11
4401  0BCA 10 0B        	djnz l0bd7h		;0bca	10 0b
4402  0BCC E5           	push hl			;0bcc	e5
4403  0BCD C5           	push bc			;0bcd	c5
4404  0BCE D9           	exx			;0bce	d9
4405  0BCF C1           	pop bc			;0bcf	c1
4406  0BD0 E1           	pop hl			;0bd0	e1
4407  0BD1 D9           	exx			;0bd1	d9
4408  0BD2 C1           	pop bc			;0bd2	c1
4409  0BD3 E1           	pop hl			;0bd3	e1
4410  0BD4 D9           	exx			;0bd4	d9
4411  0BD5              l0bd5h:
4412  0BD5 18 5E        	jr l0c35h		;0bd5	18 5e 	  ^
4413  0BD7              l0bd7h:
4414  0BD7 D9           	exx			;0bd7	d9
4415  0BD8 29           	add hl,hl			;0bd8	29 	)
4416  0BD9 CB 11        	rl c		;0bd9	cb 11
4417  0BDB 30 DD        	jr nc,l0bbah		;0bdb	30 dd 	0
4418  0BDD 3F           	ccf			;0bdd	3f 	?
4419  0BDE ED 52        	sbc hl,de		;0bde	ed 52 	  R
4420  0BE0 79           	ld a,c			;0be0	79 	y
4421  0BE1 98           	sbc a,b			;0be1	98
4422  0BE2 4F           	ld c,a			;0be2	4f 	O
4423  0BE3 B7           	or a			;0be3	b7
4424  0BE4 18 DE        	jr l0bc4h		;0be4	18 de
4425  0BE6
4426  0BE6              ; 'COMPARE TWO FLOATING POINT NUMBERS (cont.)'
4427  0BE6              ; ============================================
4428  0BE6
4429  0BE6              ;		E'	D'	B'	E	D
4430  0BE6              ; ---------------------------------------------------
4431  0BE6              ;		24 bit mantissa	(MSB)	Exp	Sign
4432  0BE6
4433  0BE6              ;		L'	H'	C'	L	H
4434  0BE6              ; ---------------------------------------------------
4435  0BE6              ;		24 bit mantissa	(MSB)	Exp	Sign
4436  0BE6
4437  0BE6
4438  0BE6              ; signs	A B	- -	- +	+ -	+ +
4439  0BE6              ; |A| > |B|	A < B	A < B	A > B	A > B
4440  0BE6              ; |A| = |B|	A = B	A < B	A > B	A = B
4441  0BE6              ; |A| < |B|	A > B	A < B	A > B	A < B
4442  0BE6
4443  0BE6              ;; FP_COMPARE_2
4444  0BE6              l0be6h:
4445  0BE6 28 0A        	jr z,l0bf2h	;0be6	HL' C' HL == 0
4446  0BE8
4447  0BE8 BB           	cp e		;0be8
4448  0BE9 28 0F        	jr z,l0bfah	;0be9	DE' B' DE == 0
4449  0BEB
4450  0BEB 7C           	ld a,h		;0beb	A = XOR of both sign bits
4451  0BEC AA           	xor d		;0bec	(resets Cf)
4452  0BED
4453  0BED CC 04 0C     	call z,l0c04h	;0bed	Call FP_COMPARE_ABS if signs are equal
4454  0BF0
4455  0BF0              			;	Different signs: Cf = 0, Zf = 0
4456  0BF0
4457  0BF0              			;	Equal signs:				Cf Zf
4458  0BF0              			;		|HL' C' HL| > |DE' B' DE| :	0  0
4459  0BF0              			;		|HL' C' HL| = |DE' B' DE| :	0  1
4460  0BF0              			;		|HL' C' HL| < |DE' B' DE| :	1  0
4461  0BF0
4462  0BF0 18 07        	jr l0bf9h	;0bf0	Jump forward
4463  0BF2
4464  0BF2              l0bf2h:
4465  0BF2 BB           	cp e		;0bf2	Return if both numbers are 0
4466  0BF3 C8           	ret z		;0bf3
4467  0BF4
4468  0BF4              			;	HL' C' HL == 0
4469  0BF4              			;	DE' B' DE != 0
4470  0BF4
4471  0BF4 37           	scf		;0bf4			Cf Zf
4472  0BF5 CB 7A        	bit 7,d		;0bf5	DE' B' DE > 0 :	1  1
4473  0BF7              			;	DE' B' DE < 0 :	1  0
4474  0BF7
4475  0BF7 18 03        	jr l0bfch	;0bf7
4476  0BF9
4477  0BF9              l0bf9h:
4478  0BF9 C8           	ret z		;0bf9	Return if sign, mantissa and exponent are equal
4479  0BFA
4480  0BFA              ; also jumps here if DE' B' DE == 0 (Cf = 0)
4481  0BFA
4482  0BFA              l0bfah:
4483  0BFA              			;			Zf
4484  0BFA CB 7C        	bit 7,h		;0bfa	HL' C' HL > 0 : 1
4485  0BFC              			;	HL' C' HL < 0 :	0
4486  0BFC
4487  0BFC              ; Cf	Zf	Result	Cf	Zf
4488  0BFC              ; ------------------------------------
4489  0BFC              ; 0	0		1	0
4490  0BFC              ; 0	1		0	1
4491  0BFC              ; 1	0		0	0
4492  0BFC              ; 1	1		1	1
4493  0BFC
4494  0BFC              l0bfch:
4495  0BFC 3F           	ccf		;0bfc
4496  0BFD C0           	ret nz		;0bfd 	Return with complemented Cf if Zf = 0
4497  0BFE 3F           	ccf		;0bfe
4498  0BFF
4499  0BFF 1F           	rra		;0bff	A = A | 01h
4500  0C00 37           	scf		;0c00
4501  0C01 CB 17        	rl a		;0c01	Clear Zf
4502  0C03
4503  0C03 C9           	ret		;0c03	Return with original Cf if Zf = 1
4504  0C04
4505  0C04              ; 'COMPARE ABSOLUTE VALUES'
4506  0C04              ; =========================
4507  0C04              ; Compares mantissa and exponent of two floating point numbers.
4508  0C04
4509  0C04              ; Parameters:
4510  0C04              ;	DE' B' DE, HL' C' HL: Floating point numbers to compare
4511  0C04
4512  0C04              ; Returns:
4513  0C04              ;	Cf, Zf: Result of (HL' C' HL - DE' B' DE) comparisson.
4514  0C04
4515  0C04              ;		E'	D'	B'	E	D
4516  0C04              ; ---------------------------------------------------
4517  0C04              ;		24 bit mantissa	(MSB)	Exp	Sign
4518  0C04
4519  0C04              ;		L'	H'	C'	L	H
4520  0C04              ; ---------------------------------------------------
4521  0C04              ;		24 bit mantissa	(MSB)	Exp	Sign
4522  0C04
4523  0C04              ;; FP_COMPARE_ABS
4524  0C04              l0c04h:
4525  0C04 7D           	ld a,l		;0c04	Subtract exponents
4526  0C05 93           	sub e		;0c05
4527  0C06
4528  0C06 28 07        	jr z,l0c0fh	;0c06	Equal exponents: Compare mantissa
4529  0C08
4530  0C08 E2 0D 0C     	jp po,l0c0dh	;0c08	Negate top bit of result on overflow
4531  0C0B ED 44        	neg		;0c0b
4532  0C0D              l0c0dh:
4533  0C0D 07           	rlca		;0c0d	Shift top bit into Cf
4534  0C0E C9           	ret		;0c0e	Return
4535  0C0F
4536  0C0F              l0c0fh:
4537  0C0F D9           	exx		;0c0f
4538  0C10 79           	ld a,c		;0c10	Compare top bytes of mantissa
4539  0C11 B8           	cp b		;0c11
4540  0C12 20 01        	jr nz,l0c15h	;0c12
4541  0C14 D7           	rst 10h		;0c14	Compare lower two bytes if top bytes equal
4542  0C15              			;	(Call CMP_HL_DE)
4543  0C15              l0c15h:
4544  0C15 D9           	exx		;0c15
4545  0C16 C9           	ret		;0c16	Return
4546  0C17
4547  0C17
4548  0C17              ; 'ADD TWO FLOATING POINT NUMBERS (cont.)'
4549  0C17              ; ========================================
4550  0C17              ; Adds number in DE' B' DE to HL' C' HL. HL' C' HL must be larger than
4551  0C17              ; DE' B' DE.
4552  0C17
4553  0C17              ; IX Offset	-5	-4	-3	-2	-1
4554  0C17              ; ---------------------------------------------------
4555  0C17              ;		E'	D'	B'	E	D
4556  0C17              ; ---------------------------------------------------
4557  0C17              ;		24 bit mantissa	(MSB)	Exp	Sign
4558  0C17
4559  0C17              ; IX Offset	-10	-9	-8	-7	-6
4560  0C17              ; ---------------------------------------------------
4561  0C17              ;		L'	H'	C'	L	H
4562  0C17              ; ---------------------------------------------------
4563  0C17              ;		24 bit mantissa	(MSB)	Exp	Sign
4564  0C17
4565  0C17              ;; FP_ADD_DO
4566  0C17              l0c17h:
4567  0C17 7D           	ld a,l		;0c17
4568  0C18 93           	sub e		;0c18	A = L - E
4569  0C19 28 0E        	jr z,l0c29h	;0c19	Jump forward if exponents already equal
4570  0C1B
4571  0C1B FE 18        	cp 24		;0c1b
4572  0C1D D0           	ret nc		;0c1d	If L - E >= 24, return
4573  0C1E              			;	(DE' B' DE is too small to affect HL' C' HL)
4574  0C1E
4575  0C1E              ; Make exponents equal
4576  0C1E
4577  0C1E D9           	exx		;0c1e
4578  0C1F              l0c1fh:
4579  0C1F CB 38        	srl b		;0c1f	Shift mantissa (DE' B') right
4580  0C21 CB 1A        	rr d		;0c21
4581  0C23 CB 1B        	rr e		;0c23
4582  0C25 3D           	dec a		;0c25	Loop A times
4583  0C26 20 F7        	jr nz,l0c1fh	;0c26
4584  0C28
4585  0C28 D9           	exx		;0c28
4586  0C29
4587  0C29              l0c29h:
4588  0C29 1E 00        	ld e,000h	;0c29	Clear
4589  0C2B 7C           	ld a,h		;0c2b	A = XOR both sign bits
4590  0C2C AA           	xor d		;0c2c
4591  0C2D
4592  0C2D FA 46 0C     	jp m,l0c46h	;0c2d	Signs different
4593  0C30
4594  0C30 D9           	exx		;0c30	HL' C' = HL' C' + DE' B'
4595  0C31 19           	add hl,de	;0c31
4596  0C32 79           	ld a,c		;0c32
4597  0C33 88           	adc a,b		;0c33
4598  0C34 4F           	ld c,a		;0c34
4599  0C35              l0c35h:
4600  0C35 30 07        	jr nc,l0c3eh	;0c35	If carry, rotate mantissa right to
4601  0C37 CB 19        	rr c		;0c37	include the carry bit.
4602  0C39 CB 1C        	rr h		;0c39
4603  0C3B CB 1D        	rr l		;0c3b
4604  0C3D 37           	scf		;0c3d	Clear carry flag.
4605  0C3E              l0c3eh:
4606  0C3E D9           	exx		;0c3e
4607  0C3F
4608  0C3F              ; Multiply with Cf and return
4609  0C3F
4610  0C3F              ; 'MULTIPLY FLOATING POINT NUMBER WITH 2^(E+Cf)'
4611  0C3F              ; ==============================================
4612  0C3F              ; Multiplies floating point number in HL' C' HL with 2^(E+Cf)
4613  0C3F
4614  0C3F              ; Parameters:
4615  0C3F              ;	E, Cf: Number to multiply with
4616  0C3F              ;	HL' C' HL: Floating point number
4617  0C3F              ; Return:
4618  0C3F              ;	HL' C' HL: Result
4619  0C3F
4620  0C3F              ;; FP_MUL_EXP
4621  0C3F              l0c3fh:
4622  0C3F 7D           	ld a,l		;0c3f	A = L + E + Cf
4623  0C40 8B           	adc a,e		;0c40
4624  0C41              l0c41h:
4625  0C41 EA 61 0C     	jp pe,l0c61h	;0c41	Jump to CORRECT_EXP_OVERFLOW if exponent
4626  0C44              			;	overflowed...
4627  0C44 6F           	ld l,a		;0c44	...else load A into L and return
4628  0C45 C9           	ret		;0c45
4629  0C46
4630  0C46              l0c46h:
4631  0C46 D9           	exx			;0c46	d9
4632  0C47 ED 52        	sbc hl,de		;0c47	ed 52 	  R
4633  0C49 79           	ld a,c			;0c49	79 	y
4634  0C4A 98           	sbc a,b			;0c4a	98
4635  0C4B 4F           	ld c,a			;0c4b	4f 	O
4636  0C4C
4637  0C4C              ; 'CORRECT EXPONENT'
4638  0C4C              ; ==================
4639  0C4C              ; This function removes any leading zeros in the mantissa and corrects
4640  0C4C              ; the exponent.
4641  0C4C
4642  0C4C              ; It is always called with the C' HL' register set selected.
4643  0C4C
4644  0C4C              ; Parameters:
4645  0C4C              ;	HL C' HL': Input floating point number
4646  0C4C              ; Returns:
4647  0C4C              ;	HL C' HL': Corrected floating point number.
4648  0C4C
4649  0C4C              ;; CORRECT_EXP
4650  0C4C              l0c4ch:
4651  0C4C 06 18        	ld b,018h	;0c4c	Load 24 into B'
4652  0C4E AF           	xor a		;0c4e	Clear A
4653  0C4F
4654  0C4F 0C           	inc c		;0c4f	Set S flag for C'
4655  0C50 0D           	dec c		;0c50
4656  0C51              l0c51h:
4657  0C51 FA 5D 0C     	jp m,l0c5dh	;0c51	Break from loop top bit of C' HL' set
4658  0C54
4659  0C54 3D           	dec a		;0c54	Decrement A
4660  0C55
4661  0C55 29           	add hl,hl	;0c55	Shift C' HL' left
4662  0C56 CB 11        	rl c		;0c56
4663  0C58
4664  0C58 10 F7        	djnz l0c51h	;0c58	Loop
4665  0C5A
4666  0C5A              ; all 24 bits of C' HL' are zero.
4667  0C5A
4668  0C5A              ;; CORRECT_EXP_ZERO
4669  0C5A              l0c5ah:
4670  0C5A 2E 80        	ld l,080h	;0c5a	Set exponent to -128
4671  0C5C C9           	ret		;0c5c	Return
4672  0C5D
4673  0C5D              l0c5dh:
4674  0C5D D9           	exx		;0c5d
4675  0C5E 85           	add a,l		;0c5e	Add L to A
4676  0C5F 18 E0        	jr l0c41h	;0c5f	Check for overflow.
4677  0C61
4678  0C61              ; Negative overflow in the exponent occured.
4679  0C61
4680  0C61              ;; CORRECT_EXP_OVERFLOW
4681  0C61              l0c61h:
4682  0C61 7C           	ld a,h		;0c61
4683  0C62 B7           	or a		;0c62
4684  0C63 F2 58 06     	jp p,l0658h	;0c63	Jump to "HOW?" error if number was positive...
4685  0C66 18 F2        	jr l0c5ah	;0c66	...else jump to CORRECT_EXP_ZERO
4686  0C68
4687  0C68              ; 'FETCH TWO FLOATING POINT NUMBERS FROM STACK'
4688  0C68              ; =============================================
4689  0C68              ; Fetches two floating point number from the top of the arithmetic stack and
4690  0C68              ; stores them HL' C' HL and DE' B' DE registers. Does not decrement IX.
4691  0C68
4692  0C68              ; Returns:
4693  0C68              ;	A: 80h
4694  0C68              ;	DE' B' DE: First floating point number
4695  0C68              ;	HL' C' HL: Second floating point number
4696  0C68              ;	Zf: Set if second number is 0.
4697  0C68
4698  0C68              ; IX Offset	-5	-4	-3	-2	-1
4699  0C68              ; ---------------------------------------------------
4700  0C68              ;		E'	D'	B'	E	D
4701  0C68              ; ---------------------------------------------------
4702  0C68              ;		24 bit mantissa	(MSB)	Exp	Sign
4703  0C68
4704  0C68              ; IX Offset	-10	-9	-8	-7	-6
4705  0C68              ; ---------------------------------------------------
4706  0C68              ;		L'	H'	C'	L	H
4707  0C68              ; ---------------------------------------------------
4708  0C68              ;		24 bit mantissa	(MSB)	Exp	Sign
4709  0C68
4710  0C68              ;; FETCH_TWO_FP
4711  0C68              l0c68h:
4712  0C68 E1           	pop hl			;0c68
4713  0C69 D5           	push de			;0c69	Store DE and HL on stack
4714  0C6A E5           	push hl			;0c6a
4715  0C6B
4716  0C6B DD 56 FF     	ld d,(ix-1)		;0c6b
4717  0C6E DD 5E FE     	ld e,(ix-2)		;0c6e
4718  0C71 DD 66 FA     	ld h,(ix-6)		;0c71
4719  0C74 DD 6E F9     	ld l,(ix-7)		;0c74
4720  0C77 D9           	exx			;0c77
4721  0C78 DD 5E FB     	ld e,(ix-5)		;0c78
4722  0C7B DD 56 FC     	ld d,(ix-4)		;0c7b
4723  0C7E DD 46 FD     	ld b,(ix-3)		;0c7e
4724  0C81              l0c81h:
4725  0C81 DD 6E F6     	ld l,(ix-10)		;0c81
4726  0C84 DD 66 F7     	ld h,(ix-9)		;0c84
4727  0C87 DD 4E F8     	ld c,(ix-8)		;0c87
4728  0C8A D9           	exx			;0c8a
4729  0C8B
4730  0C8B 3E 80        	ld a,080h		;0c8b	Is second number equal to zero?
4731  0C8D BD           	cp l			;0c8d
4732  0C8E
4733  0C8E C9           	ret			;0c8e 	Return
4734  0C8F
4735  0C8F              ; 'RANDOM'
4736  0C8F              ; ========
4737  0C8F              ; "RND" BASIC command.
4738  0C8F              ;
4739  0C8F              ; This pseudo-random number generator pushes a random floating point number
4740  0C8F              ; on the arithmetic stack.
4741  0C8F
4742  0C8F              ;; RND
4743  0C8F              l0c8fh:
4744  0C8F D5           	push de		;0c8f	Save DE on stack
4745  0C90
4746  0C90 D9           	exx		;0c90
4747  0C91
4748  0C91 21 A7 2A     	ld hl,02aa7h	;0c91	Load RND_SEED address into HL'
4749  0C94 E5           	push hl		;0c94	Save HL' on stack
4750  0C95
4751  0C95 5E           	ld e,(hl)	;0c95	Load contents of RND_SEED into DE' B'
4752  0C96 23           	inc hl		;0c96
4753  0C97 56           	ld d,(hl)	;0c97
4754  0C98 23           	inc hl		;0c98
4755  0C99 46           	ld b,(hl)	;0c99
4756  0C9A
4757  0C9A D9           	exx		;0c9a
4758  0C9B
4759  0C9B              			;	Clear HL' C' HL
4760  0C9B
4761  0C9B CD 48 02     	call l0248h	;0c9b	Call CLEAR_CX_HLX_B6
4762  0C9E EF           	rst 28h		;0c9e	Call CLEAR_HL
4763  0C9F
4764  0C9F 0E 03        	ld c,003h	;0c9f	Load 03h into C
4765  0CA1              l0ca1h:
4766  0CA1 06 08        	ld b,008h	;0ca1	Load 8 into B
4767  0CA3 56           	ld d,(hl)	;0ca3	Load (HL) into D
4768  0CA4
4769  0CA4              l0ca4h:
4770  0CA4 D9           	exx		;0ca4
4771  0CA5 29           	add hl,hl	;0ca5	Rotate HL' C' left
4772  0CA6 CB 11        	rl c		;0ca6
4773  0CA8 D9           	exx		;0ca8
4774  0CA9
4775  0CA9 CB 12        	rl d		;0ca9	Rotate D left
4776  0CAB 30 06        	jr nc,l0cb3h	;0cab	Add DE' B' if top bit of D is set...
4777  0CAD
4778  0CAD D9           	exx		;0cad
4779  0CAE 19           	add hl,de	;0cae   HL' C' = HL' C' + DE' B'
4780  0CAF 79           	ld a,c		;0caf
4781  0CB0 88           	adc a,b		;0cb0
4782  0CB1 4F           	ld c,a		;0cb1
4783  0CB2 D9           	exx		;0cb2
4784  0CB3
4785  0CB3              l0cb3h:
4786  0CB3 10 EF        	djnz l0ca4h	;0cb3	Loop 8 times
4787  0CB5
4788  0CB5 23           	inc hl		;0cb5	Increment HL
4789  0CB6
4790  0CB6 0D           	dec c		;0cb6	Decrement C
4791  0CB7 20 E8        	jr nz,l0ca1h	;0cb7	Loop 3 times
4792  0CB9
4793  0CB9 EF           	rst 28h		;0cb9	Call CLEAR_HL
4794  0CBA
4795  0CBA D9           	exx		;0cba
4796  0CBB D1           	pop de		;0cbb	Restore RND_SEED address from stack into DE'
4797  0CBC
4798  0CBC 7D           	ld a,l		;0cbc	L' = L' + 65h
4799  0CBD C6 65        	add a,065h	;0cbd	(RND_SEED) = L'
4800  0CBF 12           	ld (de),a	;0cbf
4801  0CC0 13           	inc de		;0cc0	Increment DE'
4802  0CC1 6F           	ld l,a		;0cc1
4803  0CC2
4804  0CC2 7C           	ld a,h		;0cc2	H' = H' + b0h + Cf
4805  0CC3 CE B0        	adc a,0b0h	;0cc3	(RND_SEED+1) = H'
4806  0CC5 12           	ld (de),a	;0cc5
4807  0CC6 13           	inc de		;0cc6	Increment DE'
4808  0CC7 67           	ld h,a		;0cc7
4809  0CC8
4810  0CC8 79           	ld a,c		;0cc8	C' + 05h + Cf
4811  0CC9 CE 05        	adc a,005h	;0cc9	(RND_SEED+2) = C'
4812  0CCB 12           	ld (de),a	;0ccb
4813  0CCC 4F           	ld c,a		;0ccc
4814  0CCD
4815  0CCD CD 14 09     	call l0914h	;0ccd	Call CORRECT_EXP_ADD_IX_10
4816  0CD0 C3 6D 0B     	jp l0b6dh	;0cd0	Jump to STORE_ARITHM_RET
4817  0CD3
4818  0CD3              ; 'CONVERT STRING TO AN INTEGER'
4819  0CD3              ; ==============================
4820  0CD3              ; Converts string at DE into an integer. String must start with a numeral.
4821  0CD3
4822  0CD3              ; Parameters:
4823  0CD3              ;	DE: Pointer to the string to be converted.
4824  0CD3              ; Returns:
4825  0CD3              ;	HL: Converted integer or 0 on error.
4826  0CD3              ;	Zf: Set on error or clears on success.
4827  0CD3              ;	DE: First character after the converted number.
4828  0CD3
4829  0CD3              ;; STRING_TO_INT
4830  0CD3              l0cd3h:
4831  0CD3 EF           	rst 28h		;0cd3	Call CLEAR_HL
4832  0CD4 CD 05 01     	call l0105h	;0cd4	Call EAT_SPACE
4833  0CD7
4834  0CD7 CD 72 01     	call l0172h	;0cd7	Check if the next character is a number
4835  0CDA              			;	(call CHAR_TO_INT)
4836  0CDA
4837  0CDA 38 07        	jr c,l0ce3h	;0cda	If it's not, jump forward
4838  0CDC
4839  0CDC 1B           	dec de		;0cdc	Decrement DE (step back to character used for
4840  0CDD              			;	CHAR_TO_INT)
4841  0CDD
4842  0CDD              			;	Convert the string at DE to integer in HL.
4843  0CDD
4844  0CDD CD A2 01     	call l01a2h	;0cdd	Call STRING_TO_FP
4845  0CE0 CD 6D 0A     	call l0a6dh	;0ce0	Call FP_TO_INT
4846  0CE3              l0ce3h:
4847  0CE3 7C           	ld a,h		;0ce3	Check if HL contains 0 (either the number
4848  0CE4 B5           	or l		;0ce4	read is 0 or the conversion failed)
4849  0CE5
4850  0CE5 C9           	ret		;0ce5	Return
4851  0CE6
4852  0CE6              ; 'READ A KEY FROM KEYBOARD'
4853  0CE6              ; ==========================
4854  0CE6              ; Waits for a key press on the keyboard and returns the code of the pressed
4855  0CE6              ; key in A (for most keys this means the ASCII code of the character printed
4856  0CE6              ; on the key. Special keys return their own scan code).
4857  0CE6
4858  0CE6              ; A press to the "list" key causes a jump to the LIST function.
4859  0CE6
4860  0CE6              ; A press to the "break" key causes a jump to the BREAK function.
4861  0CE6
4862  0CE6              ; Returns:
4863  0CE6              ;	A: Code of the key pressed
4864  0CE6              ; Destroys:
4865  0CE6              ;	Flags
4866  0CE6
4867  0CE6              ; A key had been seen as released. Key code in A. Address in DE.
4868  0CE6
4869  0CE6              ; Clear the key's position in KEY_DIFF (HL), if this key has been recently
4870  0CE6              ; pressed.
4871  0CE6
4872  0CE6              ;; KEY_RELEASED
4873  0CE6              l0ce6h:
4874  0CE6 BC           	cp h		;0ce6	Compare A with H...
4875  0CE7 20 02        	jr nz,l0cebh	;0ce7	...and jump forward if not equal
4876  0CE9
4877  0CE9 26 00        	ld h,000h	;0ce9	...else reset H
4878  0CEB              l0cebh:
4879  0CEB BD           	cp l		;0ceb	Compare A with L...
4880  0CEC 20 02        	jr nz,l0cf0h	;0cec	...and jump to KEY_READ_NEXT if not equal
4881  0CEE
4882  0CEE 2E 00        	ld l,000h	;0cee	...else reset L
4883  0CF0
4884  0CF0              ; Scan the next key, or start from the beginning if on the last key.
4885  0CF0
4886  0CF0              ;; KEY_READ_NEXT
4887  0CF0              l0cf0h:
4888  0CF0
4889  0CF0 1D           	dec e		;0cf0	Decrement E, move to the next key
4890  0CF1 20 0B        	jr nz,l0cfeh	;0cf1	Jump to KEY_READ if more keys to read
4891  0CF3 18 06        	jr l0cfbh	;0cf3	Jump to KEY_RESTART if on the last key.
4892  0CF5
4893  0CF5              ; Entry point into the function
4894  0CF5
4895  0CF5              ;; KEY
4896  0CF5              l0cf5h:
4897  0CF5 D9           	exx		;0cf5	Save BC, DE and HL registers
4898  0CF6
4899  0CF6 2A A5 2A     	ld hl,(02aa5h)	;0cf6	Load KEY_DIFF into HL
4900  0CF9
4901  0CF9 0E 0E        	ld c,00eh	;0cf9	Load 0eh into C (speed of the "repeat" key)
4902  0CFB
4903  0CFB              ; Restart scanning from the beginning.
4904  0CFB
4905  0CFB              ;; KEY_RESTART
4906  0CFB              l0cfbh:
4907  0CFB 11 34 20     	ld de,02034h	;0cfb	Load 2034h into DE
4908  0CFE              			;	This is the address of the last key on the
4909  0CFE              			;	keyboard except for "shift".
4910  0CFE
4911  0CFE              ;; KEY_READ
4912  0CFE              l0cfeh:
4913  0CFE 1A           	ld a,(de)	;0cfe	Load (DE) into A
4914  0CFF 0F           	rrca		;0cff	Rotate A right through carry flag
4915  0D00 7B           	ld a,e		;0d00	Load E (code of the current key) into A
4916  0D01
4917  0D01 38 E3        	jr c,l0ce6h	;0d01	Jump to KEY_RELEASED if low bit of A is set.
4918  0D03
4919  0D03 FE 32        	cp 032h		;0d03	Compare A with 32h...
4920  0D05 20 08        	jr nz,l0d0fh	;0d05	...and jump to KEY_PRESSED, if not equal
4921  0D07
4922  0D07              ; "rept" key is pressed. This key is special because it causes the last
4923  0D07              ; keypress to be repeated.
4924  0D07
4925  0D07 0D           	dec c		;0d07	Decrement C...
4926  0D08 20 DC        	jr nz,l0ce6h	;0d08	...and jump to KEY_RELEASED if not zero
4927  0D0A
4928  0D0A 3A B4 2B     	ld a,(02bb4h)	;0d0a	Load LAST_KEY into A
4929  0D0D 18 45        	jr l0d54h	;0d0d	Jump to KEY_END
4930  0D0F
4931  0D0F              ; A key had been seen as pressed. Key code in A. Address in DE.
4932  0D0F
4933  0D0F              ;; KEY_PRESSED
4934  0D0F              l0d0fh:
4935  0D0F BC           	cp h		;0d0f	Compare A with H...
4936  0D10 28 DE        	jr z,l0cf0h	;0d10	...and jump to KEY_READ_NEXT if equal
4937  0D12
4938  0D12 BD           	cp l		;0d12	Compare A with L...
4939  0D13 28 DB        	jr z,l0cf0h	;0d13	...and jump to KEY_READ_NEXT if equal
4940  0D15
4941  0D15              ; Wait for 256 cycles for key release (to filter out switch bounces)
4942  0D15
4943  0D15 06 00        	ld b,000h	;0d15	Clear B
4944  0D17              l0d17h:
4945  0D17 D7           	rst 10h		;0d17	Call CMP_HL_DE (pause)
4946  0D18
4947  0D18 1A           	ld a,(de)	;0d18	Load (DE) into A
4948  0D19 0F           	rrca		;0d19	Rotate A right through carry flag...
4949  0D1A 38 CA        	jr c,l0ce6h	;0d1a	...and jump to KEY_RELEASED if carry set.
4950  0D1C
4951  0D1C 10 F9        	djnz l0d17h	;0d1c	Loop 256 times
4952  0D1E
4953  0D1E              ; Fill in an empty position in KEY_DIFF (HL)
4954  0D1E
4955  0D1E 7C           	ld a,h		;0d1e	Load H into A
4956  0D1F B7           	or a		;0d1f	Set Z flag...
4957  0D20 20 03        	jr nz,l0d25h	;0d20	...and jump forward if A not zero
4958  0D22
4959  0D22 63           	ld h,e		;0d22	Load E into H
4960  0D23 18 05        	jr l0d2ah	;0d23	Jump forward
4961  0D25
4962  0D25              l0d25h:
4963  0D25 7D           	ld a,l		;0d25	Load L into A
4964  0D26 B7           	or a		;0d26	Set Z flag...
4965  0D27 20 D5        	jr nz,l0cfeh	;0d27	...and jump to KEY_READ if A not zero
4966  0D29 6B           	ld l,e		;0d29	Load E into L
4967  0D2A
4968  0D2A              ; A valid key press has been detected. Check for special keys, add proper
4969  0D2A              ; ASCII offsets and look keys up in the shift table. DE holds the key's
4970  0D2A              ; memory address.
4971  0D2A
4972  0D2A              ;; KEY_COMPUTE
4973  0D2A              l0d2ah:
4974  0D2A 22 A5 2A     	ld (02aa5h),hl	;0d2a	Load HL into KEY_DIFF
4975  0D2D EF           	rst 28h		;0d2d	Call CLEAR_HL
4976  0D2E 7B           	ld a,e		;0d2e	Load E into A
4977  0D2F
4978  0D2F              ; Check for special keys, that directly invoke functions in the BASIC
4979  0D2F              ; interpreter.
4980  0D2F
4981  0D2F FE 34        	cp 034h		;0d2f	Compare A with 34h ("list" key) and...
4982  0D31 CA 61 04     	jp z,l0461h	;0d31	...jump to LIST_KEY if equal
4983  0D34
4984  0D34 FE 31        	cp 031h		;0d34	Compare A with 31h ("break" key) and...
4985  0D36 CA 05 03     	jp z,l0305h	;0d36	...jump to BREAK if equal
4986  0D39
4987  0D39 FE 1B        	cp 01bh		;0d39	Compare A with 1bh ("up" key).
4988  0D3B 21 35 20     	ld hl,02035h	;0d3b	Load 2035h into HL ("shift" key address)
4989  0D3E 38 19        	jr c,l0d59h	;0d3e	Jump to KEY_END_ALPHA if A less than 1bh
4990  0D40
4991  0D40 FE 1F        	cp 01fh		;0d40	Compare A with 1fh ("space" key address)
4992  0D42 38 10        	jr c,l0d54h	;0d42	Jump to KEY_END if A is less than 1fh
4993  0D44              			;	("up", "down", "left" or "right" keys)
4994  0D44
4995  0D44              ; Code for numerical and symbol keys, that are looked up in KEY_SHIFT_SYM_TABLE
4996  0D44
4997  0D44 D6 1F        	sub 01fh	;0d44	Subtract 1fh from A
4998  0D46 CB 1E        	rr (hl)		;0d46	Rotate (HL) right
4999  0D48              			;	Since HL contains the address of the "shift"
5000  0D48              			;	key, this moves that status of the "shift" key
5001  0D48              			;	into carry flag.
5002  0D48
5003  0D48 17           	rla		;0d48	Rotate A left.
5004  0D49              			;	A = A * 2 + 0 (if shift is pressed)
5005  0D49              			;	A = A * 2 + 1 (if shirt is released)
5006  0D49
5007  0D49 4F           	ld c,a		;0d49	Load A into C
5008  0D4A
5009  0D4A 21 70 0D     	ld hl,l0d70h	;0d4a	Load KEY_SHIFT_SYM_TABLE address into HL
5010  0D4D 09           	add hl,bc	;0d4d	Add BC to HL
5011  0D4E
5012  0D4E              ; This seeds the random generator with the value of the R register after
5013  0D4E              ; some key presses.
5014  0D4E
5015  0D4E ED 5F        	ld a,r		;0d4e	Load R into A
5016  0D50 32 A8 2A     	ld (02aa8h),a	;0d50	Load A into 2nd byte of RND_SEED
5017  0D53
5018  0D53 7E           	ld a,(hl)	;0d53	Load a character from the symbol table into A
5019  0D54
5020  0D54              ; The code of the pressed key is in A. Store in LAST_KEY and return.
5021  0D54
5022  0D54              ;; KEY_END
5023  0D54              l0d54h:
5024  0D54 32 B4 2B     	ld (02bb4h),a	;0d54	Load A into LAST_KEY
5025  0D57 D9           	exx		;0d57	Restore BC, DE and HL registers.
5026  0D58 C9           	ret		;0d58	Return
5027  0D59
5028  0D59              ; Pressed key is a letter. Add proper ASCII offset, check shift mapping in
5029  0D59              ; table and return.
5030  0D59
5031  0D59              ;; KEY_END_ALPHA
5032  0D59              l0d59h:
5033  0D59 C6 40        	add a,040h	;0d59	Add 40h to A (ASCII offset)
5034  0D5B CB 1E        	rr (hl)		;0d5b	Rotate (HL) right...
5035  0D5D              			;	Since HL contains the address of the "shift"
5036  0D5D              			;	key, this moves that status of the "shift" key
5037  0D5D              			;	into carry flag.
5038  0D5D 38 F5        	jr c,l0d54h	;0d5d	...and jump to KEY_END if shift key not pressed.
5039  0D5F
5040  0D5F 21 94 0D     	ld hl,l0d94h	;0d5f	Load KEY_SHIFT_YU_TABLE address into HL
5041  0D62 01 5B 04     	ld bc,l045bh	;0d62	Load 4 into B and 5bh into C
5042  0D65
5043  0D65              ; B holds the length of the KEY_SHIFT_YU_TABLE, C holds the first ASCII code
5044  0D65              ; of the Yugoslavian character set.
5045  0D65
5046  0D65              l0d65h:
5047  0D65 BE           	cp (hl)		;0d65	Compare (HL) with A...
5048  0D66 28 05        	jr z,l0d6dh	;0d66	Jump forward if equal
5049  0D68 23           	inc hl		;0d68	Increment HL
5050  0D69 0C           	inc c		;0d69	Increment C
5051  0D6A 10 F9        	djnz l0d65h	;0d6a	Loop 4 times
5052  0D6C
5053  0D6C              ; If loops ends here, a dummy load instruction is executed. Else value in C
5054  0D6C              ; (a different character) is stored into A
5055  0D6C
5056  0D6C 0E           	db 00eh		;0d6c	These two bytes also form the instruction
5057  0D6D              l0d6dh:
5058  0D6D 79           	ld a,c		;0d6d	"ld c,079h"
5059  0D6E
5060  0D6E 18 E4        	jr l0d54h	;0d6e	Jump to KEY_END
5061  0D70
5062  0D70              ; 'KEYBOARD TABLES'
5063  0D70              ; =================
5064  0D70
5065  0D70              ; This table contains characters, that are obtained by pressing keys with
5066  0D70              ; addresses from 1fh ("space") to 30h ("return").
5067  0D70
5068  0D70              ; The first character in table is obtained by pressing shift-key and the
5069  0D70              ; second is obtained by pressing the key alone.
5070  0D70
5071  0D70              ;; KEY_SHIFT_SYM_TABLE
5072  0D70              l0d70h:
5073  0D70 20 20        	db	' ',	' '	; 1fh
5074  0D72 5F 30        	db	'_',	'0'	; 20h
5075  0D74 21 31        	db	'!',	'1'	; 21h
5076  0D76 22 32        	db	'"',	'2'	; 22h
5077  0D78 23 33        	db	'#',	'3'	; 23h
5078  0D7A 24 34        	db	'$',	'4'	; 24h
5079  0D7C 25 35        	db	'%',	'5'	; 25h
5080  0D7E 26 36        	db	'&',	'6'	; 26h
5081  0D80 BF 37        	db	0bfh,	'7'	; 27h (bfh is block graphics character)
5082  0D82 28 38        	db	'(',	'8'	; 28h
5083  0D84 29 39        	db	')',	'9'	; 29h
5084  0D86 2B 3B        	db	'+',	';'	; 2ah
5085  0D88 2A 3A        	db	'*',	':'	; 2bh
5086  0D8A 3C 2C        	db	'<',	','	; 2ch
5087  0D8C 2D 3D        	db	'-',	'='	; 2dh
5088  0D8E 3E 2E        	db	'>',	'.'	; 2eh
5089  0D90 3F 2F        	db	'?',	'/'	; 2fh
5090  0D92 0D 0D        	db	00dh,	00dh	; 30h (CR)
5091  0D94
5092  0D94              ; This table contains characters, that are mapped to Yugoslavian characters
5093  0D94              ; when the shift-key is pressed.
5094  0D94
5095  0D94              ; It also serves as the KEY_SHIFT_SYM_TABLE entries for "break" and "repeat"
5096  0D94              ; keys, which have special functions and are never looked up here.
5097  0D94
5098  0D94              ;; KEY_SHIFT_YU_TABLE
5099  0D94              l0d94h:
5100  0D94 58           	db	'X' 		; C with caron		31h
5101  0D95 43           	db 	'C'		; C with acute
5102  0D96 5A           	db 	'Z'		; Z with caron		32h
5103  0D97 53           	db	'S'		; S with caron
5104  0D98
5105  0D98              ; KEY_SHIFT_SYM_TABLE entry for the "delete" key
5106  0D98
5107  0D98 0C 00        	db	0ch,	00h	; 33h (clear screen - shift delete, delete)
5108  0D9A
5109  0D9A              ; 'MEM'
5110  0D9A              ; =====
5111  0D9A              ; "MEM" BASIC function
5112  0D9A
5113  0D9A              ;; MEM
5114  0D9A              l0d9ah:
5115  0D9A CD 83 01     	call l0183h	;0d9a	Call FREE_MEM
5116  0D9D
5117  0D9D ED 4B 99 2A  	ld bc,(02a99h)	;0d9d	Subtract array length from
5118  0DA1 ED 42        	sbc hl,bc	;0da1
5119  0DA3
5120  0DA3 18 1A        	jr l0dbfh	;0da3	Jump to INT_TO_FP and return
5121  0DA5
5122  0DA5              ; 'WORD'
5123  0DA5              ; ======
5124  0DA5              ; "WORD" BASIC function
5125  0DA5
5126  0DA5              ;; WORD
5127  0DA5              l0da5h:
5128  0DA5 4E           	ld c,(hl)	;0da5	Load word at (HL) into HL
5129  0DA6 23           	inc hl		;0da6
5130  0DA7 66           	ld h,(hl)	;0da7
5131  0DA8 69           	ld l,c		;0da8
5132  0DA9
5133  0DA9 18 14        	jr l0dbfh	;0da9	Jump to INT_TO_FP and return.
5134  0DAB
5135  0DAB              ; 'KEY'
5136  0DAB              ; =====
5137  0DAB              ; "KEY" BASIC function
5138  0DAB
5139  0DAB              ;; KEY_CMD
5140  0DAB              l0dabh:
5141  0DAB 7C           	ld a,h		;0dab	Check if HL = 0
5142  0DAC B5           	or l		;0dac
5143  0DAD 20 05        	jr nz,l0db4h	;0dad	If HL = 0 (no argument),
5144  0DAF              			;	read which key has been pressed and return
5145  0DAF
5146  0DAF CD F5 0C     	call l0cf5h	;0daf	Call KEY
5147  0DB2 18 06        	jr l0dbah	;0db2	Jump to KEY_CMD_END
5148  0DB4
5149  0DB4              l0db4h:
5150  0DB4 CB EC        	set 5,h		;0db4	HL = HL | 2000h
5151  0DB6
5152  0DB6 7E           	ld a,(hl)	;0db6	Load value from keyboard into A
5153  0DB7 2F           	cpl		;0db7	Complement A
5154  0DB8              l0db8h:
5155  0DB8 E6 01        	and 001h	;0db8	Filter out LSB.
5156  0DBA
5157  0DBA              ;; KEY_CMD_END
5158  0DBA              l0dbah:
5159  0DBA 6F           	ld l,a		;0dba	Move A into L.
5160  0DBB 3E           	db 03eh		;0dbb	Dummy "ld a,nn" (skip next instruction -
5161  0DBC              			;	clear H and jump to INT_TO_FP)
5162  0DBC
5163  0DBC              ; 'BYTE'
5164  0DBC              ; ======
5165  0DBC              ; "BYTE" BASIC function
5166  0DBC
5167  0DBC              ;; BYTE_FUNC
5168  0DBC              l0dbch:
5169  0DBC 6E           	ld l,(hl)	;0dbc	Load byte at (HL) into HL
5170  0DBD 26 00        	ld h,000h	;0dbd
5171  0DBF
5172  0DBF              l0dbfh:
5173  0DBF C3 BC 0A     	jp l0abch	;0dbf	Jump to INT_TO_FP and return.
5174  0DC2
5175  0DC2              ;; EQ
5176  0DC2              l0dc2h:
5177  0DC2 CD FC 05     	call l05fch		;0dc2	cd fc 05
5178  0DC5 E5           	push hl			;0dc5	e5
5179  0DC6 DF           	rst 18h			;0dc6	df
5180  0DC7 2C           	inc l			;0dc7	2c 	,
5181  0DC8 00           	nop			;0dc8	00
5182  0DC9 CD FC 05     	call l05fch		;0dc9	cd fc 05
5183  0DCC C1           	pop bc			;0dcc	c1
5184  0DCD              l0dcdh:
5185  0DCD 0A           	ld a,(bc)			;0dcd	0a
5186  0DCE BE           	cp (hl)			;0dce	be
5187  0DCF 20 0B        	jr nz,l0ddch		;0dcf	20 0b
5188  0DD1 B7           	or a			;0dd1	b7
5189  0DD2 28 07        	jr z,l0ddbh		;0dd2	28 07 	(
5190  0DD4 23           	inc hl			;0dd4	23 	#
5191  0DD5 03           	inc bc			;0dd5	03
5192  0DD6 7D           	ld a,l			;0dd6	7d 	}
5193  0DD7 E6 0F        	and 00fh		;0dd7	e6 0f
5194  0DD9 20 F2        	jr nz,l0dcdh		;0dd9	20 f2
5195  0DDB
5196  0DDB              ; following lines from Diss_010.jpg
5197  0DDB              l0ddbh:
5198  0DDB 3E           	db 03eh			;0ddb
5199  0DDC              l0ddch:
5200  0DDC AF           	xor a			;0ddc	af 	>
5201  0DDD 18 D9        	jr l0db8h		;0ddd	18 d9
5202  0DDF              ;; HEX
5203  0DDF              l0ddfh:
5204  0DDF CD 65 01     	call l0165h	;0ddf	Test the first character
5205  0DE2              			;	(Call HEXCHAR_TO_INT_
5206  0DE2
5207  0DE2 38 14        	jr c,l0df8h	;0de2	Jump to HOW_RST_PUSH_DE if conversion failed
5208  0DE4
5209  0DE4 1B           	dec de		;0de4	Move DE back to the beginning
5210  0DE5
5211  0DE5 EF           	rst 28h		;0de5	Call CLEAR_HL
5212  0DE6
5213  0DE6              ;; HEX_LOOP
5214  0DE6              l0de6h:
5215  0DE6 CD 65 01     	call l0165h	;0de6	Call HEXCHAR_TO_INT
5216  0DE9
5217  0DE9 38 D4        	jr c,l0dbfh	;0de9	Jump to INT_TO_FP and return on end of hex
5218  0DEB              			; 	number (on first non-hex character)
5219  0DEB
5220  0DEB 07           	rlca		;0deb	A = A << 4
5221  0DEC 07           	rlca		;0dec
5222  0DED 07           	rlca		;0ded
5223  0DEE 07           	rlca		;0dee
5224  0DEF
5225  0DEF 01 E6 0D     	ld bc,l0de6h	;0def	Load HEX_LOOP address to the top of the
5226  0DF2 C5           	push bc		;0df2	stack
5227  0DF3
5228  0DF3              ; Shift four bits in A to HL
5229  0DF3
5230  0DF3              l0df3h:
5231  0DF3 06 04        	ld b,004h	;0df3
5232  0DF5              l0df5h:
5233  0DF5 07           	rlca		;0df5	HL A = HL A << 4
5234  0DF6 ED 6A        	adc hl,hl	;0df6
5235  0DF8              l0df8h:
5236  0DF8 DA 5A 06     	jp c,l065ah	;0df8	Jump to HOW_RST_PUSH_DE on overflow
5237  0DFB
5238  0DFB 10 F8        	djnz l0df5h	;0dfb	Loop
5239  0DFD
5240  0DFD C9           	ret		;0dfd	Jump to HEX_LOOP
5241  0DFE
5242  0DFE              ; 'WORD'
5243  0DFE              ; ======
5244  0DFE              ; "WORD" BASIC command.
5245  0DFE
5246  0DFE              l0dfeh:
5247  0DFE F6           	db 0f6h		;0dfe	Dummy "or nn"
5248  0DFF              			;	(skip next instruction, clear Zf)
5249  0DFF
5250  0DFF              ; 'BYTE'
5251  0DFF              ; ======
5252  0DFF              ; "BYTE" BASIC command.
5253  0DFF
5254  0DFF              ;; BYTE
5255  0DFF              l0dffh:
5256  0DFF AF           	xor a		;0dff	Set Zf
5257  0E00 F5           	push af		;0e00	Push flags on sack
5258  0E01
5259  0E01 CF           	rst 8		;0e01	Get address (call EVAL_INT_EXP)
5260  0E02 E5           	push hl		;0e02	Save address on stack.
5261  0E03
5262  0E03 CD 05 00     	call l0005h	;0e03	Get content (call EVAL_INT_EXP_NEXT)
5263  0E06
5264  0E06 E3           	ex (sp),hl	;0e06	HL = address
5265  0E07 C1           	pop bc		;0e07	BC = content
5266  0E08
5267  0E08 71           	ld (hl),c	;0e08	Load lower byte into (HL)
5268  0E09
5269  0E09 F1           	pop af		;0e09	Get flags from stack
5270  0E0A
5271  0E0A 28 02        	jr z,l0e0eh	;0e0a	If Zf not set, store upper byte into (HL+1)
5272  0E0C 23           	inc hl		;0e0c
5273  0E0D 70           	ld (hl),b	;0e0d
5274  0E0E              l0e0eh:
5275  0E0E F7           	rst 30h		;0e0e	f7
5276  0E0F
5277  0E0F              ; 'USR'
5278  0E0F              ; =====
5279  0E0F              ; "USR" BASIC function.
5280  0E0F
5281  0E0F              ;; USR
5282  0E0F              l0e0fh:
5283  0E0F D5           	push de		;0e0f	Save DE pointer on stack
5284  0E10 11 BD 0A     	ld de,l0abdh	;0e10	Load INT_TO_FP_2 address on stack
5285  0E13 D5           	push de		;0e13
5286  0E14 E9           	jp (hl)		;0e14	Jump to user function
5287  0E15              			;	(returns back to INT_TO_FP_2, which pushes
5288  0E15              			;	result to arithmetic stack and restores DE
5289  0E15              			;	pointer)
5290  0E15
5291  0E15              ;; CHR$
5292  0E15              l0e15h:
5293  0E15 B2           	or d			;0e15	b2
5294  0E16 7D           	ld a,l			;0e16	7d 	}
5295  0E17 C9           	ret			;0e17	c9
5296  0E18              ;; FOR
5297  0E18              l0e18h:
5298  0E18 CD 74 09     	call l0974h		;0e18	cd 74 09 	  t
5299  0E1B CD 30 07     	call l0730h		;0e1b	cd 30 07 	  0
5300  0E1E 22 A1 2A     	ld (02aa1h),hl		;0e1e	22 a1 2a 	"   *
5301  0E21 DF           	rst 18h			;0e21	df
5302  0E22 54           	ld d,h			;0e22	54 	T
5303  0E23 B2           	or d			;0e23	b2
5304  0E24 DF           	rst 18h			;0e24	df
5305  0E25 4F           	ld c,a			;0e25	4f 	O
5306  0E26 AF           	xor a			;0e26	af
5307  0E27 CF           	rst 8			;0e27	cf
5308  0E28 22 6E 2A     	ld (02a6eh),hl		;0e28	22 6e 2a 	" n *
5309  0E2B 2E D8        	ld l,0d8h		;0e2b	2e d8 	.
5310  0E2D C3 98 03     	jp l0398h		;0e2d	c3 98 03
5311  0E30
5312  0E30              ; 'SAVE'
5313  0E30              ; ======
5314  0E30              ; "SAVE" BASIC command.
5315  0E30
5316  0E30              ;; SAVE
5317  0E30              l0e30h:
5318  0E30 21 36 2C     	ld hl,02c36h	;0e32 	Load BASIC_START address into HL...
5319  0E33 E5           	push hl		;0e33	...and save it to stack
5320  0E34
5321  0E34 2A 38 2C     	ld hl,(02c38h)	;0e34	Load BASIC_END into HL
5322  0E37
5323  0E37 DF           	rst 18h		;0e37	Call READ_PAR
5324  0E38 0D           	db 00dh		;0e38	ASCII CR
5325  0E39 02           	db l0e3ch-$-1	;0e39
5326  0E3A
5327  0E3A 18 06        	jr l0e42h	;0e3a	There is no parameter on the rest of the line.
5328  0E3C              			;	Jump forward
5329  0E3C
5330  0E3C              ; This looks like the SAVE nnnn,nnnn variant of the command.
5331  0E3C
5332  0E3C              l0e3ch:
5333  0E3C CF           	rst 8		;0e3c	Call EVAL_INT_EXP
5334  0E3D
5335  0E3D E3           	ex (sp),hl	;0e3d	Replace BASIC_START address on the stack with
5336  0E3E              			;	the number from EVAL_INT_EXP
5337  0E3E CD 05 00     	call l0005h	;0e3e	Call EVAL_INT_EXP_NEXT
5338  0E41
5339  0E41 23           	inc hl		;0e41	Replace BASIC_END address in HL with the number
5340  0E42              			;	from EVAL_INT_EXP_NEXT + 1.
5341  0E42
5342  0E42              l0e42h:
5343  0E42 D1           	pop de		;0e42	...restore BASIC_START address into DE
5344  0E43              			;	(address of the first byte of the block to
5345  0E43              			;	save)
5346  0E43
5347  0E43 06 60        	ld b,060h	;0e43	Load 60h into B
5348  0E45 F3           	di		;0e45	Disable interrupts
5349  0E46
5350  0E46              ; Save 96 sync bytes (00h)
5351  0E46
5352  0E46              l0e46h:
5353  0E46 AF           	xor a		;0e46	Clear A
5354  0E47 CD 68 0E     	call l0e68h	;0e47	Call SAVE_BYTE
5355  0E4A 10 FA        	djnz l0e46h	;0e4a	Repeat 96 times
5356  0E4C
5357  0E4C              ; B = 0 and from now on holds the sum of all saved bytes.
5358  0E4C
5359  0E4C              ; Save start byte (a5h)
5360  0E4C
5361  0E4C 3E A5        	ld a,0a5h	;0e4c	Load a5h into A
5362  0E4E CD 68 0E     	call l0e68h	;0e4e	Call SAVE_BYTE
5363  0E51
5364  0E51 CD 62 0E     	call l0e62h	;0e51	Call SAVE_WORD
5365  0E54              			;	Saves DE (start address)
5366  0E54 CD 62 0E     	call l0e62h	;0e54	Call SAVE_WORD
5367  0E57              			;	Saves HL (end address)
5368  0E57
5369  0E57 2B           	dec hl		;0e57	Decrement HL
5370  0E58              			;	(address of the last byte of the block to save)
5371  0E58
5372  0E58              ; Save data (from DE to HL inclusive)
5373  0E58
5374  0E58              l0e58h:
5375  0E58 1A           	ld a,(de)	;0e58	Load byte at (DE) into A
5376  0E59 13           	inc de		;0e59	Increment DE
5377  0E5A CD 68 0E     	call l0e68h	;0e5a	Call SAVE_BYTE
5378  0E5D 30 F9        	jr nc,l0e58h	;0e5d	If DE <= HL then loop
5379  0E5F
5380  0E5F 78           	ld a,b		;0e5f	Load sum into A
5381  0E60 2F           	cpl		;0e60	Complement A (make checksum)
5382  0E61 5F           	ld e,a		;0e61	Load checksum into E
5383  0E62
5384  0E62              ; Save checksum and one garbage byte in D and return.
5385  0E62
5386  0E62              ; 'SAVE WORD'
5387  0E62              ; ===========
5388  0E62              ; This function saves one word (16 bits) to the audio cassette.
5389  0E62
5390  0E62              ; Parameters:
5391  0E62              ;	DE: word to be saved
5392  0E62              ; Returns:
5393  0E62              ;	HL: holds previous contents of DE
5394  0E62              ;	DE: holds previous contents of HL
5395  0E62              ;	B: B + sum of both saved bytes
5396  0E62              ; Destroys:
5397  0E62              ;	A
5398  0E62
5399  0E62              ;; SAVE_WORD
5400  0E62              l0e62h:
5401  0E62 EB           	ex de,hl	;0e62	Exchange contents of DE and HL registers.
5402  0E63 7D           	ld a,l		;0e63	Load L into A
5403  0E64 CD 68 0E     	call l0e68h	;0e64	Call SAVE_BYTE
5404  0E67
5405  0E67 7C           	ld a,h		;0e67	Load H into A
5406  0E68
5407  0E68              ; Save the second byte and return.
5408  0E68
5409  0E68              ; 'SAVE BYTE'
5410  0E68              ; ===========
5411  0E68              ; This function saves one byte to the audio cassette.
5412  0E68
5413  0E68              ; Parameters:
5414  0E68              ;	A: byte to be saved
5415  0E68              ; Returns:
5416  0E68              ;	B: B = B + A
5417  0E68              ;	flags: output of CMP_HL_DE
5418  0E68              ; Destroys:
5419  0E68              ;	A
5420  0E68
5421  0E68              ;; SAVE_BYTE
5422  0E68              l0e68h:
5423  0E68 D9           	exx		;0e68	Exchange BC,DE,HL with BC',DE',HL'
5424  0E69
5425  0E69 0E 10        	ld c,010h	;0e69	Load 16 into C
5426  0E6B 21 38 20     	ld hl,02038h	;0e6b	Load latch address (2038h) into HL
5427  0E6E
5428  0E6E              ;; SAVE_BYTE_LOOP
5429  0E6E              l0e6eh:
5430  0E6E CB 41        	bit 0,c		;0e6e	Test bit 0 of C
5431  0E70 28 05        	jr z,l0e77h	;0e70	If C even, always make an impulse on output...
5432  0E72 0F           	rrca		;0e72	...else rotate A right (stores LSB in C flag)
5433  0E73 06 64        	ld b,064h	;0e73	   load 100 into B
5434  0E75 30 0F        	jr nc,l0e86h	;0e75	   skip impulse if LSB not set
5435  0E77
5436  0E77              l0e77h:
5437  0E77 36 FC        	ld (hl),0fch	;0e77	Set output to high
5438  0E79 06 32        	ld b,032h	;0e79	Load 50 into B
5439  0E7B              l0e7bh:
5440  0E7B 10 FE        	djnz l0e7bh	;0e7b	Wait (approx. 650 T)
5441  0E7D 36 B8        	ld (hl),0b8h	;0e7d	Set output to low
5442  0E7F 06 32        	ld b,032h	;0e7f	Load 50 into B
5443  0E81              l0e81h:
5444  0E81 10 FE        	djnz l0e81h	;0e81	Wait (approx. 650 T)
5445  0E83 36 BC        	ld (hl),0bch	;0e83	Set output to zero
5446  0E85 04           	inc b		;0e85	Load 01h into B
5447  0E86              l0e86h:
5448  0E86 10 FE        	djnz l0e86h	;0e86	Wait (13 or 1300 T, depending whether
5449  0E88              			;	C was even or odd)
5450  0E88              l0e88h:
5451  0E88 10 FE        	djnz l0e88h	;0e88	Wait (approx. 3328 T)
5452  0E8A 0D           	dec c		;0e8a	Decrement C
5453  0E8B 20 E1        	jr nz,l0e6eh	;0e8b	Jump to SAVE_BYTE_LOOP
5454  0E8D
5455  0E8D              			;	BC = 0
5456  0E8D              			;	The following loop waits for 512 cycles
5457  0E8D              l0e8dh:
5458  0E8D 03           	inc bc		;0e8d	Increment BC
5459  0E8E CB 48        	bit 1,b		;0e8e	Test bit 1 of B...
5460  0E90 28 FB        	jr z,l0e8dh	;0e90	... and loop if not set.
5461  0E92
5462  0E92 D9           	exx		;0e92	Exchange BC,DE,HL with BC',DE',HL'
5463  0E93
5464  0E93              ; LOAD_BYTE function jumps here at the end
5465  0E93              l0e93h:
5466  0E93 80           	add a,b		;0e93	Add B to A
5467  0E94 47           	ld b,a		;0e94	B = A + B
5468  0E95 D7           	rst 10h		;0e95	Call CMP_HL_DE
5469  0E96
5470  0E96 C9           	ret		;0e96	Return
5471  0E97
5472  0E97
5473  0E97              ; 'OLD'
5474  0E97              ; =====
5475  0E97              ; "OLD" BASIC command.
5476  0E97
5477  0E97              ; Verifies saved data if there is a '?' character after the command.
5478  0E97
5479  0E97              ;; OLD
5480  0E97              l0e97h:
5481  0E97 DF           	rst 18h		;0e97	Call READ_PAR
5482  0E98 3F           	db '?' 		;0e98
5483  0E99 00           	db l0e9ah-$-1	;0e99	Check for '?' in the argument
5484  0E9A              l0e9ah:
5485  0E9A
5486  0E9A F5           	push af		;0e9a	Push result of READ_PAR.
5487  0E9B
5488  0E9B DF           	rst 18h		;0e9b	Call READ_PAR
5489  0E9C 0D           	db 00dh		;0e9c	ASCII CR
5490  0E9D 02           	db l0ea0h-$-1	;0e9d
5491  0E9E
5492  0E9E EF           	rst 28h		;0e9e	Call CLEAR_HL
5493  0E9F 3E           	db 03eh		;0e9f	Dummy ld a,	(ignores "rst 8" instruction,
5494  0EA0              			;			if there was no parameter)
5495  0EA0              l0ea0h:
5496  0EA0 CF           	rst 8		;0ea0	Read load offset to HL (Call EVAL_INT_EXP)
5497  0EA1
5498  0EA1 E5           	push hl		;0ea1	Store load offset on stack
5499  0EA2
5500  0EA2 F3           	di		;0ea2	Disable interrupts
5501  0EA3
5502  0EA3              ; Wait for the start byte (a5h)
5503  0EA3
5504  0EA3              l0ea3h:
5505  0EA3 CD DD 0E     	call l0eddh	;0ea3	Call LOAD_BYTE
5506  0EA6 79           	ld a,c		;0ea6
5507  0EA7 FE A5        	cp 0a5h		;0ea7	Compare loaded byte with a5h and ...
5508  0EA9 20 F8        	jr nz,l0ea3h	;0ea9	... loop if not equal.
5509  0EAB
5510  0EAB 47           	ld b,a		;0eab	Load a5h into B
5511  0EAC              			;	(value of the first loaded byte, for checksum)
5512  0EAC CD D9 0E     	call l0ed9h	;0eac	Call LOAD_WORD (start address)
5513  0EAF 61           	ld h,c		;0eaf
5514  0EB0
5515  0EB0 D1           	pop de		;0eb0	Fetch load offset from stack and add it
5516  0EB1 D5           	push de		;0eb1	to the start address.
5517  0EB2 19           	add hl,de	;0eb2
5518  0EB3
5519  0EB3 EB           	ex de,hl	;0eb3	DE = start address
5520  0EB4
5521  0EB4 CD D9 0E     	call l0ed9h	;0eb4	Call LOAD_WORD (end address)
5522  0EB7 61           	ld h,c		;0eb7
5523  0EB8
5524  0EB8 2B           	dec hl		;0eb8	Decrement end address
5525  0EB9              			;	HL = address of last byte to load
5526  0EB9
5527  0EB9 78           	ld a,b		;0eb9	Save checksum to A
5528  0EBA
5529  0EBA C1           	pop bc		;0eba	Add load offset
5530  0EBB 09           	add hl,bc	;0ebb
5531  0EBC
5532  0EBC 47           	ld b,a		;0ebc	Restore checksum to B
5533  0EBD
5534  0EBD              l0ebdh:
5535  0EBD EB           	ex de,hl	;0ebd	HL = address of the current byte
5536  0EBE              			;	DE = address of the last byte
5537  0EBE
5538  0EBE CD DD 0E     	call l0eddh	;0ebe	Call LOAD_BYTE
5539  0EC1 08           	ex af,af'	;0ec1	F' holds results of CMP_HL_DE
5540  0EC2
5541  0EC2 79           	ld a,c		;0ec2	Compare loaded byte with (HL) and ...
5542  0EC3 BE           	cp (hl)		;0ec3
5543  0EC4 28 05        	jr z,l0ecbh	;0ec4	... jump forward if equal
5544  0EC6
5545  0EC6 F1           	pop af		;0ec6	Restore flags
5546  0EC7 28 0D        	jr z,l0ed6h	;0ec7	Jump to WHAT_RST if loaded byte not equal
5547  0EC9              			;	to memory byte and verify mode is enabled
5548  0EC9              			;	(Z flag is set by the READ_PAR function).
5549  0EC9 F5           	push af		;0ec9	Save flags
5550  0ECA
5551  0ECA 71           	ld (hl),c	;0eca	Store loaded byte in memory
5552  0ECB
5553  0ECB              l0ecbh:
5554  0ECB 23           	inc hl		;0ecb	Increment HL
5555  0ECC
5556  0ECC EB           	ex de,hl	;0ecc	DE = address of the current byte
5557  0ECD              			;	HL = address of the last byte
5558  0ECD
5559  0ECD 08           	ex af,af'	;0ecd
5560  0ECE 38 ED        	jr c,l0ebdh	;0ece	Loop if current address < last address
5561  0ED0
5562  0ED0 CD DD 0E     	call l0eddh	;0ed0	Call LOAD_BYTE (checksum)
5563  0ED3 F1           	pop af		;0ed3	Remove stored flags from stack
5564  0ED4
5565  0ED4 04           	inc b		;0ed4	Return if B = ffh, else display WHAT? error
5566  0ED5 C8           	ret z		;0ed5
5567  0ED6
5568  0ED6              l0ed6h:
5569  0ED6 C3 8F 07     	jp l078fh	;0ed6	Jump to WHAT_RST
5570  0ED9              			;	Tape loading error
5571  0ED9
5572  0ED9              ; 'LOAD WORD'
5573  0ED9              ; ===========
5574  0ED9              ; Loads one word (16 bits) from the audio cassette. It executes CMP_HL_DE
5575  0ED9              ; function and returns its result in the flag register.
5576  0ED9
5577  0ED9              ; Returns:
5578  0ED9              ;	L: low byte
5579  0ED9              ;	C: high byte
5580  0ED9              ;	B: B = B + sum of both loaded bytes
5581  0ED9              ;	flags: Result of the CMP_HL_DE function.
5582  0ED9
5583  0ED9              ;; LOAD_WORD
5584  0ED9              l0ed9h:
5585  0ED9 CD DD 0E     	call l0eddh	;0ed9	Call LOAD_BYTE
5586  0EDC 69           	ld l,c		;0edc	Save result into L
5587  0EDD
5588  0EDD              ; Continue with another LOAD_BYTE and return
5589  0EDD
5590  0EDD              ; 'LOAD BYTE'
5591  0EDD              ; ===========
5592  0EDD              ; This function loads one byte from the audio cassette.
5593  0EDD
5594  0EDD              ; Returns:
5595  0EDD              ;	C: byte loaded
5596  0EDD              ;	B: B = B + C
5597  0EDD
5598  0EDD              ;; LOAD_BYTE
5599  0EDD              l0eddh:
5600  0EDD D9           	exx		;0edd
5601  0EDE 06 01        	ld b,001h	;0ede	Load 1 into B'
5602  0EE0
5603  0EE0              l0ee0h:
5604  0EE0 3E A7        	ld a,0a7h	;0ee0	Load 167 into A
5605  0EE2
5606  0EE2              ; This block waits for an impulse on the cassette port. If B' = 1 (on first
5607  0EE2              ; iteration), it waits indefinitely. If B' = 0 it waits for A loop iterations.
5608  0EE2
5609  0EE2              ; 49 T * 167 = 8183 T = 2.7ms
5610  0EE2
5611  0EE2              ;; LOAD_WAIT_PULSE
5612  0EE2              l0ee2h:
5613  0EE2 80           	add a,b		;0ee2	4	Add B' to A
5614  0EE3 21 00 20     	ld hl,02000h	;0ee3	10	Load cassette port address into HL'
5615  0EE6 CB 46        	bit 0,(hl)	;0ee6	12	Test bit 0
5616  0EE8 28 07        	jr z,l0ef1h	;0ee8	12,7	If impulse was detected, break loop...
5617  0EEA 3D           	dec a		;0eea	4	...else decrement A and
5618  0EEB 20 F5        	jr nz,l0ee2h	;0eeb	12,7	   loop to LOAD_WAIT_PULSE if not zero
5619  0EED
5620  0EED D9           	exx		;0eed	4
5621  0EEE 79           	ld a,c		;0eee	4	Load C into A
5622  0EEF
5623  0EEF 18 A2        	jr l0e93h	;0eef		B = A + B, compare HL with DE
5624  0EF1              			;		and return from function
5625  0EF1
5626  0EF1              l0ef1h:
5627  0EF1
5628  0EF1              ; Pause for 4369 T = 1.42 ms
5629  0EF1
5630  0EF1 06 DA        	ld b,0dah	;0ef1	7	Load 218 into B'
5631  0EF3              l0ef3h:
5632  0EF3 3E A9        	ld a,0a9h	;0ef3	7	Load a9h into A
5633  0EF5 10 FC        	djnz l0ef3h	;0ef5	13,8	Loop
5634  0EF7
5635  0EF7 06 5A        	ld b,05ah	;0ef7	7	Load 90 into B'
5636  0EF9
5637  0EF9              ; This loop checks if the first pulse is followed by another one in specified
5638  0EF9              ; time interval. It has 90 iterations, each 35 T (11.4us) long. If input is
5639  0EF9              ; low in more than 4 iterations (so that A doesn't overflow), then bit 1 is
5640  0EF9              ; loaded into C. Else bit 0.
5641  0EF9
5642  0EF9              ; This gives a minimum pulse width of 140 T (45 us).
5643  0EF9
5644  0EF9              ;; LOAD_READ_PULSE
5645  0EF9              l0ef9h:
5646  0EF9 4E           	ld c,(hl)	;0ef9	7	Load C' from cassette port
5647  0EFA CB 19        	rr c		;0efa	8	Move bit 0 into carry flag...
5648  0EFC CE 00        	adc a,000h	;0efc	7	...and add it to A
5649  0EFE 10 F9        	djnz l0ef9h	;0efe	13,8	Loop to LOAD_READ_PULSE
5650  0F00
5651  0F00 07           	rlca		;0f00	Rotate A left (MSB into carry flag)
5652  0F01 D9           	exx		;0f01
5653  0F02 CB 19        	rr c		;0f02	Rotate C right (carry flag into MSB)
5654  0F04 D9           	exx		;0f04
5655  0F05
5656  0F05 18 D9        	jr l0ee0h	;0f05	Loop LOAD_WAIT_PULSE (B' = 0)
5657  0F07
5658  0F07              ; **********************************
5659  0F07              ; * BASIC INTERPRETER DATA SECTION *
5660  0F07              ; **********************************
5661  0F07
5662  0F07              ; 'READY STRING'
5663  0F07              ; ==============
5664  0F07              ; Command prompt string, printed when in command line mode.
5665  0F07              ;; READY
5666  0F07              l0f07h:
5667  0F07 40 27        	dm 040h, 027h			;0f07
5668  0F09 52 45 41 44  	dm "READY", 00dh		;0f09
5668  0F0D 59 0D
5669  0F0F
5670  0F0F              ; 'BASIC TABLES'
5671  0F0F              ; ==============
5672  0F0F              ; Following section contains tables for the BASIC interpreter
5673  0F0F              ; (NOTE: complete table must fit into 0fxxh page)
5674  0F0F
5675  0F0F              ; Format of the table is:
5676  0F0F              ;	dm 	"function name"
5677  0F0F              ;	db 	"high byte of function's address" + 80h
5678  0F0F              ;			( + 40h if function takes an integer argument in
5679  0F0F              ;			parenthesis)
5680  0F0F              ;	db 	"low byte of function's address"
5681  0F0F
5682  0F0F              ; A catch-all rule lacks the function name.
5683  0F0F
5684  0F0F              ; 'BASIC COMMAND LINE TABLE'
5685  0F0F              ; ==========================
5686  0F0F              ; These BASIC commands take zero or one integer argument and can only appear
5687  0F0F              ; on the command line.
5688  0F0F
5689  0F0F              ;; BASIC_CMDLINE_TABLE
5690  0F0F              l0f0fh:
5691  0F0F 4C 49 53 54  	dm "LIST"			;0f0f
5692  0F13 84           	db ((l045eh>>8)&00ffh)+80h	;0f13
5693  0F14 5E           	db (l045eh)&00ffh		;0f14
5694  0F15
5695  0F15 52 55 4E     	dm "RUN"			;0f15
5696  0F18 84           	db ((l040bh>>8)&00ffh)+80h	;0f18
5697  0F19 0B           	db (l040bh)&00ffh		;0f19
5698  0F1A
5699  0F1A 4E 45 57     	dm "NEW"			;0f1a
5700  0F1D 83           	db ((l03fch>>8)&00ffh)+80h	;0f1d
5701  0F1E FC           	db (l03fch)&00ffh		;0f1e
5702  0F1F
5703  0F1F 53 41 56 45  	dm "SAVE"			;0f1f
5704  0F23 8E           	db ((l0e30h>>8)&00ffh)+80h	;0f23
5705  0F24 30           	db (l0e30h)&00ffh		;0f24
5706  0F25
5707  0F25 4F 4C 44     	dm "OLD"			;0f25
5708  0F28 8E           	db ((l0e97h>>8)&00ffh)+80h	;0f28
5709  0F29 97           	db (l0e97h)&00ffh		;0f29
5710  0F2A
5711  0F2A 45 44 49 54  	dm "EDIT"			;0f2a
5712  0F2E 82           	db ((l0299h>>8)&00ffh)+80h	;0f2e
5713  0F2F 99           	db (l0299h)&00ffh		;0f2f
5714  0F30
5715  0F30              ; 'BASIC COMMAND TABLE'
5716  0F30              ; =====================
5717  0F30              ; These BASIC commands take zero or one integer argument and jump to
5718  0F30              ; RUN_THIS_LINE routine (or one of interpreter's other entry points) at the
5719  0F30              ; end.
5720  0F30
5721  0F30              ;; BASIC_CMD_TABLE
5722  0F30              l0f30h:
5723  0F30 4E 45 58 54  	dm "NEXT"			;0f30
5724  0F34 85           	db ((l0564h>>8)&00ffh)+80h	;0f34
5725  0F35 64           	db (l0564h)&00ffh		;0f35
5726  0F36
5727  0F36 49 4E 50 55  	dm "INPUT"			;0f36
5727  0F3A 54
5728  0F3B 86           	db ((l066ch>>8)&00ffh)+80h	;0f3b
5729  0F3C 6C           	db (l066ch)&00ffh		;0f3c
5730  0F3D
5731  0F3D 49 46        	dm "IF"				;0f3d
5732  0F3F 84           	db ((l0441h>>8)&00ffh)+80h	;0f3f
5733  0F40 41           	db (l0441h)&00ffh		;0f40
5734  0F41
5735  0F41 47 4F 54 4F  	dm "GOTO"			;0f41
5736  0F45 84           	db ((l0453h>>8)&00ffh)+80h	;0f45
5737  0F46 53           	db (l0453h)&00ffh		;0f46
5738  0F47
5739  0F47 43 41 4C 4C  	dm "CALL"			;0f47
5740  0F4B 84           	db ((l04f4h>>8)&00ffh)+80h	;0f4b
5741  0F4C F4           	db (l04f4h)&00ffh		;0f4c
5742  0F4D
5743  0F4D 55 4E 44 4F  	dm "UNDOT"			;0f4d
5743  0F51 54
5744  0F52 86           	db ((l06cch>>8)&00ffh)+80h	;0f52
5745  0F53 CC           	db (l06cch)&00ffh		;0f53
5746  0F54
5747  0F54 52 45 54     	dm "RET"			;0f54
5748  0F57 85           	db ((l0512h>>8)&00ffh)+80h	;0f57
5749  0F58 12           	db (l0512h)&00ffh		;0f58
5750  0F59
5751  0F59 54 41 4B 45  	dm "TAKE"			;0f59
5752  0F5D 86           	db ((l0626h>>8)&00ffh)+80h	;0f5d
5753  0F5E 26           	db (l0626h)&00ffh		;0f5e
5754  0F5F
5755  0F5F 21           	dm "!"				;0f5f
5756  0F60 84           	db ((l044dh>>8)&00ffh)+80h	;0f60
5757  0F61 4D           	db (l044dh)&00ffh		;0f61
5758  0F62
5759  0F62 23           	dm "#"				;0f62
5760  0F63 84           	db ((l044dh>>8)&00ffh)+80h	;0f63
5761  0F64 4D           	db (l044dh)&00ffh		;0f64
5762  0F65
5763  0F65 46 4F 52     	dm "FOR"			;0f65
5764  0F68 8E           	db ((l0e18h>>8)&00ffh)+80h	;0f68
5765  0F69 18           	db (l0e18h)&00ffh		;0f69
5766  0F6A
5767  0F6A 50 52 49 4E  	dm "PRINT"			;0f69
5767  0F6E 54
5768  0F6F 84           	db ((l0480h>>8)&00ffh)+80h	;0f6f
5769  0F70 80           	db (l0480h)&00ffh		;0f70
5770  0F71
5771  0F71 44 4F 54     	dm "DOT"			;0f71
5772  0F74 86           	db ((l06cfh>>8)&00ffh)+80h	;0f74
5773  0F75 CF           	db (l06cfh)&00ffh		;0f75
5774  0F76
5775  0F76 45 4C 53 45  	dm "ELSE"			;0f76
5776  0F7A 84           	db ((l044dh>>8)&00ffh)+80h	;0f7a
5777  0F7B 4D           	db (l044dh)&00ffh		;0f7b
5778  0F7C
5779  0F7C 42 59 54 45  	dm "BYTE"			;0f7c
5780  0F80 8D           	db ((l0dffh>>8)&00ffh)+80h	;0f80
5781  0F81 FF           	db (l0dffh)&00ffh		;0f81
5782  0F82
5783  0F82 57 4F 52 44  	dm "WORD"			;0f82
5784  0F86 8D           	db ((l0dfeh>>8)&00ffh)+80h	;0f86
5785  0F87 FE           	db (l0dfeh)&00ffh		;0f87
5786  0F88
5787  0F88 41 52 52 24  	dm "ARR$"			;0f88
5788  0F8C C1           	db ((l010bh>>8)&00ffh)+80h+40h	;0f8c
5789  0F8D 0B           	db (l010bh)&00ffh		;0f8d
5790  0F8E
5791  0F8E 53 54 4F 50  	dm "STOP"			;0f8e
5792  0F92 83           	db ((l0317h>>8)&00ffh)+80h	;0f92
5793  0F93 17           	db (l0317h)&00ffh		;0f93
5794  0F94
5795  0F94 48 4F 4D 45  	dm "HOME"			;0f94
5796  0F98 84           	db ((l04d6h>>8)&00ffh)+80h	;0f98
5797  0F99 D6           	db (l04d6h)&00ffh		;0f99
5798  0F9A
5799  0F9A              ; Catch-all rule for BASIC commands.
5800  0F9A
5801  0F9A 87           	db ((l075bh>>8)&00ffh)+80h	;0f9a
5802  0F9B 5B           	db (l075bh)&00ffh		;0f9b
5803  0F9C
5804  0F9C              ; 'BASIC FUNCTION TABLE'
5805  0F9C              ; ======================
5806  0F9C              ; These BASIC functions take zero or one integer arguments and leave a
5807  0F9C              ; floating point value on the arithmetic stack after they return.
5808  0F9C
5809  0F9C              ;; BASIC_FUNC_TABLE
5810  0F9C              l0f9ch:
5811  0F9C 52 4E 44     	dm "RND" 			;0f9c
5812  0F9F 8C           	db ((l0c8fh>>8)&00ffh)+80h	;0f9f
5813  0FA0 8F           	db (l0c8fh)&00ffh		;0fa0
5814  0FA1
5815  0FA1 4D 45 4D     	dm "MEM"			;0fa1
5816  0FA4 8D           	db ((l0d9ah>>8)&00ffh)+80h	;0fa4
5817  0FA5 9A           	db (l0d9ah)&00ffh		;0fa5
5818  0FA6
5819  0FA6 4B 45 59     	dm "KEY" 			;0fa6
5820  0FA9 CD           	db ((l0dabh>>8)&00ffh)+80h+40h	;0fa9
5821  0FAA AB           	db (l0dabh)&00ffh		;0faa
5822  0FAB
5823  0FAB 42 59 54 45  	dm "BYTE"			;0fab
5824  0FAF CD           	db ((l0dbch>>8)&00ffh)+80h+40h	;0faf
5825  0FB0 BC           	db (l0dbch)&00ffh		;0fb0
5826  0FB1
5827  0FB1 57 4F 52 44  	dm "WORD"			;0fb1
5828  0FB5 CD           	db ((l0da5h>>8)&00ffh)+80h+40h	;0fb5
5829  0FB6 A5           	db (l0da5h)&00ffh		;0fb6
5830  0FB7
5831  0FB7 50 54 52     	dm "PTR"			;0fb7
5832  0FBA 87           	db ((l0769h>>8)&00ffh)+80h	;0fba
5833  0FBB 69           	db (l0769h)&00ffh		;0fbb
5834  0FBC
5835  0FBC 56 41 4C     	dm "VAL"			;0fbc
5836  0FBF C7           	db ((l0770h>>8)&00ffh)+80h+40h	;0fbf
5837  0FC0 70           	db (l0770h)&00ffh		;0fc0
5838  0FC1
5839  0FC1 45 51        	dm "EQ"				;0fc1
5840  0FC3 8D           	db ((l0dc2h>>8)&00ffh)+80h	;0fc3
5841  0FC4 C2           	db (l0dc2h)&00ffh		;0fc4
5842  0FC5
5843  0FC5 49 4E 54     	dm "INT"			;0fc5
5844  0FC8 CA           	db ((l0abch>>8)&00ffh)+80h+40h	;0fc8
5845  0FC9 BC           	db (l0abch)&00ffh		;0fc9
5846  0FCA
5847  0FCA 26           	dm "&"				;0fca
5848  0FCB 8D           	db ((l0ddfh>>8)&00ffh)+80h	;0fcb
5849  0FCC DF           	db (l0ddfh)&00ffh		;0fcc
5850  0FCD
5851  0FCD 55 53 52     	dm "USR"			;0fcd
5852  0FD0 CE           	db ((l0e0fh>>8)&00ffh)+80h+40h	;0fd0
5853  0FD1 0F           	db (l0e0fh)&00ffh		;0fd1
5854  0FD2
5855  0FD2 44 4F 54     	dm "DOT"			;0fd2
5856  0FD5 86           	db ((l06dch>>8)&00ffh)+80h	;0fd5
5857  0FD6 DC           	db (l06dch)&00ffh		;0fd6
5858  0FD7
5859  0FD7              ; Catch-all rule for BASIC functions.
5860  0FD7
5861  0FD7 87           	db ((l0777h>>8)&00ffh)+80h	;0fd7
5862  0FD8 77           	db (l0777h)&00ffh		;0fd8
5863  0FD9
5864  0FD9 53 54 45 50  	dm "STEP"			;0fd9
5865  0FDD 85           	db ((l0528h>>8)&00ffh)+80h	;0fdd
5866  0FDE 28           	db (l0528h)&00ffh		;0fde
5867  0FDF
5868  0FDF              ; Catch-all rule
5869  0FDF
5870  0FDF 85           	db ((l052ah>>8)&00ffh)+80h	;0fdf
5871  0FE0 2A           	db (l052ah)&00ffh		;0fe0
5872  0FE1
5873  0FE1              ; 'BASIC "PRINT" COMMAND TABLE'
5874  0FE1              ; =============================
5875  0FE1              ; These BASIC commands can only appear after the "PRINT" command. They
5876  0FE1              ; jump to RUN_THIS_LINE routine (or one of interpreter's other entry points)
5877  0FE1              ; at the end.
5878  0FE1
5879  0FE1              ;; BASIC_PRINT_TABLE
5880  0FE1              l0fe1h:
5881  0FE1
5882  0FE1 41 54        	dm "AT"				;0fe1
5883  0FE3 84           	db ((l04bch>>8)&00ffh)+80h	;0fe3
5884  0FE4 BC           	db (l04bch)&00ffh		;0fe4
5885  0FE5
5886  0FE5 58 24        	dm "X$"				;0fe5
5887  0FE7 84           	db ((l0498h>>8)&00ffh)+80h	;0fe7
5888  0FE8 98           	db (l0498h)&00ffh		;0fe8
5889  0FE9
5890  0FE9 59 24        	dm "Y$"				;0fe9
5891  0FEB 84           	db ((l049bh>>8)&00ffh)+80h	;0feb
5892  0FEC 9B           	db (l049bh)&00ffh		;0fec
5893  0FED
5894  0FED              ; Catch-all rule
5895  0FED
5896  0FED 84           	db ((l048eh>>8)&00ffh)+80h	;0fed
5897  0FEE 8E           	db (l048eh)&00ffh		;0fee
5898  0FEF
5899  0FEF 43 48 52 24  	dm "CHR$"			;0fef
5900  0FF3 CE           	db ((l0e15h>>8)&00ffh)+80h+40h	;0ff3
5901  0FF4 15           	db (l0e15h)&00ffh		;0ff4
5902  0FF5
5903  0FF5              ; Catch-all rule
5904  0FF5
5905  0FF5 86           	db ((l060bh>>8)&00ffh)+80h	;0ff5
5906  0FF6 0B           	db (l060bh)&00ffh		;0ff6
5907  0FF7
5908  0FF7 45 4C 53 45  	dm "ELSE"			;0ff7
5909  0FFB 84           	db ((l041ah>>8)&00ffh)+80h	;0ffb
5910  0FFC 1A           	db (l041ah)&00ffh		;0ffc
5911  0FFD
5912  0FFD              ; Catch-all rule
5913  0FFD
5914  0FFD 88           	db ((l081bh>>8)&00ffh)+80h	;0ffd
5915  0FFE 1B           	db (l081bh)&00ffh		;0ffe
5916  0FFF
5917  0FFF              ; One (!) spare byte
5918  0FFF
5919  0FFF 00           	db 00h				;0fff
5920  1000
5921  1000              	end
# file closed: .//rom_a.asm
